[{"path":"index.html","id":"關於","chapter":"關於","heading":"關於","text":"程式設計與資料科學導論實習課講義GitHub課程影片","code":""},{"path":"ch01.html","id":"ch01","chapter":"1 掌握你的電腦","heading":"1 掌握你的電腦","text":"(投影片 /\n影片)","code":""},{"path":"ch01.html","id":"路徑-工作目錄","chapter":"1 掌握你的電腦","heading":"1.1 路徑 & 工作目錄","text":"電腦透過資料夾 (directory) 與檔案 (file) 將資訊組織起來，方便與使用者互動。資料夾裡面可以是另一個資料夾，也可以是檔案。換言之，資料夾是有階層結構的，可以一層層的包覆起來電腦透過資料夾 (directory) 與檔案 (file) 將資訊組織起來，方便與使用者互動。資料夾裡面可以是另一個資料夾，也可以是檔案。換言之，資料夾是有階層結構的，可以一層層的包覆起來在使用電腦時，我們通常是透過圖形使用者界面 (GUI) 與電腦互動。在操作檔案與資料夾時，我們通常會透過檔案管理員這類的程式 (Figure 1.1)在使用電腦時，我們通常是透過圖形使用者界面 (GUI) 與電腦互動。在操作檔案與資料夾時，我們通常會透過檔案管理員這類的程式 (Figure 1.1)\nFigure 1.1: Windows 與 Mac 的檔案管理界面1\n對於初次接觸程式的同學，需要逐步習慣使用 Text-based user interfaces (TUI) (下圖)。透過 TUI 與電腦互動意謂著使用者(幾乎)只能使用鍵盤，也意謂著使用者需了解更多的程式指令以及電腦組織檔案與資料夾的方式。但與此同時，使用者將能更好地掌握自己的電腦2\n對於初次接觸程式的同學，需要逐步習慣使用 Text-based user interfaces (TUI) (下圖)。透過 TUI 與電腦互動意謂著使用者(幾乎)只能使用鍵盤，也意謂著使用者需了解更多的程式指令以及電腦組織檔案與資料夾的方式。但與此同時，使用者將能更好地掌握自己的電腦2","code":""},{"path":"ch01.html","id":"目錄結構-directory-structure","chapter":"1 掌握你的電腦","heading":"1.1.1 目錄結構 (Directory structure)","text":"為方便理解電腦裡面的資料夾與檔案結構 (簡稱目錄結構)，我們通常會以樹狀結構去表示目錄結構。Figure 1.2 是 Windows 以及 Mac 上的目錄結構圖為方便理解電腦裡面的資料夾與檔案結構 (簡稱目錄結構)，我們通常會以樹狀結構去表示目錄結構。Figure 1.2 是 Windows 以及 Mac 上的目錄結構圖在樹狀圖中，越上方的資料夾階層越高。最上方的資料夾稱為根目錄 (root)，電腦中的所有其它資料夾與檔案皆位於根目錄之內3在樹狀圖中，越上方的資料夾階層越高。最上方的資料夾稱為根目錄 (root)，電腦中的所有其它資料夾與檔案皆位於根目錄之內3\nFigure 1.2: 目錄結構\n以 Figure 1.2 為例，\nWindows 的根目錄 C: 裡有 3 個資料夾 temp, Users, 以及 Windows，其中的 Users 之下又有 3 個資料夾 Tiger, Pooh 與 Piglet\nMac 的根目錄以 / 表示，裡面有 3 個資料夾 Library, Users 以及 System。Users 之下有 Tiger, Pooh 與 Piglet 3 個資料夾\nWindows 的根目錄 C: 裡有 3 個資料夾 temp, Users, 以及 Windows，其中的 Users 之下又有 3 個資料夾 Tiger, Pooh 與 PigletMac 的根目錄以 / 表示，裡面有 3 個資料夾 Library, Users 以及 System。Users 之下有 Tiger, Pooh 與 Piglet 3 個資料夾","code":""},{"path":"ch01.html","id":"路徑-path","chapter":"1 掌握你的電腦","heading":"1.1.2 路徑 (Path)","text":"使用 Text-based user interfaces (TUI) 與電腦互動時，需要一套用來描述路徑 (Path) (亦即, 某個資料夾或檔案位於電腦上的哪個位置) 的語法。這套語法基本上就是在告訴電腦「如何從 資料夾『走到』目標資料夾 (或檔案)」","code":""},{"path":"ch01.html","id":"絕對路徑","chapter":"1 掌握你的電腦","heading":"1.1.2.1 絕對路徑","text":"絕對路徑就是在告訴電腦「如何從根目錄 (root)走到目標資料夾 (或檔案)」/ 在描述路徑時具有 2 種語意：\n若 / 出現在路徑的起始 (e.g., /Users)，則其代表的是根目錄 (Windows 的 C: 以及 Mac 的 /)\n若 / 出現在 路徑的中間 (e.g., C:/Users/Pooh)，則是作為母 (Parent) 子 (Child) 資料夾之間的分隔符號\n若 / 出現在路徑的起始 (e.g., /Users)，則其代表的是根目錄 (Windows 的 C: 以及 Mac 的 /)若 / 出現在 路徑的中間 (e.g., C:/Users/Pooh)，則是作為母 (Parent) 子 (Child) 資料夾之間的分隔符號舉例來說，\n若要告訴電腦根目錄的位置，只須輸入根目錄的名稱：\nC: (Windows)/ (Mac)\n\n若要告訴電腦 Tiger 的位置，則可以在根目錄後面依序輸入 Users 與 Tiger，並使用 / 作為資料夾間的分隔線：\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\n\n若要告訴電腦根目錄的位置，只須輸入根目錄的名稱：\nC: (Windows)/ (Mac)\nC: (Windows)/ (Mac)若要告訴電腦 Tiger 的位置，則可以在根目錄後面依序輸入 Users 與 Tiger，並使用 / 作為資料夾間的分隔線：\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\nFigure 1.3: 絕對路徑\n現在是時候打開終端機 (Terminal) 玩玩看了 (解鎖你電腦的 1 號隱藏功能)。按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：\nC:\\Users\\{username}\n這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在 Finder 搜尋 Terminal 或 終端機在 Finder 搜尋 Terminal 或 終端機在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑\n/Users/{username}\n這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱這個出現在終端機上的絕對路徑即是目前終端機程式的工作目錄。所以到底什麼是工作目錄？由於程式 (e.g., 終端機, R, Python, Chrome, …) 運行時需要與電腦進行互動，換言之，它們經常需要讀取、修改、刪除與寫入檔案與資料夾，但同時又不需要知道電腦上完整的目錄結構，因此它們需要有一個參照用的資料夾，以此資料夾作為描述路徑的基準。這個參照的資料夾就如同執行中的程式工作的地方，因此稱為工作目錄；而用來描述相對於工作目錄的路徑則稱為相對路徑。而上面 C:\\Users\\{username} (Windows) 與 /Users/{username} (Mac) 這兩個路徑， 即是終端機開啟時預設的工作目錄。下方介紹完相對路徑後，接著會告訴大家如何更改工作目錄。","code":"C:\\Users\\{username}/Users/{username}"},{"path":"ch01.html","id":"windows","chapter":"1 掌握你的電腦","heading":"Windows","text":"按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：\nC:\\Users\\{username}\n這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱","code":"C:\\Users\\{username}"},{"path":"ch01.html","id":"mac","chapter":"1 掌握你的電腦","heading":"Mac","text":"在 Finder 搜尋 Terminal 或 終端機在 Finder 搜尋 Terminal 或 終端機在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑\n/Users/{username}\n這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱","code":"/Users/{username}"},{"path":"ch01.html","id":"工作目錄-working-directory","chapter":"1 掌握你的電腦","heading":"工作目錄 (Working Directory)","text":"這個出現在終端機上的絕對路徑即是目前終端機程式的工作目錄。所以到底什麼是工作目錄？由於程式 (e.g., 終端機, R, Python, Chrome, …) 運行時需要與電腦進行互動，換言之，它們經常需要讀取、修改、刪除與寫入檔案與資料夾，但同時又不需要知道電腦上完整的目錄結構，因此它們需要有一個參照用的資料夾，以此資料夾作為描述路徑的基準。這個參照的資料夾就如同執行中的程式工作的地方，因此稱為工作目錄；而用來描述相對於工作目錄的路徑則稱為相對路徑。而上面 C:\\Users\\{username} (Windows) 與 /Users/{username} (Mac) 這兩個路徑， 即是終端機開啟時預設的工作目錄。下方介紹完相對路徑後，接著會告訴大家如何更改工作目錄。","code":""},{"path":"ch01.html","id":"相對路徑","chapter":"1 掌握你的電腦","heading":"1.1.2.2 相對路徑","text":"相對路徑就是在告訴電腦「如何從工作目錄 (working directory) 走到目標資料夾 (或檔案)」。以下方的目錄結構為例 (工作目錄設在 /Users/Pooh)，\nFigure 1.4: 範例目錄結構。在此例中，工作目錄設置在 Pooh\n. 表示的是「當前」的目錄，所以若其出現在路徑的開頭，即是指工作目錄5。所以透過相對路徑表示工作目錄非常簡短：\n.. 表示的是「當前」的目錄，所以若其出現在路徑的開頭，即是指工作目錄5。所以透過相對路徑表示工作目錄非常簡短：若要表示工作目錄之下的檔案或資料夾，例如 Desktop，其相對路徑即為其名稱：\nDesktop\n或是，也可以在透過 . 表示當前目錄之後，再於後方加入檔案或資料夾的名稱：\n./Desktop若要表示工作目錄之下的檔案或資料夾，例如 Desktop，其相對路徑即為其名稱：或是，也可以在透過 . 表示當前目錄之後，再於後方加入檔案或資料夾的名稱：依此類推，工作目錄下面兩個階層的檔案或資料夾 (例如，.txt) 的相對路徑為：\nDesktop/.txt\n./Desktop/.txt依此類推，工作目錄下面兩個階層的檔案或資料夾 (例如，.txt) 的相對路徑為：.. 則讓我們可以往上走。例如，若想表示工作目錄的母資料夾 Users，可以使用 ..：\n..\n./.... 則讓我們可以往上走。例如，若想表示工作目錄的母資料夾 Users，可以使用 ..：這讓我們可以很方便地表示工作目錄的「姊妹」資料夾 Tiger (它們共同的母資料夾是 Users)：\n../Tiger\n./../Tiger\n\n\nFigure 1.5: 透過相對路徑表示「姊妹」的資料夾\n\n這讓我們可以很方便地表示工作目錄的「姊妹」資料夾 Tiger (它們共同的母資料夾是 Users)：\nFigure 1.5: 透過相對路徑表示「姊妹」的資料夾\n同理，若要表達 Tiger 之下的 .txt，只需在原本的路徑之後加入檔名：\n../Tiger/.txt\n./../Tiger/.txt同理，若要表達 Tiger 之下的 .txt，只需在原本的路徑之後加入檔名：透過終端機更改工作目錄的指令很簡單：cd (“change directory”) + 絕對/相對路徑6。所以假設想將 Figure 1.5 中的工作目錄 Pooh 更改成 Tiger，只要輸入：或Windows 系統上的路徑使用的是反斜線 \\ 作為分隔符號，與其它系統 (Mac, Linux 等) 以及各種程式語言 (R, Python 等) 使用的 / 不同。但近年的 Windows 系統已讓使用者能輸入 / 作為路徑中的分隔7。由於反斜線 \\ 在許多程式語言中常具有特殊的功能，這邊強烈建議大家路徑中不要使用反斜線 \\，請使用 /。這麼做的好處之一，是讓你撰寫的程式可以同時在 Windows 以及其它系統上運行8。","code":".Desktop./DesktopDesktop/i.txt\n./Desktop/i.txt..\n./..../Tiger\n./../Tiger../Tiger/he.txt\n./../Tiger/he.txtcd ../Tigercd /Users/Tiger"},{"path":"ch01.html","id":"windows-路徑中的反斜線","chapter":"1 掌握你的電腦","heading":"Windows 路徑中的反斜線 (\\)","text":"Windows 系統上的路徑使用的是反斜線 \\ 作為分隔符號，與其它系統 (Mac, Linux 等) 以及各種程式語言 (R, Python 等) 使用的 / 不同。但近年的 Windows 系統已讓使用者能輸入 / 作為路徑中的分隔7。由於反斜線 \\ 在許多程式語言中常具有特殊的功能，這邊強烈建議大家路徑中不要使用反斜線 \\，請使用 /。這麼做的好處之一，是讓你撰寫的程式可以同時在 Windows 以及其它系統上運行8。","code":""},{"path":"ch01.html","id":"r-101","chapter":"1 掌握你的電腦","heading":"1.2 R 101","text":"現在我們已經知道如何操作終端機了。接下來，我們就可以透過終端機執行我們的第一支 R 程式：透過文字編輯器9新增一份純文字檔，將檔案命名為 hello.R。hello.R 內請寫下：\n\nprint(\"Hello World!\")透過文字編輯器9新增一份純文字檔，將檔案命名為 hello.R。hello.R 內請寫下：打開終端機，cd 到 hello.R 所在的資料夾 (e.g., C:/Users/Tiger/Desktop)，再執行 Rscript hello.R:\ncd ./Desktop\nRscript hello.R打開終端機，cd 到 hello.R 所在的資料夾 (e.g., C:/Users/Tiger/Desktop)，再執行 Rscript hello.R:這時，你應該會看到終端機裡印出：\n[1] \"Hello World!\"這時，你應該會看到終端機裡印出：試著修改 hello.R 的內容，然後重複執行 Rscript hello.R，看看輸出指令如何改變。你可以嘗試以下的指令：print(\"Hi\")(2 + 7) / 102 ^ 31:4在 hello.R 裡面，你可以輸入不只一條指令，但注意，每一條指令需佔獨立的一行。例如，若要輸入三條指令，hello.R 的樣子會類似：","code":"\nprint(\"Hello World!\")cd ./Desktop\nRscript hello.R[1] \"Hello World!\"\nprint(\"Hello world\")\nprint(\"Hi\")\n(2 + 7) / 10"},{"path":"ch01.html","id":"r-script","chapter":"1 掌握你的電腦","heading":"1.2.1 R Script","text":"hello.R 這類用來撰寫程式的純文字檔稱為 R script (而執行 R Script 裡程式的指令為 Rscript)。在 R script 中，程式碼是由上至下執行，所以上面的例子執行後會依序印出這三行的執行結果：","code":"\nprint(\"Hello world\")\nprint(\"Hi\")\n(2 + 7) / 10[1] \"Hello World!\"\n[1] \"Hi\"\n[1] 0.9"},{"path":"ch01.html","id":"回傳值","chapter":"1 掌握你的電腦","heading":"1.2.2 回傳值","text":"在上方的例子中，印出的執行結果前面皆有一個 [1]。這個 [1] 的目的是為了方便使用者知道指令執行的結果 (回傳值) 的「位置」。事實上，R 印出回傳值的形式是：[<num>] <value(s)>：\n<value(s)> 是指令所傳回來的值 (可有一個以上)，e.g. 1 1 2 3 4 \"\" \"b\" \"c\" \"d\"\n而 [<num>] 則是一個指標 (位於每橫列的開頭)，用來指示其右邊第一個值在所有的值之中的排序，e.g. [1] 11 12 13 代表 11 是第 1 個數值、12 是第 2 個數值；若第一行不足以印出所有的值，則會接著印出第二行: 例如 [16] 26 27 28 代表 26 是第 16 個。\n在上方的例子中，印出的執行結果前面皆有一個 [1]。這個 [1] 的目的是為了方便使用者知道指令執行的結果 (回傳值) 的「位置」。事實上，R 印出回傳值的形式是：[<num>] <value(s)>：<value(s)> 是指令所傳回來的值 (可有一個以上)，e.g. 1 1 2 3 4 \"\" \"b\" \"c\" \"d\"而 [<num>] 則是一個指標 (位於每橫列的開頭)，用來指示其右邊第一個值在所有的值之中的排序，e.g. [1] 11 12 13 代表 11 是第 1 個數值、12 是第 2 個數值；若第一行不足以印出所有的值，則會接著印出第二行: 例如 [16] 26 27 28 代表 26 是第 16 個。例如，執行 1:50 會回傳 50 個值 (1~50)。因為終端機一行無法顯示全部的值，它便會將結果用多行 (行數每台電腦可能不同) 顯示，並透過 [<num>] 方便使用者知道目前印到哪一個值：\n\n1:50\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50例如，執行 1:50 會回傳 50 個值 (1~50)。因為終端機一行無法顯示全部的值，它便會將結果用多行 (行數每台電腦可能不同) 顯示，並透過 [<num>] 方便使用者知道目前印到哪一個值：","code":"\n1:50#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"},{"path":"ch01.html","id":"變數指派-assignment","chapter":"1 掌握你的電腦","heading":"1.2.3 變數指派 (Assignment)","text":"要將指令的回傳值儲存起來，需要使用 <- (assignment operator)，將 <- 右邊的程式碼執行後所回傳的數值儲存於 <- 左邊的變數例如，我可以先將 2 * 3 + 4 的運算結果儲存在 x 內：之後，我可以輸入 x 直接取用上次運算的結果：","code":"\nx <- 2 * 3 + 4\nx#> [1] 10\nx + 1  # 用 x 內的值進一步運算#> [1] 11"},{"path":"ch01.html","id":"r-內建函數","chapter":"1 掌握你的電腦","heading":"1.2.4 R 內建函數","text":"R 裡面的函數就像是我們國高中數學課學到的「函數」。\nR 的函數 (通常) 會有一個或多個「輸入值」，稱為「引數 (argument)」；並且在運算完成後，一定會丟出一個「回傳值」\nR 裡面的函數就像是我們國高中數學課學到的「函數」。R 的函數 (通常) 會有一個或多個「輸入值」，稱為「引數 (argument)」；並且在運算完成後，一定會丟出一個「回傳值」sqrt() 是一個函數，它會將輸入值 (在圓括號內) 開根號後回傳\n\nsqrt(16)\n#> [1] 4sqrt() 是一個函數，它會將輸入值 (在圓括號內) 開根號後回傳函數裡面可以放入另一個函數 (e.g. sqrt(sqrt(16)))，其運算的次序是由內而外，先執行最內部的函數，取得回傳值後，再將此回傳值作為外面的函數的輸入值\n\nsqrt(sqrt(16))\n#> [1] 2\n概念上等同於：\n\ninner <- sqrt(16)\nsqrt(inner)\n#> [1] 2函數裡面可以放入另一個函數 (e.g. sqrt(sqrt(16)))，其運算的次序是由內而外，先執行最內部的函數，取得回傳值後，再將此回傳值作為外面的函數的輸入值概念上等同於：","code":"\nsqrt(16)#> [1] 4\nsqrt(sqrt(16))#> [1] 2\ninner <- sqrt(16)\nsqrt(inner)#> [1] 2"},{"path":"ch01.html","id":"r-console","chapter":"1 掌握你的電腦","heading":"1.2.5 R Console","text":"寫程式時，每次修改都要透過 Rscript 指令檢視執行結果有點麻煩，特別是當你只是在測試或是只想看某一行指令的輸出結果時。因此在撰寫程式時，我們通常會\n先將指令寫在 R Console 測試\n確認執行結果沒問題後再將指令複製到 R Script\n寫完完整的一段程式碼再透過終端機執行整個 R Script\n先將指令寫在 R Console 測試確認執行結果沒問題後再將指令複製到 R Script寫完完整的一段程式碼再透過終端機執行整個 R Script在終端機裡面輸入 R 即可打開 R Console。R Console 是互動式的，意思是輸入一行指令後，可以馬上看到指令執行的結果，並且還可以繼續執行其它指令 (過程中若有指派變數，結果也會記錄下來)。\nFigure 1.6: 寫 R 必備的 3 樣工具\n","code":""},{"path":"ch01.html","id":"說明文件-r-help-page","chapter":"1 掌握你的電腦","heading":"1.2.6 說明文件 (R Help Page)","text":"不確定如何使用函數時，可以閱讀該函數的說明文件：\n\n# ?<function_name>\n?log\n\n# ?`<function_name>`: special functions (e.g. binary operators)\n?`+`不確定如何使用函數時，可以閱讀該函數的說明文件：\nFigure 1.7: 說明文件結構。建議閱讀步驟：Description > Usage > Arguments > Value > Examples > Details\n","code":"\n# ?<function_name>\n?log\n\n# ?`<function_name>`: for special functions (e.g. binary operators)\n?`+`"},{"path":"ch02.html","id":"ch02","chapter":"2 Base R (I) & 輔助工具","heading":"2 Base R (I) & 輔助工具","text":"(投影片 /\n影片)","code":""},{"path":"ch02.html","id":"r-studio","chapter":"2 Base R (I) & 輔助工具","heading":"2.1 R Studio","text":"","code":""},{"path":"ch02.html","id":"自訂樣式","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.1 自訂樣式","text":"RStudio 預設有 4 個區塊 (Pane)。你可以自行決定這 4 個區塊的位置\nTools –> Global Options... –> (在左欄選擇) Pane Layout\nSource, Console, 及 2 個自訂區塊\nTools –> Global Options... –> (在左欄選擇) Pane LayoutSource, Console, 及 2 個自訂區塊除了區塊的相對位置，也可以設定 RStudio 整體的風格以及程式碼 Syntax Highlighting 的樣式:\nTools –> Global Options... –> (在左欄選擇) Appearance\nTools –> Global Options... –> (在左欄選擇) Appearance","code":""},{"path":"ch02.html","id":"編輯器設定","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.2 編輯器設定","text":"Source Pane 是撰寫程式碼的地方 (文字編輯器)\n縮排間距：建議使用 space (而非 tab) 作為縮排字元\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab\n\n文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding\n\n縮排間距：建議使用 space (而非 tab) 作為縮排字元\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab\n縮排間距：建議使用 space (而非 tab) 作為縮排字元Tools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding\n文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8Tools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding","code":""},{"path":"ch02.html","id":"工作目錄","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.3 工作目錄","text":"使用 RStudio 時，最好養成要馬上設置「工作目錄」的習慣。使用 RStudio 時，最好養成要馬上設置「工作目錄」的習慣。RStudio 所在的「工作目錄」顯示於 Console Pane 的標籤下方 (e.g. ~/)RStudio 所在的「工作目錄」顯示於 Console Pane 的標籤下方 (e.g. ~/)工作目錄的設置方式\nRStudio 功能選單: Sessions > Set Working Directory...\nConsole\n\nsetwd('~/Desktop/week2')\n# setwd('<path//new_working_dir>')\ngetwd()  # show current directory\n工作目錄的設置方式RStudio 功能選單: Sessions > Set Working Directory...RStudio 功能選單: Sessions > Set Working Directory...Console\n\nsetwd('~/Desktop/week2')\n# setwd('<path//new_working_dir>')\ngetwd()  # show current directoryConsole","code":"\nsetwd('~/Desktop/week2')\n# setwd('<path/to/new_working_dir>')\ngetwd()  # show current directory"},{"path":"ch02.html","id":"函數","chapter":"2 Base R (I) & 輔助工具","heading":"2.2 函數","text":"","code":"\nget_area <- function() {\n    area <- 3.14 * 1 * 1\n    return(area)\n}\nget_area()#> [1] 3.14\n# Function with a argument\nget_area <- function(r) {\n    area <- 3.14 * r * r\n    return(area)\n}\nget_area(2)#> [1] 12.56\n# Function with a argument that has default value\nget_area <- function(r = 1) {\n    area <- 3.14 * r * r\n    return(area)\n}\nget_area()#> [1] 3.14\nget_area <- function(r) {\n    area <- 3.14 * r * r\n    return(area)\n}\narea <- 100\narea\nget_area(1)\narea#> [1] 100\n#> [1] 3.14\n#> [1] 100"},{"path":"ch02.html","id":"function-arguments","chapter":"2 Base R (I) & 輔助工具","heading":"2.3 Function Arguments","text":"","code":"\nvol <- function(r, height = 1) {\n    volumn <- 3.14 * r * r * height\n    return(volumn)\n}\nvol(1, 2)#> [1] 6.28\nvol(r = 1, height = 2)  # Be explicit#> [1] 6.28\n# If all args are named, order doesn't matter\nvol(height = 2, r = 1)#> [1] 6.28\n# Mix named and unnamed args:\n# named args will be assigned first, then\n# unnamed args will be assigned \n# based on their positions\nvol(height = 2, 1)#> [1] 6.28"},{"path":"ch02.html","id":"vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4 vector","text":"上週實習課使用 R 時，指令的回傳值多半只有「一個」。但 R 其實是一種以向量作為基本單位的程式語言，所以對於「一個回傳值」更精確的描述應該是「一個長度為 1 的向量」。\n\nx <- 2\nx\n#> [1] 2\n\n.vector(x)\n#> [1] TRUE\n\nlength(x)\n#> [1] 1上週實習課使用 R 時，指令的回傳值多半只有「一個」。但 R 其實是一種以向量作為基本單位的程式語言，所以對於「一個回傳值」更精確的描述應該是「一個長度為 1 的向量」。我們上週簡短提過以 : 製造數列的方式 (e.g. 1:10)。事實上，這個回傳的數列即是一個 vector。另外，由於這個 vector 的每個元素皆是整數，因此這個 vector 屬於 integer vector。我們可以使用 typeof() 確認 vector 的類別\n\ntypeof(1:10)\n#> [1] \"integer\"我們上週簡短提過以 : 製造數列的方式 (e.g. 1:10)。事實上，這個回傳的數列即是一個 vector。另外，由於這個 vector 的每個元素皆是整數，因此這個 vector 屬於 integer vector。我們可以使用 typeof() 確認 vector 的類別R 裡面的 vector 可以被分成 6 種類別，其中常見的 4 種分別為 integer, double, , character, logicalR 裡面的 vector 可以被分成 6 種類別，其中常見的 4 種分別為 integer, double, , character, logical","code":"\nx <- 2\nx#> [1] 2\nis.vector(x)#> [1] TRUE\nlength(x)#> [1] 1\ntypeof(1:10)#> [1] \"integer\""},{"path":"ch02.html","id":"integer-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.1 integer vector","text":"integer vector 的元素由整數組成，它可以是零、正或負的。除了使用 : 製造數列，也可以使用 c() (稱為 concatenate) 組出任意序列的 vector。\n使用 c() 製造 integer vector 時，每個整數數字後面必須接 L，若沒有加上 L， R 會將製造出來的 vector 視為 double vector。\n使用 c() 製造 integer vector 時，每個整數數字後面必須接 L，若沒有加上 L， R 會將製造出來的 vector 視為 double vector。","code":"\nint_vec <- c(-1L, 5L, 2L)\ndbl_vec <- c(-1, 5, 2)\nint_vec#> [1] -1  5  2\ndbl_vec#> [1] -1  5  2\ntypeof(int_vec)#> [1] \"integer\"\ntypeof(dbl_vec)#> [1] \"double\""},{"path":"ch02.html","id":"double-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.2 double vector","text":"double vector 儲存的是浮點數，亦即含有小數點的數字 (e.g 1.2, -0.75)double vector 儲存的是浮點數，亦即含有小數點的數字 (e.g 1.2, -0.75)在 R 裡面，integer vector 與 double vector 合稱為 numeric vector，兩者之間的區隔通常也不太重要，因為 R 在運算時，通常會將這兩種資料類型自動轉換成合適的類型\n\ntypeof(2L)\n#> [1] \"integer\"\n\ntypeof(2.0)\n#> [1] \"double\"\n\n.numeric(2L)\n#> [1] TRUE\n\n.numeric(2.0)\n#> [1] TRUE\n\ntypeof(1L + 1.0)\n#> [1] \"double\"\n\ntypeof(1L / 2L)\n#> [1] \"double\"在 R 裡面，integer vector 與 double vector 合稱為 numeric vector，兩者之間的區隔通常也不太重要，因為 R 在運算時，通常會將這兩種資料類型自動轉換成合適的類型Special values:\nInf: 代表無限大\nNaN: “Number”，常見於數字運算不符數學定義時，例如：\n\n0 / 0\n#> [1] NaN\n\nInf / Inf\n#> [1] NaN\n\nlog(-1)\n#> Warning log(-1): NaNs produced\n#> [1] NaN\nSpecial values:Inf: 代表無限大Inf: 代表無限大NaN: “Number”，常見於數字運算不符數學定義時，例如：\n\n0 / 0\n#> [1] NaN\n\nInf / Inf\n#> [1] NaN\n\nlog(-1)\n#> Warning log(-1): NaNs produced\n#> [1] NaNNaN: “Number”，常見於數字運算不符數學定義時，例如：","code":"\ntypeof(2L)#> [1] \"integer\"\ntypeof(2.0)#> [1] \"double\"\nis.numeric(2L)#> [1] TRUE\nis.numeric(2.0)#> [1] TRUE\ntypeof(1L + 1.0)#> [1] \"double\"\ntypeof(1L / 2L)#> [1] \"double\"\n0 / 0#> [1] NaN\nInf / Inf#> [1] NaN\nlog(-1)#> Warning in log(-1): NaNs produced#> [1] NaN"},{"path":"ch02.html","id":"character-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.3 character vector","text":"除了數字以外，R 也可以儲存字串 (string)。character vector 的每個元素皆由一個字串所組成。在 R 裡面，只要是被引號 (quote, ' 或 \" 皆可) 包裹的東西就是字串，放在引號內的可以是任何字元 (e.g. 空白、數字、中文字、英文字母)\n\n\"1.1\"  # string (character vector length 1), double\n#> [1] \"1.1\"\n\n\"你好！\"\n#> [1] \"你好！\"\n\nc(\"1.1\", \"你好！\")\n#> [1] \"1.1\"    \"你好！\"除了數字以外，R 也可以儲存字串 (string)。character vector 的每個元素皆由一個字串所組成。在 R 裡面，只要是被引號 (quote, ' 或 \" 皆可) 包裹的東西就是字串，放在引號內的可以是任何字元 (e.g. 空白、數字、中文字、英文字母)如果字串內含有引號 \"，需在字串內的引號前使用跳脫字元 \\，以表示此引號是字串的一部分而非字串的開頭或結尾\n或是，你可以使用「不同的」引號。例如以「單引號」表示字串的開頭與結尾時，字串內就可以直接使用「雙引號」，反之亦然\n\n\"\\\"\"  # escape double quote\n'\\''  # escape single quote\n'\"'   # double quote string without escaping\n\"'\"   # single quote string without escaping\n#> [1] \"\\\"\"\n#> [1] \"'\"\n#> [1] \"\\\"\"\n#> [1] \"'\"如果字串內含有引號 \"，需在字串內的引號前使用跳脫字元 \\，以表示此引號是字串的一部分而非字串的開頭或結尾或是，你可以使用「不同的」引號。例如以「單引號」表示字串的開頭與結尾時，字串內就可以直接使用「雙引號」，反之亦然","code":"\n\"1.1\"  # This is a string (character vector of length 1), not double#> [1] \"1.1\"\n\"你好！\"#> [1] \"你好！\"\nc(\"1.1\", \"你好！\")#> [1] \"1.1\"    \"你好！\"\n\"\\\"\"  # escape a double quote\n'\\''  # escape a single quote\n'\"'   # a double quote as string without escaping\n\"'\"   # a single quote as string without escaping#> [1] \"\\\"\"\n#> [1] \"'\"\n#> [1] \"\\\"\"\n#> [1] \"'\""},{"path":"ch02.html","id":"logical-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.4 logical vector","text":"logical vector 的每個元素由 TRUE 或 FALSE 組成。logical vector 的每個元素由 TRUE 或 FALSE 組成。可以使用 c() 一項項手動輸入製造 logical vector可以使用 c() 一項項手動輸入製造 logical vectorlogical vector 的另一個來源則是 logical test 的回傳值：\nlogical operators: ==, !=, >, <, %%\n\n\nvec1 <- c(1, 1, 1)\nvec2 <- c(2, 0, 2)\n\n# logical tests\nvec1 > vec2\n#> [1] FALSE  TRUE FALSE\n\nvec1 < vec2\n#> [1]  TRUE FALSE  TRUE\n\nvec1 == vec2\n#> [1] FALSE FALSE FALSElogical vector 的另一個來源則是 logical test 的回傳值：logical operators: ==, !=, >, <, %%boolean operators (&, |, !, (), ()) 可以整合多個 logical tests\n\n\nTRUE & TRUE\n#> [1] TRUE\n\nTRUE & FALSE\n#> [1] FALSE\n\nTRUE | FALSE\n#> [1] TRUE\n\n!TRUE\n#> [1] FALSE\n\n(1 == 1) & (2 == 2)\n#> [1] TRUEboolean operators (&, |, !, (), ()) 可以整合多個 logical tests","code":"\nvec1 <- c(1, 1, 1)\nvec2 <- c(2, 0, 2)\n# logical tests\nvec1 > vec2#> [1] FALSE  TRUE FALSE\nvec1 < vec2#> [1]  TRUE FALSE  TRUE\nvec1 == vec2#> [1] FALSE FALSE FALSE\nTRUE & TRUE#> [1] TRUE\nTRUE & FALSE#> [1] FALSE\nTRUE | FALSE#> [1] TRUE\n!TRUE#> [1] FALSE\n(1 == 1) & (2 == 2)#> [1] TRUE"},{"path":"ch02.html","id":"na","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.5 NA","text":"NA 代表的是「缺失值」，可以作為任何一種 vector 裡面的元素。當 NA 出現在 vector 中，函數對於 vector 的運算常會出現令人意外的結果:\n\n10 > NA\n#> [1] NA\n\nNA == NA\n#> [1] NA\n\nvec <- c(1, NA, 2, 3)\nmean(vec)\n#> [1] NA\n\nmean(vec, na.rm = TRUE)\n#> [1] 2NA 代表的是「缺失值」，可以作為任何一種 vector 裡面的元素。當 NA 出現在 vector 中，函數對於 vector 的運算常會出現令人意外的結果:","code":"\n10 > NA#> [1] NA\nNA == NA#> [1] NA\nvec <- c(1, NA, 2, 3)\nmean(vec)#> [1] NA\nmean(vec, na.rm = TRUE)#> [1] 2"},{"path":"ch02.html","id":"recycling","chapter":"2 Base R (I) & 輔助工具","heading":"2.5 Recycling","text":"兩個或兩個以上的 vector 進行運算時，通常是以 element-wise 的方式進行。此時，若進行運算的 vector 長度不相同，例如，c(1, 2, 3) + 2， R 會自動將長度較短 vector (2) 「回收 (recycle)」，亦即，重複此向量內的元素使其「拉長」到與另一個 vector 等長；接著再將兩個一樣長的 vector 進行 element-wise 的向量運算。","code":"\nx <- c(1, 1, 2, 2)\n\n# Arithmetic operation\nx + 2  # equivalent to...#> [1] 3 3 4 4\nx + c(2, 2, 2, 2)#> [1] 3 3 4 4\nx <- c(1, 1, 2, 2)\n\n# Logical operation\nx == 2  # equivalent to...#> [1] FALSE FALSE  TRUE  TRUE\nx == c(2, 2, 2, 2)#> [1] FALSE FALSE  TRUE  TRUE\n# String operation\nlong <- c(\"a\", \"b\", \"c\")\nshort <- \"1\"\npaste0(\"a\", \"1\")#> [1] \"a1\"\npaste0(long, short)#> [1] \"a1\" \"b1\" \"c1\""},{"path":"ch02.html","id":"coercion","chapter":"2 Base R (I) & 輔助工具","heading":"2.6 Coercion","text":"vector 內的每個元素，其資料類型 (data type) 必須相同。資料類型即是前面提到的 integer, double, character, logical。vector 內的每個元素，其資料類型 (data type) 必須相同。資料類型即是前面提到的 integer, double, character, logical。若發生資料類型不一致的情形 (e.g. 將不同資料類型的元素放入 c())，R 會根據某些規則，自動進行資料類型的轉換。這個過程在 R 裡面稱為 Coercion\n\nc(TRUE, FALSE, 3)      # logical & numeric\n#> [1] 1 0 3\n\nc(-1, \"aa\")            # numeric & character\n#> [1] \"-1\" \"aa\"\n\nc(FALSE, TRUE, \"hi!\")  # logical & character\n#> [1] \"FALSE\" \"TRUE\"  \"hi!\"\n\nc(TRUE, 0, \"hi!\")      # logical & numeric & character\n#> [1] \"TRUE\" \"0\"    \"hi!\"若發生資料類型不一致的情形 (e.g. 將不同資料類型的元素放入 c())，R 會根據某些規則，自動進行資料類型的轉換。這個過程在 R 裡面稱為 Coercion\nFigure 2.1: Rules Coercion\ncoercion failed, throw errorif coercion failed, throw errormanual coercion: .character(), .logical(), .numeric()manual coercion: .character(), .logical(), .numeric()","code":"\nc(TRUE, FALSE, 3)      # logical & numeric#> [1] 1 0 3\nc(-1, \"aa\")            # numeric & character#> [1] \"-1\" \"aa\"\nc(FALSE, TRUE, \"hi!\")  # logical & character#> [1] \"FALSE\" \"TRUE\"  \"hi!\"\nc(TRUE, 0, \"hi!\")      # logical & numeric & character#> [1] \"TRUE\" \"0\"    \"hi!\"\nsum(c(T, T, T, F))#> [1] 3\ngender <- c(\"male\", \"female\", \"male\", \"female\")\nsum(gender == \"male\")  # num of male#> [1] 2\nmean(gender == \"male\")  # proportion of male#> [1] 0.5"},{"path":"ch02.html","id":"subsetting-a-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.7 Subsetting a vector","text":"有 3 種方法可用於取出 vector 裡面的元素 (回傳一個新的 vector)\n透過提供 vector 中元素的位置次序 (index)\n透過一個與此 vector 等長的 logical vector。在 logical vector 中的相對應位置，以 TRUE 或 FALSE 表示是否保留該位置的元素\n透過提供元素的「名字」(.e. names 屬性)\n透過提供 vector 中元素的位置次序 (index)透過一個與此 vector 等長的 logical vector。在 logical vector 中的相對應位置，以 TRUE 或 FALSE 表示是否保留該位置的元素透過提供元素的「名字」(.e. names 屬性)","code":""},{"path":"ch02.html","id":"index-subsetting","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.1 index subsetting","text":"","code":"\n# z[<integer_vector>]\nLETTERS  # R 內建變數: 包含所有大寫英文字母的 character vector#>  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\nLETTERS[1]#> [1] \"A\"\nLETTERS[1:5]#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nLETTERS[c(1, 3, 5)]#> [1] \"A\" \"C\" \"E\"\nLETTERS[-(1:5)]  # Exclude the first 5 elements#>  [1] \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\"\n#> [20] \"Y\" \"Z\""},{"path":"ch02.html","id":"logical-subsetting","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.2 Logical subsetting","text":"","code":"\n# z[<logical_vector of length(z)>]\nage <- c(21, 20, 18, 19)\nage[c(FALSE, TRUE, FALSE, TRUE)]#> [1] 20 19\n## Creating logical vectors\nage[1] < 20  # returns a logical vector of length 1#> [1] FALSE\nage < 20     # returns a logical vector of length(x)#> [1] FALSE FALSE  TRUE  TRUE\n# Subset a vector using a logical test\nage[age < 20]#> [1] 18 19"},{"path":"ch02.html","id":"subsetting-with-names","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.3 Subsetting with names","text":"","code":"\nage <- c(40, 20, 18, 19)\nnames(age) <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\n# age <- c(kai = 40, pooh = 20, tiger = 18, piglet = 19)  # another way of setting names\n\nage#>    kai   pooh  tiger piglet \n#>     40     20     18     19\nage['kai'] + 9#> kai \n#>  49\nage[c('pooh', 'kai')]#> pooh  kai \n#>   20   40"},{"path":"ch02.html","id":"modifying-values-in-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.4 Modifying Values in vector","text":"","code":"\na2z <- LETTERS\na2z[1:3] <- c(\"a\", \"b\", \"c\")\na2z#>  [1] \"a\" \"b\" \"c\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\ngender <- c(\"m\", \"m\", \"f\", \"f\")\ngender[gender == \"m\"] <- \"male\"\ngender#> [1] \"male\" \"male\" \"f\"    \"f\"\ngender[gender == \"f\"] <- \"female\"\ngender#> [1] \"male\"   \"male\"   \"female\" \"female\"\nnames(gender) <- c(\"john\", \"jenny\", \"jane\", \"kate\")\ngender#>     john    jenny     jane     kate \n#>   \"male\"   \"male\" \"female\" \"female\"\ngender[\"john\"] <- \"male\"\ngender#>     john    jenny     jane     kate \n#>   \"male\"   \"male\" \"female\" \"female\"\ngender[c(\"jenny\", \"jane\", \"kate\")] <- \"female\"\ngender#>     john    jenny     jane     kate \n#>   \"male\" \"female\" \"female\" \"female\""},{"path":"ch02.html","id":"if-else","chapter":"2 Base R (I) & 輔助工具","heading":"2.8 if else","text":"一般而言，R 是由上至下一行一行地執行程式碼。有時候我們會希望能跳過某些程式碼或是依據不同的狀況執行不同的程式碼，這時候我們就需要使用條件式。在 -else -else 的結構中，只有其中一個區塊 (被大括弧 {} 包裹的程式碼) 會被執行。執行完該區塊後，就會忽略剩下的條件控制區塊，執行條件式之後的程式碼。在 -else -else 的結構中，只有其中一個區塊 (被大括弧 {} 包裹的程式碼) 會被執行。執行完該區塊後，就會忽略剩下的條件控制區塊，執行條件式之後的程式碼。可以在 之後使用多個 else .可以在 之後使用多個 else .條件式的結構：\n# 只有 \n(<條件>) {\n    <Code>  # 條件成立時執行\n}\n\n# , else\n(<條件>) {\n    <Code>  # <條件>成立時執行\n} else {\n    <Code>  # <條件>不成立時執行\n}\n\n# , else , else\n(<條件1>) {\n    <Code>          # <條件1>成立時執行\n} else ( <條件2> ) {\n    <Code>          # <條件1>不成立、<條件2>成立時執行\n} else {\n    <Code>          # <條件1>、<條件2>皆不成立時執行\n}條件式的結構：","code":"\nx <- 1\n\nif (x > 0) {\n    print('x is positive')\n} else {\n    print('x is not positive')\n}#> [1] \"x is positive\"\nx <- -1\n\nif (x > 0) {\n    print('x is positive')\n} else if (x < 0) {\n    print('x is negative')\n} else {\n    print('x is zero')\n}\n\nprint('This is always printed')#> [1] \"x is negative\"\n#> [1] \"This is always printed\"# 只有 if\nif (<條件>) {\n    <Some Code>  # 條件成立時執行\n}\n\n# if, else\nif (<條件>) {\n    <Some Code>  # <條件>成立時執行\n} else {\n    <Some Code>  # <條件>不成立時執行\n}\n\n# if, else if, else\nif (<條件1>) {\n    <Some Code>          # <條件1>成立時執行\n} else if ( <條件2> ) {\n    <Some Code>          # <條件1>不成立、<條件2>成立時執行\n} else {\n    <Some Code>          # <條件1>、<條件2>皆不成立時執行\n}"},{"path":"ch02.html","id":"wrap-up","chapter":"2 Base R (I) & 輔助工具","heading":"2.9 Wrap up: 句子產生器","text":"","code":"\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)\n\n# Randomly draw 2 subjects\nwho <- sample(1:4, size = 2)\n\n# Find out who is older\nage1 <- age[who[1]]\nage2 <- age[who[2]]\nif (age1 > age2) {\n    comparitive <- ' is older than '\n} else if (age1 < age2) {\n    comparitive <- ' is younger than '\n} else {\n    comparitive <- ' is as old as '\n}\n\n# Construct sentence\npaste0(name[who[1]], comparitive, name[who[2]])#> [1] \"piglet is younger than pooh\""},{"path":"ch02.html","id":"r-markdown","chapter":"2 Base R (I) & 輔助工具","heading":"2.10 R Markdown","text":"使用前需先安裝 rmarkdown:\n\ninstall.packages('rmarkdown')使用前需先安裝 rmarkdown:R Markdown (.Rmd) 就像之前同學用來寫自我介紹的 Markdown 文件 (.md) 一樣是一種純文字格式。R Markdown 的語法其實只是 Markdown 的一種擴充：它新增了一些特殊的語法，讓使用者可以直接在 R Markdown 裡面撰寫程式碼，並透過 R 將這些程式碼的運算結果插入 R Markdown 的輸出文件當中。R Markdown (.Rmd) 就像之前同學用來寫自我介紹的 Markdown 文件 (.md) 一樣是一種純文字格式。R Markdown 的語法其實只是 Markdown 的一種擴充：它新增了一些特殊的語法，讓使用者可以直接在 R Markdown 裡面撰寫程式碼，並透過 R 將這些程式碼的運算結果插入 R Markdown 的輸出文件當中。knitr Code Chunk\n執行：由上至下執行\n後面的 chunk 可以讀取之前的 chunks 產生的變數\nknitr Code Chunk執行：由上至下執行後面的 chunk 可以讀取之前的 chunks 產生的變數(在 RStudio 使用 R Markdown)使用 RStudio 開啟 R Markdown (.Rmd) 時，Rmd 檔會出現在 Source Pane 讓使用者編輯使用 RStudio 開啟 R Markdown (.Rmd) 時，Rmd 檔會出現在 Source Pane 讓使用者編輯將 R Markdown (.Rmd) 輸出 (knit )成 HTML 檔 (.html):將 R Markdown (.Rmd) 輸出 (knit )成 HTML 檔 (.html):\nFigure 2.2: R Markdown document RStudio10.\n","code":"\ninstall.packages('rmarkdown')"},{"path":"ch02.html","id":"參考資源","chapter":"2 Base R (I) & 輔助工具","heading":"參考資源","text":"Grolemund, G. (2014). Hands-programming R\nR Objects (https://rstudio-education.github.io/hopr/r-objects)\nModifying Values (https://rstudio-education.github.io/hopr/modify)Grolemund, G. (2014). Hands-programming R\nR Objects (https://rstudio-education.github.io/hopr/r-objects)\nModifying Values (https://rstudio-education.github.io/hopr/modify)Xie, Y., Allaire, J., & Grolemund, G. (2019). R Markdown: Definitive GuideXie, Y., Allaire, J., & Grolemund, G. (2019). R Markdown: Definitive Guide","code":""},{"path":"ch03.html","id":"ch03","chapter":"3 Base R (II)","heading":"3 Base R (II)","text":"(投影片 /\n程式碼 /\n影片)","code":""},{"path":"ch03.html","id":"list","chapter":"3 Base R (II)","heading":"3.1 list","text":"vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存不同資料類型或是具有階層結構的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存不同資料類型或是具有階層結構的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。R 可以透過 list() 去製造出 list。list() 的使用方式很類似用來製造 vector 的 c()，但與 c() 不同的是，list()\n能使用不同的資料類型\n\nlist(TRUE, 1:3, \"Hello\")\n#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\n\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")\n#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"\n具有階層結構，亦即，list() 裡面可以放入另一個 list()\n\nlist(1.1, list(2.1, \"Hello\"))\n#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\"\nR 可以透過 list() 去製造出 list。list() 的使用方式很類似用來製造 vector 的 c()，但與 c() 不同的是，list()能使用不同的資料類型\n\nlist(TRUE, 1:3, \"Hello\")\n#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\n\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")\n#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"能使用不同的資料類型具有階層結構，亦即，list() 裡面可以放入另一個 list()\n\nlist(1.1, list(2.1, \"Hello\"))\n#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\"具有階層結構，亦即，list() 裡面可以放入另一個 list()","code":"\nlist(TRUE, 1:3, \"Hello\")#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"\nlist(1.1, list(2.1, \"Hello\"))#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\""},{"path":"ch03.html","id":"subsetting","chapter":"3 Base R (II)","heading":"3.1.1 Subsetting","text":"通常我們會習慣為 list 加上名字 (names)，幫助我們更容易處理這種比較複雜的資料結構通常我們會習慣為 list 加上名字 (names)，幫助我們更容易處理這種比較複雜的資料結構[]: 與 vector 一樣，我們可以透過 lst[<char vector names>]、lst[<integer vector>] 或 lst[<logical vector>] 去 subset list\n\npooh <- list(age = 20, single = FALSE, tags = c(\"ig\", \"selfie\"))\npooh['single']\n#> $single\n#> [1] FALSE\n\npooh[2:3]\n#> $single\n#> [1] FALSE\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n\npooh[c(TRUE, FALSE, TRUE)]\n#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"[]: 與 vector 一樣，我們可以透過 lst[<char vector names>]、lst[<integer vector>] 或 lst[<logical vector>] 去 subset list就像 vec[<vector>] 會回傳一部分的 vector (sub-vector)；lst[<vector>] 也會回傳一部分的 list (sub-list)。換言之，使用 [] 時，回傳值的資料結構不會改變。就像 vec[<vector>] 會回傳一部分的 vector (sub-vector)；lst[<vector>] 也會回傳一部分的 list (sub-list)。換言之，使用 [] 時，回傳值的資料結構不會改變。我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂裡面是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 []；欲取得 sub-list 裡面的值 (.e. 脫去外層的 list)，需使用 [[]]\n\n# 回傳 sub-list\ntypeof(pooh[\"tags\"])\npooh[\"tags\"]\n\n# 回傳 list 之內的「值」，在此為一個 char vector\ntypeof(pooh[[\"tags\"]])\npooh[[\"tags\"]]\n#> [1] \"list\"\n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"character\"\n#> [1] \"ig\"     \"selfie\"\nlst[[\"<name>\"]] 有另一種更簡便的寫法：lst$<name>, e.g. pooh[[\"tags\"]] 可改寫成 pooh$tags\n我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂裡面是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 []；欲取得 sub-list 裡面的值 (.e. 脫去外層的 list)，需使用 [[]]lst[[\"<name>\"]] 有另一種更簡便的寫法：lst$<name>, e.g. pooh[[\"tags\"]] 可改寫成 pooh$tags\nFigure 3.1: List train\n","code":"\npooh <- list(age = 20, single = FALSE, tags = c(\"ig\", \"selfie\"))\npooh['single']#> $single\n#> [1] FALSE\npooh[2:3]#> $single\n#> [1] FALSE\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\npooh[c(TRUE, FALSE, TRUE)]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n# 回傳 sub-list\ntypeof(pooh[\"tags\"])\npooh[\"tags\"]\n\n# 回傳 list 之內的「值」，在此為一個 char vector\ntypeof(pooh[[\"tags\"]])\npooh[[\"tags\"]]#> [1] \"list\"\n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"character\"\n#> [1] \"ig\"     \"selfie\""},{"path":"ch03.html","id":"nested-structure","chapter":"3 Base R (II)","heading":"3.1.2 Nested Structure","text":"","code":"\na_lst <- list(name = \"pooh\",\n              info = list(age = 20,\n                          tags = c(\"ig\", \"selfie\")))\n\n# Get \"selfie\"  \na_lst[['info']]\na_lst[['info']][['tags']]\na_lst[['info']][['tags']][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# Another way to get \"selfie\"\na_lst['info'][[1]]\na_lst['info'][[1]]['tags'][[1]]\na_lst['info'][[1]]['tags'][[1]][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# Yet another way to get \"selfie\"\na_lst[[2]]\na_lst[[2]][[2]]\na_lst[[2]][[2]][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# The most 'readable' way to get \"selfie\"\na_lst$info\na_lst$info$tags\na_lst$info$tags[2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\""},{"path":"ch03.html","id":"for-loop","chapter":"3 Base R (II)","heading":"3.2 for loop","text":"上週介紹的條件式 (-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。上週介紹的條件式 (-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。R 有 與 迴圈。一般而言，在資料分析時非常少會用到 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。R 有 與 迴圈。一般而言，在資料分析時非常少會用到 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。loop 的結構如下\n(<變數> <vector>) {\n    <code>\n}loop 的結構如下for loop 會使 {} 內的程式碼重複執行數次，其次數等於 <vector> 的長度；並且，在第 n 次開始執行 {} 內的程式碼前，會將 <vector> 裡的第 n 個元素指派給 <變數>。所以在第一次迴圈時，可透過 <變數> 取得 <vector> 中的第一個元素；在第二次迴圈時，可取得 <vector> 中的第二個元素；依此類推，最後一次迴圈則可以透過 <變數> 取得 <vector> 中的最後一個元素。loop 會使 {} 內的程式碼重複執行數次，其次數等於 <vector> 的長度；並且，在第 n 次開始執行 {} 內的程式碼前，會將 <vector> 裡的第 n 個元素指派給 <變數>。所以在第一次迴圈時，可透過 <變數> 取得 <vector> 中的第一個元素；在第二次迴圈時，可取得 <vector> 中的第二個元素；依此類推，最後一次迴圈則可以透過 <變數> 取得 <vector> 中的最後一個元素。","code":"for (<變數> in <vector>) {\n    <some code>\n}\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n  \nfor (word in vec) {\n    # Will execute 4 times, \n    # each time a new value from `vec` will be assigned to `word`\n    print(word)\n}#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\""},{"path":"ch03.html","id":"for-loop-的各種型態","chapter":"3 Base R (II)","heading":"3.2.1 for loop 的各種型態","text":"R 的 只有一種結構：每次疊代將 vector (或 list) 中的一個元素指派給變數 (<var> <vector>)。但因為 R 向量式程式語言的特性，R 的 迴圈很容易改寫成其它更方便的型態。有時候我們需要知道迴圈進行到 <vector> 的第幾個元素，這時候通常會使用 seq_along(<vector>) 去製造出與 <vector> 等長的整數序列 (e.g. seq_along(c('', 'b', 'c')) 會回傳 1 2 3)，如此我們便可知道進行到第幾次迴圈，也可透過 <vector>[] 取得與該次迴圈對應的元素。\n\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n(seq_along(vec)) {\n    print(paste(, vec[]))\n}\n#> [1] \"1 謝\"\n#> [1] \"2 老師\"\n#> [1] \"3 好\"\n#> [1] \"4 帥\"\n\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n(seq_along(vec)) {\n    print(vec[])\n\n    # Print `?` last loop\n    (== length(vec)) {\n        print('?')\n    }\n}\n#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\"\n#> [1] \"?\"有時候我們需要知道迴圈進行到 <vector> 的第幾個元素，這時候通常會使用 seq_along(<vector>) 去製造出與 <vector> 等長的整數序列 (e.g. seq_along(c('', 'b', 'c')) 會回傳 1 2 3)，如此我們便可知道進行到第幾次迴圈，也可透過 <vector>[] 取得與該次迴圈對應的元素。我們也可以透過 names() 在 loop 裡使用 <vector> 的 names 屬性：\n\nvec <- c(Monday = \"rainy\", Tuesday = \"cloudy\", Wednesday = \"sunny\")\n(name names(vec)) {\n    print(paste0(name, ' ', vec[name], '.'))\n}\n#> [1] \"Monday rainy.\"\n#> [1] \"Tuesday cloudy.\"\n#> [1] \"Wednesday sunny.\"我們也可以透過 names() 在 loop 裡使用 <vector> 的 names 屬性：常常我們會需要對 loop 有「更多的控制」。前面在 loop 中使用到條件式即是一個例子。但常常條件式本身的功能並不足夠：執行迴圈時，在符合特定條件下，有時候我們會希望能忽略一次迴圈中「所有尚未被執行的程式碼」，這時就會使用到 next:\n\n# 使用 next '忽略一次' 迴圈\n(1:10) {\n    (== 5) {\n        print(\"Skipping print() == 5\")\n        next\n    }\n    print()\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Skipping print() == 5\"\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10有時候我們會希望能忽略一次迴圈中「所有尚未被執行的程式碼」，這時就會使用到 next:有時我們需要跳出整個迴圈，亦即不再執行 loop 裡面的程式碼。這時就會使用到 break:\n\n# 使用 break 跳出整個迴圈\n(1:10) {\n    (== 5) {\n        print(\"Breaking loop\")\n        break\n    }\n    print()\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Breaking loop\"有時我們需要跳出整個迴圈，亦即不再執行 loop 裡面的程式碼。這時就會使用到 break:下方的程式碼能將多個檔案 (圖片) 重新命名 (並透過 next 忽略某些檔案)。有興趣者請下載原始碼，裡面有一個資料夾 dice/。執行此程式碼前，需將工作目錄設至 dice/ 資料夾。","code":"\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\nfor (i in seq_along(vec)) {\n    print(paste(i, vec[i]))\n}#> [1] \"1 謝\"\n#> [1] \"2 老師\"\n#> [1] \"3 好\"\n#> [1] \"4 帥\"\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\nfor (i in seq_along(vec)) {\n    print(vec[i])\n\n    # Print `?` in the last loop\n    if (i == length(vec)) {\n        print('?')\n    }\n}#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\"\n#> [1] \"?\"\nvec <- c(Monday = \"rainy\", Tuesday = \"cloudy\", Wednesday = \"sunny\")\nfor (name in names(vec)) {\n    print(paste0(name, ' was ', vec[name], '.'))\n}#> [1] \"Monday was rainy.\"\n#> [1] \"Tuesday was cloudy.\"\n#> [1] \"Wednesday was sunny.\"\n# 使用 next '忽略一次' 迴圈\nfor (i in 1:10) {\n    if (i == 5) {\n        print(\"Skipping print(i) if i == 5\")\n        next\n    }\n    print(i)\n}#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Skipping print(i) if i == 5\"\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10\n# 使用 break 跳出整個迴圈\nfor (i in 1:10) {\n    if (i == 5) {\n        print(\"Breaking out the for loop\")\n        break\n    }\n    print(i)\n}#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Breaking out the for loop\"\nfor (file in list.files()) {\n    # 忽略 `00_not_an_img.txt` 這個檔案\n    if (file == '00_not_an_img.txt') {\n        next\n    }\n    \n    file.rename(from = file, to = paste0('dice-', file))\n}"},{"path":"ch03.html","id":"實際應用修改檔案名稱","chapter":"3 Base R (II)","heading":"3.2.2 實際應用：修改檔案名稱","text":"下方的程式碼能將多個檔案 (圖片) 重新命名 (並透過 next 忽略某些檔案)。有興趣者請下載原始碼，裡面有一個資料夾 dice/。執行此程式碼前，需將工作目錄設至 dice/ 資料夾。","code":"\nfor (file in list.files()) {\n    # 忽略 `00_not_an_img.txt` 這個檔案\n    if (file == '00_not_an_img.txt') {\n        next\n    }\n    \n    file.rename(from = file, to = paste0('dice-', file))\n}"},{"path":"ch03.html","id":"wrap-upfor-loop-與-list","chapter":"3 Base R (II)","heading":"3.3 Wrap up：for loop 與 list","text":"上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人\n(“kai”, “pooh”, “tiger”, “piglet”)\n的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (name 與 age) 分開來儲存在獨立的 vector。\n\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人\n(“kai”, “pooh”, “tiger”, “piglet”)\n的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (name 與 age) 分開來儲存在獨立的 vector。對於這種彼此之間具有關聯的資料，一種更好的方式是將它們儲存在一起，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 list 去改寫上週的資料：\n\nmember <- list(\n    list(name = \"kai\", age = 40),\n    list(name = \"pooh\", age = 20),\n    list(name = \"tiger\", age = 18),\n    list(name = \"piglet\", age = 19)\n)\n\nmember\n#> [[1]]\n#> [[1]]$name\n#> [1] \"kai\"\n#> \n#> [[1]]$age\n#> [1] 40\n#> \n#> \n#> [[2]]\n#> [[2]]$name\n#> [1] \"pooh\"\n#> \n#> [[2]]$age\n#> [1] 20\n#> \n#> \n#> [[3]]\n#> [[3]]$name\n#> [1] \"tiger\"\n#> \n#> [[3]]$age\n#> [1] 18\n#> \n#> \n#> [[4]]\n#> [[4]]$name\n#> [1] \"piglet\"\n#> \n#> [[4]]$age\n#> [1] 19\n\n(person member) {\n    name <- person$name\n    age <- person$age\n\n    # 將組成句子的片語儲存於 char vector `phrases`\n    phrases <- c(name, \" \", age)\n    (age < 35) {\n        phrases[4] <- \", quite young\"\n    }\n\n    # 將各片語連接起來成為一個句子\n    sentence <- paste0(phrases,  collapse = '')\n\n    print(sentence)\n}\n#> [1] \"kai 40\"\n#> [1] \"pooh 20, quite young\"\n#> [1] \"tiger 18, quite young\"\n#> [1] \"piglet 19, quite young\"對於這種彼此之間具有關聯的資料，一種更好的方式是將它們儲存在一起，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 list 去改寫上週的資料：","code":"\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)\nmember <- list(\n    list(name = \"kai\", age = 40),\n    list(name = \"pooh\", age = 20),\n    list(name = \"tiger\", age = 18),\n    list(name = \"piglet\", age = 19)\n)\n\nmember#> [[1]]\n#> [[1]]$name\n#> [1] \"kai\"\n#> \n#> [[1]]$age\n#> [1] 40\n#> \n#> \n#> [[2]]\n#> [[2]]$name\n#> [1] \"pooh\"\n#> \n#> [[2]]$age\n#> [1] 20\n#> \n#> \n#> [[3]]\n#> [[3]]$name\n#> [1] \"tiger\"\n#> \n#> [[3]]$age\n#> [1] 18\n#> \n#> \n#> [[4]]\n#> [[4]]$name\n#> [1] \"piglet\"\n#> \n#> [[4]]$age\n#> [1] 19\nfor (person in member) {\n    name <- person$name\n    age <- person$age\n\n    # 將組成句子的片語儲存於 char vector `phrases`\n    phrases <- c(name, \" is \", age)\n    if (age < 35) {\n        phrases[4] <- \", which is quite young\"\n    }\n\n    # 將各片語連接起來成為一個句子\n    sentence <- paste0(phrases,  collapse = '')\n\n    print(sentence)\n}#> [1] \"kai is 40\"\n#> [1] \"pooh is 20, which is quite young\"\n#> [1] \"tiger is 18, which is quite young\"\n#> [1] \"piglet is 19, which is quite young\""},{"path":"ch03.html","id":"data-frame","chapter":"3 Base R (II)","heading":"3.4 data frame","text":"data frame 是 R 語言非常重要的資料結構，它造就了 R 強大的表格式資料處理能力data frame 是 R 語言非常重要的資料結構，它造就了 R 強大的表格式資料處理能力data frame 是一種二維的資料結構。這種資料結構基本上與我們熟悉的 Excel (或 google 試算表) 非常類似：\n\n\nFigure 3.2: data frame looks like Excel Spreadsheet\n\n\ndata frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)\ndata frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)\ndata frame 是一種二維的資料結構。這種資料結構基本上與我們熟悉的 Excel (或 google 試算表) 非常類似：\nFigure 3.2: data frame looks like Excel Spreadsheet\ndata frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)data frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)data frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)data frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)\nFigure 3.3: Data Frame\n我們可以使用 tibble 套件的 tibble()11 建立 data frame。上圖中的 data frame 例子即可由下方的程式碼所建立:\n\nlibrary(tibble)\n\ndf <- tibble(name = c(\"kai\", \"pooh\", \"tiger\", \"piglet\"),\n             age  = c(40, 20, 18, 19), \n             grad = c(FALSE, TRUE, FALSE, TRUE))\ndf\n#> # tibble: 4 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 kai       40 FALSE\n#> 2 pooh      20 TRUE \n#> 3 tiger     18 FALSE\n#> 4 piglet    19 TRUE\ntibble() 裡的每個 vector 對映到 data frame 中的一欄 (column)。因此 data frame 中不同欄的資料類型可能不同，但每一欄 (變項) 內的資料類型必須相同 (因為 vector 只能儲存相同的資料類型)。\n我們可以使用 tibble 套件的 tibble()11 建立 data frame。上圖中的 data frame 例子即可由下方的程式碼所建立:tibble() 裡的每個 vector 對映到 data frame 中的一欄 (column)。因此 data frame 中不同欄的資料類型可能不同，但每一欄 (變項) 內的資料類型必須相同 (因為 vector 只能儲存相同的資料類型)。下方的指令可用於檢視 data frame 的資訊\n\nnrow(df)   # number rows\nncol(df)   # number columns\ndim(df)    # 形狀 (num rows, num columns)\nnames(df)  # name column\n#> [1] 4\n#> [1] 3\n#> [1] 4 3\n#> [1] \"name\" \"age\"  \"grad\"\n\ntibble::glimpse(df)  # 關於 df 的各種資訊\n#> Rows: 4\n#> Columns: 3\n#> $ name <chr> \"kai\", \"pooh\", \"tiger\", \"piglet\"\n#> $ age  <dbl> 40, 20, 18, 19\n#> $ grad <lgl> FALSE, TRUE, FALSE, TRUE\n\nstr(df)              # 也可用 Base R 內建函數: str()\n#> tibble [4 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ name: chr [1:4] \"kai\" \"pooh\" \"tiger\" \"piglet\"\n#>  $ age : num [1:4] 40 20 18 19\n#>  $ grad: logi [1:4] FALSE TRUE FALSE TRUE\n\nView(df)   # View data frame RStudio source pane下方的指令可用於檢視 data frame 的資訊","code":"\nlibrary(tibble)\n\ndf <- tibble(name = c(\"kai\", \"pooh\", \"tiger\", \"piglet\"),\n             age  = c(40, 20, 18, 19), \n             grad = c(FALSE, TRUE, FALSE, TRUE))\ndf#> # A tibble: 4 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 kai       40 FALSE\n#> 2 pooh      20 TRUE \n#> 3 tiger     18 FALSE\n#> 4 piglet    19 TRUE\nnrow(df)   # number of rows\nncol(df)   # number of columns\ndim(df)    # 形狀 (num of rows, num of columns)\nnames(df)  # name of each column#> [1] 4\n#> [1] 3\n#> [1] 4 3\n#> [1] \"name\" \"age\"  \"grad\"\ntibble::glimpse(df)  # 關於 df 的各種資訊#> Rows: 4\n#> Columns: 3\n#> $ name <chr> \"kai\", \"pooh\", \"tiger\", \"piglet\"\n#> $ age  <dbl> 40, 20, 18, 19\n#> $ grad <lgl> FALSE, TRUE, FALSE, TRUE\nstr(df)              # 也可用 Base R 內建函數: str()#> tibble [4 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ name: chr [1:4] \"kai\" \"pooh\" \"tiger\" \"piglet\"\n#>  $ age : num [1:4] 40 20 18 19\n#>  $ grad: logi [1:4] FALSE TRUE FALSE TRUE\nView(df)   # View data frame in RStudio source pane"},{"path":"ch03.html","id":"subsetting-returning-a-data-frame","chapter":"3 Base R (II)","heading":"3.4.1 Subsetting: returning a data frame","text":"data frame 的篩選 (subsetting) 與 vector 和 list 類似，差別只在於 data frame 屬於二維的資料結構，因此需要提供 2 個 vector 進行資料的篩選：\ndf[<vector 1>, <vector 2>]\n在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。\n以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])\ndata frame 的篩選 (subsetting) 與 vector 和 list 類似，差別只在於 data frame 屬於二維的資料結構，因此需要提供 2 個 vector 進行資料的篩選：在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])","code":"df[<vector 1>, <vector 2>]\ndf[2, 1]#> # A tibble: 1 x 1\n#>   name \n#>   <chr>\n#> 1 pooh\ndf[2, 1:2]  # df[2, c(\"name\", \"age\")]#> # A tibble: 1 x 2\n#>   name    age\n#>   <chr> <dbl>\n#> 1 pooh     20\ndf[2, ]#> # A tibble: 1 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 pooh     20 TRUE"},{"path":"ch03.html","id":"subsetting-returning-a-vector","chapter":"3 Base R (II)","heading":"3.4.2 Subsetting: returning a vector","text":"若想要從 data frame 裡面篩選出 vector (取得「火車車廂」內的值)，則要使用之前提過的 $ 或 [[]]:\n\ndf[[2]]      # df[[<column_index>]]\ndf[[\"age\"]]  # df[[\"<column_name>\"]]\ndf$age       # df$<column_name>, 最常見\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19若想要從 data frame 裡面篩選出 vector (取得「火車車廂」內的值)，則要使用之前提過的 $ 或 [[]]:篩選 data frame 而回傳 vector 是個很實用的技巧，因為我們可以使用這個回傳的 vector 當作我們進一步篩選 data frame 的依據，例如：\n\nover19 <- df$age > 19  \nover19\n#> [1]  TRUE  TRUE FALSE FALSE\n\n# subset df obs. 19\ndf[over19, ]\n#> # tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\n\n# subset df obs. equal 19\ndf[!over19, ]\n#> # tibble: 2 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 tiger     18 FALSE\n#> 2 piglet    19 TRUE\n\n# 合併起來寫 (最常見的寫法，但比較難讀懂)\ndf[df$age > 19, ]\n#> # tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE篩選 data frame 而回傳 vector 是個很實用的技巧，因為我們可以使用這個回傳的 vector 當作我們進一步篩選 data frame 的依據，例如：透過這個技巧，R 能幫助我們快速篩選出需要的資料，例如，我們可以結合 age 與 grad 兩個變項，篩選出「小於 20 歲且為研究所學生」的 data frame:\n\ndf[(df$age < 20) & (df$grad), ]\n#> # tibble: 1 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 piglet    19 TRUE透過這個技巧，R 能幫助我們快速篩選出需要的資料，例如，我們可以結合 age 與 grad 兩個變項，篩選出「小於 20 歲且為研究所學生」的 data frame:","code":"\ndf[[2]]      # df[[<column_index>]]\ndf[[\"age\"]]  # df[[\"<column_name>\"]]\ndf$age       # df$<column_name>, 最常見#> [1] 40 20 18 19\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19\nover19 <- df$age > 19  \nover19#> [1]  TRUE  TRUE FALSE FALSE\n# subset df with obs. over 19\ndf[over19, ]#> # A tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\n# subset df with obs. below or equal 19\ndf[!over19, ]#> # A tibble: 2 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 tiger     18 FALSE\n#> 2 piglet    19 TRUE\n# 合併起來寫 (最常見的寫法，但比較難讀懂)\ndf[df$age > 19, ]#> # A tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\ndf[(df$age < 20) & (df$grad), ]#> # A tibble: 1 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 piglet    19 TRUE"},{"path":"ch04.html","id":"ch04","chapter":"4 Data Frame 處理：dplyr","heading":"4 Data Frame 處理：dplyr","text":"(投影片 /\n程式碼 /\n影片)material largely based Garrett Grolemund’s introduction dplyr","code":""},{"path":"ch04.html","id":"why-dplyr","chapter":"4 Data Frame 處理：dplyr","heading":"4.1 Why dplyr?","text":"上週介紹過篩選 data frame 的方法：df[<vector 1>, <vector 2>]。但這種方法有一個缺點：隨著篩選條件越來越多，篩選 data frame 的指令會越來越複雜，變得難以閱讀，例如:\n\nlibrary(tibble)\ndf <- as_tibble(iris)\n\n# long take understand command ?\ndf[(df$Species == \"setosa\") & (df$Sepal.Length < 5.8), c(\"Species\", \"Sepal.Width\")]\n#> # tibble: 49 x 2\n#>    Species Sepal.Width\n#>    <fct>         <dbl>\n#>  1 setosa          3.5\n#>  2 setosa          3  \n#>  3 setosa          3.2\n#>  4 setosa          3.1\n#>  5 setosa          3.6\n#>  6 setosa          3.9\n#>  7 setosa          3.4\n#>  8 setosa          3.4\n#>  9 setosa          2.9\n#> 10 setosa          3.1\n#> # … 39 rows上週介紹過篩選 data frame 的方法：df[<vector 1>, <vector 2>]。但這種方法有一個缺點：隨著篩選條件越來越多，篩選 data frame 的指令會越來越複雜，變得難以閱讀，例如:套件 dplyr 目的就是為了使這個過程變得更加容易：讓處理 data frame 的指令變得直覺易懂。套件 dplyr 目的就是為了使這個過程變得更加容易：讓處理 data frame 的指令變得直覺易懂。","code":"\nlibrary(tibble)\ndf <- as_tibble(iris)\n\n# How long does it take to understand the command below?\ndf[(df$Species == \"setosa\") & (df$Sepal.Length < 5.8), c(\"Species\", \"Sepal.Width\")]#> # A tibble: 49 x 2\n#>    Species Sepal.Width\n#>    <fct>         <dbl>\n#>  1 setosa          3.5\n#>  2 setosa          3  \n#>  3 setosa          3.2\n#>  4 setosa          3.1\n#>  5 setosa          3.6\n#>  6 setosa          3.9\n#>  7 setosa          3.4\n#>  8 setosa          3.4\n#>  9 setosa          2.9\n#> 10 setosa          3.1\n#> # … with 39 more rows"},{"path":"ch04.html","id":"讀取表格式資料-.csv","chapter":"4 Data Frame 處理：dplyr","heading":"4.2 讀取表格式資料 (.csv)","text":"可使用 RStudio Environment Pane  >  Import Dataset  >  Text (readr)...，或直接使用指令：\n\nbabynames <- readr::read_csv('babynames.csv')\nbabynames\n#> # tibble: 177,780 x 5\n#>     year sex   name        n   prop\n#>    <dbl> <chr> <chr>   <dbl>  <dbl>\n#>  1  1880 M     John     9655 0.0815\n#>  2  1880 M     William  9532 0.0805\n#>  3  1880 M     James    5927 0.0501\n#>  4  1880 M     Charles  5348 0.0452\n#>  5  1880 M     George   5126 0.0433\n#>  6  1880 M     Frank    3242 0.0274\n#>  7  1880 M     Joseph   2632 0.0222\n#>  8  1880 M     Thomas   2534 0.0214\n#>  9  1880 M     Henry    2444 0.0206\n#> 10  1880 M     Robert   2415 0.0204\n#> # … 177,770 rows\n如此便會將外部檔案讀入成 tibble (data frame)可使用 RStudio Environment Pane  >  Import Dataset  >  Text (readr)...，或直接使用指令：如此便會將外部檔案讀入成 tibble (data frame)","code":"\nbabynames <- readr::read_csv('babynames.csv')\nbabynames#> # A tibble: 177,780 x 5\n#>     year sex   name        n   prop\n#>    <dbl> <chr> <chr>   <dbl>  <dbl>\n#>  1  1880 M     John     9655 0.0815\n#>  2  1880 M     William  9532 0.0805\n#>  3  1880 M     James    5927 0.0501\n#>  4  1880 M     Charles  5348 0.0452\n#>  5  1880 M     George   5126 0.0433\n#>  6  1880 M     Frank    3242 0.0274\n#>  7  1880 M     Joseph   2632 0.0222\n#>  8  1880 M     Thomas   2534 0.0214\n#>  9  1880 M     Henry    2444 0.0206\n#> 10  1880 M     Robert   2415 0.0204\n#> # … with 177,770 more rows"},{"path":"ch04.html","id":"functions-for-isolating-data-in-dplyr","chapter":"4 Data Frame 處理：dplyr","heading":"4.3 Functions for “isolating data” in dplyr","text":"dplyr 有 2 個重要的函數可以用來取代上週講過得 [<vector 1> , <vector 2>]\nselect(): 篩選出 data frame 中的變項 (variables) (.e. columns data frame)\nfilter(): 篩選出 data frame 中特定的觀察值 (observations) (.e. rows data frame)\nselect() 與 filter() 分別取代了 [<vector 1> , <vector 2>] 之中的 vector 2 與 vector 1 的功能。除此之外，dplyr 還有 arrange() 可以用來將觀察值依據某些變項進行排序。\nselect(): 篩選出 data frame 中的變項 (variables) (.e. columns data frame)filter(): 篩選出 data frame 中特定的觀察值 (observations) (.e. rows data frame)select() 與 filter() 分別取代了 [<vector 1> , <vector 2>] 之中的 vector 2 與 vector 1 的功能。除此之外，dplyr 還有 arrange() 可以用來將觀察值依據某些變項進行排序。","code":""},{"path":"ch04.html","id":"select-篩選出特定變項","chapter":"4 Data Frame 處理：dplyr","heading":"4.4 select(): 篩選出特定變項","text":"\nFigure 4.1: 篩選出 babynames 中的 name 與 prop 變項。\n","code":"\nlibrary(dplyr)\n\n# select(<data frame>, <variable name in df>, <variable name in df>, ...)\nselect(babynames, name, prop)  # eqivalent to babynames[, c(\"name\", \"prop\")]#> # A tibble: 177,780 x 2\n#>    name      prop\n#>    <chr>    <dbl>\n#>  1 John    0.0815\n#>  2 William 0.0805\n#>  3 James   0.0501\n#>  4 Charles 0.0452\n#>  5 George  0.0433\n#>  6 Frank   0.0274\n#>  7 Joseph  0.0222\n#>  8 Thomas  0.0214\n#>  9 Henry   0.0206\n#> 10 Robert  0.0204\n#> # … with 177,770 more rows"},{"path":"ch04.html","id":"helpers","chapter":"4 Data Frame 處理：dplyr","heading":"4.4.1 helpers","text":"dplyr 額外提供了一些函數，方便使用者依據變項名稱的特性去篩選變項：\n\niris_ <- as_tibble(iris)\nselect(iris_, starts_with('Sepal'))\n#> # tibble: 150 x 2\n#>    Sepal.Length Sepal.Width\n#>           <dbl>       <dbl>\n#>  1          5.1         3.5\n#>  2          4.9         3  \n#>  3          4.7         3.2\n#>  4          4.6         3.1\n#>  5          5           3.6\n#>  6          5.4         3.9\n#>  7          4.6         3.4\n#>  8          5           3.4\n#>  9          4.4         2.9\n#> 10          4.9         3.1\n#> # … 140 rows\n\nselect(iris_, ends_with('Width'))\n#> # tibble: 150 x 2\n#>    Sepal.Width Petal.Width\n#>          <dbl>       <dbl>\n#>  1         3.5         0.2\n#>  2         3           0.2\n#>  3         3.2         0.2\n#>  4         3.1         0.2\n#>  5         3.6         0.2\n#>  6         3.9         0.4\n#>  7         3.4         0.3\n#>  8         3.4         0.2\n#>  9         2.9         0.2\n#> 10         3.1         0.1\n#> # … 140 rows\n\nselect(iris_, contains('.'))\n#> # tibble: 150 x 4\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width\n#>           <dbl>       <dbl>        <dbl>       <dbl>\n#>  1          5.1         3.5          1.4         0.2\n#>  2          4.9         3            1.4         0.2\n#>  3          4.7         3.2          1.3         0.2\n#>  4          4.6         3.1          1.5         0.2\n#>  5          5           3.6          1.4         0.2\n#>  6          5.4         3.9          1.7         0.4\n#>  7          4.6         3.4          1.4         0.3\n#>  8          5           3.4          1.5         0.2\n#>  9          4.4         2.9          1.4         0.2\n#> 10          4.9         3.1          1.5         0.1\n#> # … 140 rows\n\ndf <- tibble(x_1 = 1:10, x_2 = 11:20, x_3 = 21:30, x_4 = 31:40, x_5 = 41:50)\nselect(df, num_range(\"x_\", 2:4))\n#> # tibble: 10 x 3\n#>      x_2   x_3   x_4\n#>    <int> <int> <int>\n#>  1    11    21    31\n#>  2    12    22    32\n#>  3    13    23    33\n#>  4    14    24    34\n#>  5    15    25    35\n#>  6    16    26    36\n#>  7    17    27    37\n#>  8    18    28    38\n#>  9    19    29    39\n#> 10    20    30    40\n\n# can still quote variable names\nselect(df, \"x_1\", \"x_2\", \"x_3\")\n#> # tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30\n\n# `select()` can mixed base R's `paste0()`\nselect(df, paste0(\"x_\", 1:3))\n#> # tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30dplyr 額外提供了一些函數，方便使用者依據變項名稱的特性去篩選變項：","code":"\niris_ <- as_tibble(iris)\nselect(iris_, starts_with('Sepal'))#> # A tibble: 150 x 2\n#>    Sepal.Length Sepal.Width\n#>           <dbl>       <dbl>\n#>  1          5.1         3.5\n#>  2          4.9         3  \n#>  3          4.7         3.2\n#>  4          4.6         3.1\n#>  5          5           3.6\n#>  6          5.4         3.9\n#>  7          4.6         3.4\n#>  8          5           3.4\n#>  9          4.4         2.9\n#> 10          4.9         3.1\n#> # … with 140 more rows\nselect(iris_, ends_with('Width'))#> # A tibble: 150 x 2\n#>    Sepal.Width Petal.Width\n#>          <dbl>       <dbl>\n#>  1         3.5         0.2\n#>  2         3           0.2\n#>  3         3.2         0.2\n#>  4         3.1         0.2\n#>  5         3.6         0.2\n#>  6         3.9         0.4\n#>  7         3.4         0.3\n#>  8         3.4         0.2\n#>  9         2.9         0.2\n#> 10         3.1         0.1\n#> # … with 140 more rows\nselect(iris_, contains('.'))#> # A tibble: 150 x 4\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width\n#>           <dbl>       <dbl>        <dbl>       <dbl>\n#>  1          5.1         3.5          1.4         0.2\n#>  2          4.9         3            1.4         0.2\n#>  3          4.7         3.2          1.3         0.2\n#>  4          4.6         3.1          1.5         0.2\n#>  5          5           3.6          1.4         0.2\n#>  6          5.4         3.9          1.7         0.4\n#>  7          4.6         3.4          1.4         0.3\n#>  8          5           3.4          1.5         0.2\n#>  9          4.4         2.9          1.4         0.2\n#> 10          4.9         3.1          1.5         0.1\n#> # … with 140 more rows\ndf <- tibble(x_1 = 1:10, x_2 = 11:20, x_3 = 21:30, x_4 = 31:40, x_5 = 41:50)\nselect(df, num_range(\"x_\", 2:4))#> # A tibble: 10 x 3\n#>      x_2   x_3   x_4\n#>    <int> <int> <int>\n#>  1    11    21    31\n#>  2    12    22    32\n#>  3    13    23    33\n#>  4    14    24    34\n#>  5    15    25    35\n#>  6    16    26    36\n#>  7    17    27    37\n#>  8    18    28    38\n#>  9    19    29    39\n#> 10    20    30    40\n# You can still quote the variable names\nselect(df, \"x_1\", \"x_2\", \"x_3\")#> # A tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30\n# So `select()` can be mixed with base R's `paste0()`\nselect(df, paste0(\"x_\", 1:3))#> # A tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30"},{"path":"ch04.html","id":"filter-篩選出特定觀察值","chapter":"4 Data Frame 處理：dplyr","heading":"4.5 filter(): 篩選出特定觀察值","text":"\nFigure 4.2: 篩選出 babynames 中的 name 為 “Garrett” 的觀察值。\n","code":"\n# filter(<data frame>, <logical test on variable>, <logical test on variable>, ...)\nfilter(babynames, name == \"Garrett\")#> # A tibble: 13 x 5\n#>     year sex   name        n       prop\n#>    <dbl> <chr> <chr>   <dbl>      <dbl>\n#>  1  1880 M     Garrett    13 0.000110  \n#>  2  1881 M     Garrett     7 0.0000646 \n#>  3  1882 M     Garrett    15 0.000123  \n#>  4  1883 M     Garrett    13 0.000116  \n#>  5  1884 M     Garrett    15 0.000122  \n#>  6  1885 M     Garrett     9 0.0000776 \n#>  7  2013 M     Garrett  1613 0.000800  \n#>  8  2013 F     Garrett     5 0.0000026 \n#>  9  2014 M     Garrett  1562 0.000764  \n#> 10  2014 F     Garrett     6 0.00000307\n#> 11  2015 M     Garrett  1349 0.000662  \n#> 12  2016 M     Garrett  1146 0.000568  \n#> 13  2017 M     Garrett  1056 0.000538\nfilter(babynames, (name == \"Garrett\") & (year < 1885))#> # A tibble: 5 x 5\n#>    year sex   name        n      prop\n#>   <dbl> <chr> <chr>   <dbl>     <dbl>\n#> 1  1880 M     Garrett    13 0.000110 \n#> 2  1881 M     Garrett     7 0.0000646\n#> 3  1882 M     Garrett    15 0.000123 \n#> 4  1883 M     Garrett    13 0.000116 \n#> 5  1884 M     Garrett    15 0.000122\nfilter(babynames, name == \"Garrett\", year < 1885)  # equivalent to the previous command#> # A tibble: 5 x 5\n#>    year sex   name        n      prop\n#>   <dbl> <chr> <chr>   <dbl>     <dbl>\n#> 1  1880 M     Garrett    13 0.000110 \n#> 2  1881 M     Garrett     7 0.0000646\n#> 3  1882 M     Garrett    15 0.000123 \n#> 4  1883 M     Garrett    13 0.000116 \n#> 5  1884 M     Garrett    15 0.000122"},{"path":"ch04.html","id":"arrange-重新排序觀察值","chapter":"4 Data Frame 處理：dplyr","heading":"4.6 arrange(): 重新排序觀察值","text":"\nFigure 4.3: 依據變項 n 的大小由小至大排序 babynames 中的觀察值。\nPop quiz 3: answer","code":"\n#arrange(<data frame>, <variable name in df>, <variable name in df>, ...)\narrange(babynames, n)#> # A tibble: 177,780 x 5\n#>     year sex   name         n      prop\n#>    <dbl> <chr> <chr>    <dbl>     <dbl>\n#>  1  1880 M     Ab           5 0.0000422\n#>  2  1880 M     Abbott       5 0.0000422\n#>  3  1880 M     Agustus      5 0.0000422\n#>  4  1880 M     Albertus     5 0.0000422\n#>  5  1880 M     Almer        5 0.0000422\n#>  6  1880 M     Alphonso     5 0.0000422\n#>  7  1880 M     Alvia        5 0.0000422\n#>  8  1880 M     Artie        5 0.0000422\n#>  9  1880 M     Arvid        5 0.0000422\n#> 10  1880 M     Ashby        5 0.0000422\n#> # … with 177,770 more rows\n# 由大至小排序 (降冪)\narrange(babynames, desc(n))#> # A tibble: 177,780 x 5\n#>     year sex   name       n    prop\n#>    <dbl> <chr> <chr>  <dbl>   <dbl>\n#>  1  2013 F     Sophia 21213 0.0110 \n#>  2  2013 F     Emma   20936 0.0109 \n#>  3  2014 F     Emma   20924 0.0107 \n#>  4  2015 F     Emma   20435 0.0105 \n#>  5  2014 F     Olivia 19791 0.0101 \n#>  6  2017 F     Emma   19738 0.0105 \n#>  7  2015 F     Olivia 19669 0.0101 \n#>  8  2015 M     Noah   19613 0.00962\n#>  9  2016 F     Emma   19471 0.0101 \n#> 10  2016 F     Olivia 19327 0.0100 \n#> # … with 177,770 more rows\n# Order first by `year` then by `name`\narrange(babynames, year, name)#> # A tibble: 177,780 x 5\n#>     year sex   name        n      prop\n#>    <dbl> <chr> <chr>   <dbl>     <dbl>\n#>  1  1880 M     Aaron     102 0.000861 \n#>  2  1880 M     Ab          5 0.0000422\n#>  3  1880 F     Abbie      71 0.000727 \n#>  4  1880 M     Abbott      5 0.0000422\n#>  5  1880 F     Abby        6 0.0000615\n#>  6  1880 M     Abe        50 0.000422 \n#>  7  1880 M     Abel        9 0.0000760\n#>  8  1880 F     Abigail    12 0.000123 \n#>  9  1880 M     Abner      27 0.000228 \n#> 10  1880 M     Abraham    81 0.000684 \n#> # … with 177,770 more rows\n# Order first by `name` then by `year`\narrange(babynames, name, year)#> # A tibble: 177,780 x 5\n#>     year sex   name      n       prop\n#>    <dbl> <chr> <chr> <dbl>      <dbl>\n#>  1  2013 M     Aaban    14 0.00000694\n#>  2  2014 M     Aaban    16 0.00000783\n#>  3  2015 M     Aaban    15 0.00000736\n#>  4  2016 M     Aaban     9 0.00000446\n#>  5  2017 M     Aaban    11 0.0000056 \n#>  6  2014 F     Aabha     9 0.00000461\n#>  7  2015 F     Aabha     7 0.0000036 \n#>  8  2016 F     Aabha     7 0.00000363\n#>  9  2016 M     Aabid     5 0.00000248\n#> 10  2016 M     Aabir     5 0.00000248\n#> # … with 177,770 more rows\ngirls2017 <- filter(babynames, year == 2017, sex == \"F\")\ngirls2017 <- select(girls2017, name, n)\ngirls2017 <- arrange(girls2017, desc(n))\ngirls2017"},{"path":"ch04.html","id":"connecting-multiple-dplyr-functions-together","chapter":"4 Data Frame 處理：dplyr","heading":"4.7 %>%: Connecting multiple dplyr functions together","text":"dplyr 的函數一次只能做一件事情:select() 只能用來篩選變項、filter() 只能用來篩選觀察值、arrange() 只能用來排序資料。但資料整理的過程中往往需要一次做很多事情，例如，可能需要在篩選完觀察值之後再進行排序。如果每次呼叫完一個函數就必須將結果儲存在一個變項，會讓整理資料的過程變得很麻煩，例如：\n\ngirls2017 <- filter(babynames, year == 2017, sex == \"F\")\ngirls2017 <- select(girls2017, name, n)\ngirls2017 <- arrange(girls2017, desc(n))\ngirls2017\n#> # tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … 18,299 rowsdplyr 的函數一次只能做一件事情:select() 只能用來篩選變項、filter() 只能用來篩選觀察值、arrange() 只能用來排序資料。但資料整理的過程中往往需要一次做很多事情，例如，可能需要在篩選完觀察值之後再進行排序。如果每次呼叫完一個函數就必須將結果儲存在一個變項，會讓整理資料的過程變得很麻煩，例如：dplyr (精確地說是 magrittr) 因此提供了一種特殊的 binary operator %>%，讓使用者可以將位在 %>% 左側之表達式的執行結果 (回傳值) 做為位在 %>% 右側之函數的第一個輸入值 (引數, argument)：\n\n# Two equivalent expressions\nfilter(babynames, year == 2017, sex == \"F\")\n\ncat('\\n\\n')  # 讓印出結果比較好看\n\nbabynames %>% filter(year == 2017, sex == \"F\")\n#> # tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … 18,299 rows\n#> \n#> \n#> # tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … 18,299 rows\n如此便可將整理資料的過程改寫成一條「由一個個函數串成的」指令，如下\n\nbabynames %>% \n    filter(year == 2017, sex == \"F\") %>% \n    select(name, n) %>%\n    arrange(desc(n))\n#> # tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … 18,299 rowsdplyr (精確地說是 magrittr) 因此提供了一種特殊的 binary operator %>%，讓使用者可以將位在 %>% 左側之表達式的執行結果 (回傳值) 做為位在 %>% 右側之函數的第一個輸入值 (引數, argument)：如此便可將整理資料的過程改寫成一條「由一個個函數串成的」指令，如下","code":"\ngirls2017 <- filter(babynames, year == 2017, sex == \"F\")\ngirls2017 <- select(girls2017, name, n)\ngirls2017 <- arrange(girls2017, desc(n))\ngirls2017#> # A tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … with 18,299 more rows\n# Two equivalent expressions\nfilter(babynames, year == 2017, sex == \"F\")\n\ncat('\\n\\n')  # 讓印出結果比較好看\n\nbabynames %>% filter(year == 2017, sex == \"F\")#> # A tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … with 18,299 more rows\n#> \n#> \n#> # A tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … with 18,299 more rows\nbabynames %>% \n    filter(year == 2017, sex == \"F\") %>% \n    select(name, n) %>%\n    arrange(desc(n))#> # A tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … with 18,299 more rows"},{"path":"ch04.html","id":"functions-for-deriving-information-in-dplyr","chapter":"4 Data Frame 處理：dplyr","heading":"4.8 Functions for “deriving information” in dplyr","text":"上文介紹的內容是關於「如何篩選或排序既有的資料」。但有時候，我們需要從既有的資料去產出新的資料，例如根據既有資料的某些變項計算出新的變項，或是對既有資料做出一些摘要統計。面對這些需求，dplyr 提供了 2 個重要的函數：\nmutate(): 在 data frame 裡建立一個新的變項\nsummarise(): 對 data frame 裡的變項進行摘要，例如，計算某個變項的算術平均數、最大(小)值、變異數等\ngroup_by() 是 dplyr 中常與 summarise() 搭配使用的函數，其功能是將觀察值依據某些「類別變項」進行分類，如此 summarise() 就可依據分組後的結果去計算出各個組別內變項的摘要。例如，我們可以先使用 group_by() 將 babynames 的觀察值依據性別 (sex) 進行分類，再使用 summarise() 計算出這兩個性別的姓名 (name) 的數量。\n\nmutate(): 在 data frame 裡建立一個新的變項summarise(): 對 data frame 裡的變項進行摘要，例如，計算某個變項的算術平均數、最大(小)值、變異數等\ngroup_by() 是 dplyr 中常與 summarise() 搭配使用的函數，其功能是將觀察值依據某些「類別變項」進行分類，如此 summarise() 就可依據分組後的結果去計算出各個組別內變項的摘要。例如，我們可以先使用 group_by() 將 babynames 的觀察值依據性別 (sex) 進行分類，再使用 summarise() 計算出這兩個性別的姓名 (name) 的數量。\ngroup_by() 是 dplyr 中常與 summarise() 搭配使用的函數，其功能是將觀察值依據某些「類別變項」進行分類，如此 summarise() 就可依據分組後的結果去計算出各個組別內變項的摘要。例如，我們可以先使用 group_by() 將 babynames 的觀察值依據性別 (sex) 進行分類，再使用 summarise() 計算出這兩個性別的姓名 (name) 的數量。","code":""},{"path":"ch04.html","id":"mutate-建立新變項","chapter":"4 Data Frame 處理：dplyr","heading":"4.9 mutate(): 建立新變項","text":"\nFigure 4.4: 依據變項 prop 製造新變項 percent。\nmutate() 背後運作的原理是 R 的向量式運算，亦即，它是以一個變項 (.e. 向量) 當作操作的單元。因此，用於 mutate() 內的函數必須是所謂的 “vectorized function”：vectorized function 是指可接受一個或多個 vector 當作輸入值，並且會回傳長度相等的 vector的函數。","code":"\nbabynames %>% mutate(percent = prop*100)#> # A tibble: 177,780 x 6\n#>     year sex   name        n   prop percent\n#>    <dbl> <chr> <chr>   <dbl>  <dbl>   <dbl>\n#>  1  1880 M     John     9655 0.0815    8.15\n#>  2  1880 M     William  9532 0.0805    8.05\n#>  3  1880 M     James    5927 0.0501    5.01\n#>  4  1880 M     Charles  5348 0.0452    4.52\n#>  5  1880 M     George   5126 0.0433    4.33\n#>  6  1880 M     Frank    3242 0.0274    2.74\n#>  7  1880 M     Joseph   2632 0.0222    2.22\n#>  8  1880 M     Thomas   2534 0.0214    2.14\n#>  9  1880 M     Henry    2444 0.0206    2.06\n#> 10  1880 M     Robert   2415 0.0204    2.04\n#> # … with 177,770 more rows\nbabynames %>% mutate(sex2 = if_else(sex == \"F\", \"female\", \"male\"))#> # A tibble: 177,780 x 6\n#>     year sex   name        n   prop sex2 \n#>    <dbl> <chr> <chr>   <dbl>  <dbl> <chr>\n#>  1  1880 M     John     9655 0.0815 male \n#>  2  1880 M     William  9532 0.0805 male \n#>  3  1880 M     James    5927 0.0501 male \n#>  4  1880 M     Charles  5348 0.0452 male \n#>  5  1880 M     George   5126 0.0433 male \n#>  6  1880 M     Frank    3242 0.0274 male \n#>  7  1880 M     Joseph   2632 0.0222 male \n#>  8  1880 M     Thomas   2534 0.0214 male \n#>  9  1880 M     Henry    2444 0.0206 male \n#> 10  1880 M     Robert   2415 0.0204 male \n#> # … with 177,770 more rows"},{"path":"ch04.html","id":"summarise-對變項進行摘要","chapter":"4 Data Frame 處理：dplyr","heading":"4.10 summarise(): 對變項進行摘要","text":"\nFigure 4.5: 對變項 n 進行摘要 (計算總和與最大值)，並將摘要的結果儲存於兩個新變項 total 與 max。\n","code":"\nbabynames %>% summarise(total = sum(n), max = max(n))#> # A tibble: 1 x 2\n#>      total   max\n#>      <dbl> <dbl>\n#> 1 19538552 21213\nbabynames %>% summarise(num_of_rows = n(), num_of_names = n_distinct(name))#> # A tibble: 1 x 2\n#>   num_of_rows num_of_names\n#>         <int>        <int>\n#> 1      177780        45953"},{"path":"ch04.html","id":"group_by-先分類再摘要","chapter":"4 Data Frame 處理：dplyr","heading":"4.10.1 group_by(): 先分類再摘要","text":"\nFigure 4.6: 先將 pollution 的觀察值依據變項 city 分成 3 組，再各自對 3 組進行摘要 (計算污染量平均與總和) 求得之摘要表。\n","code":"\npollution <- tibble::tribble(\n     ~city,   ~size,   ~amount, \n  \"New York\", \"large\",      23,\n  \"New York\", \"small\",      14,\n  \"London\",   \"large\",      22,\n  \"London\",   \"small\",      16,\n  \"Beijing\",  \"large\",      121,\n  \"Beijing\",  \"small\",      56\n)\npollution#> # A tibble: 6 x 3\n#>   city     size  amount\n#>   <chr>    <chr>  <dbl>\n#> 1 New York large     23\n#> 2 New York small     14\n#> 3 London   large     22\n#> 4 London   small     16\n#> 5 Beijing  large    121\n#> 6 Beijing  small     56\npollution %>% \n  group_by(city) %>% \n    summarise(mean = mean(amount), \n              sum = sum(amount),\n              count = n())#> # A tibble: 3 x 4\n#>   city      mean   sum count\n#>   <chr>    <dbl> <dbl> <int>\n#> 1 Beijing   88.5   177     2\n#> 2 London    19      38     2\n#> 3 New York  18.5    37     2\npollution %>% \n  group_by(city, size) %>% \n  summarise(mean = mean(amount),\n            sum = sum(amount),\n            count = n())#> # A tibble: 6 x 5\n#> # Groups:   city [3]\n#>   city     size   mean   sum count\n#>   <chr>    <chr> <dbl> <dbl> <int>\n#> 1 Beijing  large   121   121     1\n#> 2 Beijing  small    56    56     1\n#> 3 London   large    22    22     1\n#> 4 London   small    16    16     1\n#> 5 New York large    23    23     1\n#> 6 New York small    14    14     1"},{"path":"ch04.html","id":"參考資源-1","chapter":"4 Data Frame 處理：dplyr","heading":"參考資源","text":"Wickham, H., & Grolemund, G. (2017). R Data Science: Data transformationGrolemund, G. (2019). Transform Data dplyr","code":""},{"path":"ch05.html","id":"ch05","chapter":"5 視覺化：ggplot2","heading":"5 視覺化：ggplot2","text":"(投影片 /\n影片)material based Garrett Grolemund’s introduction ggplot2","code":""},{"path":"ch05.html","id":"r-的繪圖系統","chapter":"5 視覺化：ggplot2","heading":"5.1 R 的繪圖系統","text":"眾所皆知，R 語言的繪圖能力非常強大。相較其它統計套裝軟體，R 讓使用者能對圖的細部做許多調整，甚至去創造出獨特的圖片 (.e. 不屬於傳統統計圖範疇內的圖)。但隨著強大繪圖功能伴隨而來的便是異常複雜的繪圖函數。傳統的 R 即擁有很厲害的繪圖系統：base R graphics 與 lattice 套件皆是功能非常強大的繪圖系統，但其學習曲線也相當陡峭，因此，實習課僅會介紹 ggplot2 這個較易上手 (但功能仍相當強大) 的繪圖系統 (套件)。","code":""},{"path":"ch05.html","id":"今天用到的資料-diamonds","chapter":"5 視覺化：ggplot2","heading":"5.2 今天用到的資料: diamonds","text":"diamonds 是 ggplot2 套件的內建資料。這筆資料記錄著 5 萬多筆鑽石的售價以及各種資訊。可使用 ?diamonds 閱讀此資料各變項的說明。因為 diamonds 相當龐大，為減少運算時間，這裡從 diamonds 抽出 1500 筆資料儲存於 diam","code":"\nlibrary(dplyr)\nlibrary(ggplot2)\n\ndiam <- diamonds %>% sample_n(size = 1500)"},{"path":"ch05.html","id":"template-1","chapter":"5 視覺化：ggplot2","heading":"5.3 Template 1","text":"最基本的 ggplot 模板：\nggplot(data = <DATA>) +\n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))最基本的 ggplot 模板：使用模板繪製散布圖：\n\n\nFigure 5.1: ggplot() 的結構\n\n使用模板繪製散布圖：\nFigure 5.1: ggplot() 的結構\n","code":"ggplot(data = <DATA>) +\n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))"},{"path":"ch05.html","id":"散布圖-scatter-plot","chapter":"5 視覺化：ggplot2","heading":"5.3.1 散布圖 (Scatter plot)","text":"使用下方程式碼，可繪製出鑽石的重量 (克拉) 與價錢 (美元) 的關係 (散布圖)\n\nlibrary(ggplot2)\n\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price))\n使用下方程式碼，可繪製出鑽石的重量 (克拉) 與價錢 (美元) 的關係 (散布圖)","code":"\nlibrary(ggplot2)\n\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price))"},{"path":"ch05.html","id":"圖層","chapter":"5 視覺化：ggplot2","heading":"5.4 圖層","text":"在 ggplot 的概念中，圖片是由一層層的圖層堆疊起來的：\n第一層 (ggplot()) 是底圖 (初始化繪圖函數)。在這層定義的內容 (e.g. data) 可被之後的圖層使用。\n\nggplot(data = diam)   # 底層\n\n第二層 (geom_point()) 畫在底圖之上。圖層之間以 + 連結起來,要將第一與第二層連起來，得在繪製第一層圖層的程式碼之後加上一個 +：\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price))    # 第二層\n\n如果想增加其它圖層，只要再繼續使用 +:\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price)) +  # 第二層\n  geom_smooth(mapping = aes(x = carat, y = price))   # 第三層\n\n第一層 (ggplot()) 是底圖 (初始化繪圖函數)。在這層定義的內容 (e.g. data) 可被之後的圖層使用。\n\nggplot(data = diam)   # 底層\n第一層 (ggplot()) 是底圖 (初始化繪圖函數)。在這層定義的內容 (e.g. data) 可被之後的圖層使用。第二層 (geom_point()) 畫在底圖之上。圖層之間以 + 連結起來,要將第一與第二層連起來，得在繪製第一層圖層的程式碼之後加上一個 +：\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price))    # 第二層\n第二層 (geom_point()) 畫在底圖之上。圖層之間以 + 連結起來,要將第一與第二層連起來，得在繪製第一層圖層的程式碼之後加上一個 +：如果想增加其它圖層，只要再繼續使用 +:\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price)) +  # 第二層\n  geom_smooth(mapping = aes(x = carat, y = price))   # 第三層\n如果想增加其它圖層，只要再繼續使用 +:","code":"\nggplot(data = diam)   # 底層\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price))    # 第二層\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price)) +  # 第二層\n  geom_smooth(mapping = aes(x = carat, y = price))   # 第三層"},{"path":"ch05.html","id":"mapping-將資料對應至視覺屬性","chapter":"5 視覺化：ggplot2","heading":"5.5 Mapping: 將資料對應至視覺屬性","text":"要能繪製統計圖，必須先將抽象的資料 (.e. data frame) 對應至實際可見的視覺屬性上 (e.g. 位置、形狀、大小、顏色、透明度等) 。不同的統計圖，所需的「資料與視覺屬性間的對應關係」就不同。要能繪製統計圖，必須先將抽象的資料 (.e. data frame) 對應至實際可見的視覺屬性上 (e.g. 位置、形狀、大小、顏色、透明度等) 。不同的統計圖，所需的「資料與視覺屬性間的對應關係」就不同。要繪製一個散布圖，我們必須將 data frame 中的一個變項對應至 x 軸、另一個變項對應至 y 軸，以將 data frame 中的每筆觀察值 (抽象資料) 轉換成圖上的一個個點 (視覺屬性)要繪製一個散布圖，我們必須將 data frame 中的一個變項對應至 x 軸、另一個變項對應至 y 軸，以將 data frame 中的每筆觀察值 (抽象資料) 轉換成圖上的一個個點 (視覺屬性)geom_*() 中的參數 mapping，即在定義「data frame 中的資料與統計圖上之視覺屬性的關係」：\n\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price, color = clarity))\n\n在 aes() 裡面定義資料與視覺屬性間的關係\nx = carat: 將 diam 中的變項 carat 對應至散布圖的 x 軸\ny = price: 將 diam 中的變項 price 對應至散布圖的 y 軸\nx 與 y 會共同決定一個點的位置\ncolor = clarity: 將 diam 中的變項 clarity 對應至散布圖上點的顏色\n\ngeom_*() 中的參數 mapping，即在定義「data frame 中的資料與統計圖上之視覺屬性的關係」：在 aes() 裡面定義資料與視覺屬性間的關係\nx = carat: 將 diam 中的變項 carat 對應至散布圖的 x 軸\ny = price: 將 diam 中的變項 price 對應至散布圖的 y 軸\nx 與 y 會共同決定一個點的位置\ncolor = clarity: 將 diam 中的變項 clarity 對應至散布圖上點的顏色\nx = carat: 將 diam 中的變項 carat 對應至散布圖的 x 軸y = price: 將 diam 中的變項 price 對應至散布圖的 y 軸x 與 y 會共同決定一個點的位置color = clarity: 將 diam 中的變項 clarity 對應至散布圖上點的顏色\nFigure 5.2: Aesthetic Mappings\n","code":"\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price, color = clarity))"},{"path":"ch05.html","id":"長條圖-bar-chart","chapter":"5 視覺化：ggplot2","heading":"5.6 長條圖 (Bar chart)","text":"概念上，繪製長條圖與繪製散布圖是很不一樣的：\n散布圖上的視覺屬性可以直接對應到 data frame 裡的資料\n長條圖的視覺屬性 (bar 的長度) 無法直接對應到 data frame 裡的資料。它對應到的是由 data frame 裡的資料經過彙整的結果:\nx 軸上是某變項裡的各個類別組成的\ny 軸代表各個類別出現的次數\n\n概念上，繪製長條圖與繪製散布圖是很不一樣的：散布圖上的視覺屬性可以直接對應到 data frame 裡的資料長條圖的視覺屬性 (bar 的長度) 無法直接對應到 data frame 裡的資料。它對應到的是由 data frame 裡的資料經過彙整的結果:\nx 軸上是某變項裡的各個類別組成的\ny 軸代表各個類別出現的次數\nx 軸上是某變項裡的各個類別組成的y 軸代表各個類別出現的次數geom_bar() 是用來繪製長條圖的函數。在定義 mapping 時，只需將 data frame 的某個變項 (通常為類別變項) 對應至 x，geom_bar() 即會自動依據此變項計算出各類別的次數。換言之，在生成的長條圖中，y 軸 (count) 並非 data frame 的變項，而是 geom_bar() 幫你計算出來的東西，因此在定義 mapping 時，不需定義變項與 y 軸間的 mapping。\n\nggplot(data = diam) + \n  geom_bar(mapping = aes(x = cut))\ngeom_bar() 是用來繪製長條圖的函數。在定義 mapping 時，只需將 data frame 的某個變項 (通常為類別變項) 對應至 x，geom_bar() 即會自動依據此變項計算出各類別的次數。換言之，在生成的長條圖中，y 軸 (count) 並非 data frame 的變項，而是 geom_bar() 幫你計算出來的東西，因此在定義 mapping 時，不需定義變項與 y 軸間的 mapping。geom_bar() 在繪製長條圖之前，為符合繪圖需求而將傳入的 data frame 進行的運算，稱為 Statistical Transformation:\n\n\nFigure 5.3: geom_bar()’s default statistical transformation13\n\ngeom_bar() 在繪製長條圖之前，為符合繪圖需求而將傳入的 data frame 進行的運算，稱為 Statistical Transformation:\nFigure 5.3: geom_bar()’s default statistical transformation13\n","code":"\nggplot(data = diam) + \n  geom_bar(mapping = aes(x = cut))"},{"path":"ch05.html","id":"statistical-transformations","chapter":"5 視覺化：ggplot2","heading":"5.7 Statistical Transformations","text":"有時候，我們只能拿到已整理好的資料，換言之，我們無法從 x 裡面去計算出裡面各類別的次數 (count)，例如 sum_data 已儲存著 cut 當中各類別的次數 (count)：\n\nsum_data <- diam %>% \n  group_by(cut) %>%\n  summarise(count = n())\n\nsum_data\n#> # tibble: 5 x 2\n#>   cut       count\n#>   <ord>     <int>\n#> 1 Fair         41\n#> 2 Good        128\n#> 3 Good   386\n#> 4 Premium     363\n#> 5 Ideal       582有時候，我們只能拿到已整理好的資料，換言之，我們無法從 x 裡面去計算出裡面各類別的次數 (count)，例如 sum_data 已儲存著 cut 當中各類別的次數 (count)：如果想使用 sum_data 之中的變項直接去畫出長條圖，就需要覆寫 「geom_bar() 自動從 x 計算出次數」的預設行為。這個行為可由 geom_bar() 的 stat 參數進行設定。如果想使用 sum_data 之中的變項直接去畫出長條圖，就需要覆寫 「geom_bar() 自動從 x 計算出次數」的預設行為。這個行為可由 geom_bar() 的 stat 參數進行設定。geom_bar() 的 stat 預設值是 \"count\"，讓 geom_bar() 可以從「對應至 x 的變項」計算出此變項裡各類別的次數。geom_bar() 的 stat 預設值是 \"count\"，讓 geom_bar() 可以從「對應至 x 的變項」計算出此變項裡各類別的次數。若不想自動進行這種計算，而想直接使用 data frame 本身的變項，則可以將 stat 設為 \"identity\"，此時便可以在 mapping 中直接將 data frame 的變項對應至長條圖的 x 軸 與 y 軸：\n\n# stat = \"identity\"\nggplot(data = sum_data) +\n  geom_bar(mapping = aes(x = cut, y = count),\n           stat = \"identity\") +\n  labs(title = 'stat = \"identity\"')\n\n# stat = \"count\" (geom_bar 預設)\nggplot(data = diam) +\n  geom_bar(mapping = aes(x = cut),\n           stat = \"count\") +\n  labs(title = 'stat = \"count\" (default)')\n若不想自動進行這種計算，而想直接使用 data frame 本身的變項，則可以將 stat 設為 \"identity\"，此時便可以在 mapping 中直接將 data frame 的變項對應至長條圖的 x 軸 與 y 軸：","code":"\nsum_data <- diam %>% \n  group_by(cut) %>%\n  summarise(count = n())\n\nsum_data#> # A tibble: 5 x 2\n#>   cut       count\n#>   <ord>     <int>\n#> 1 Fair         41\n#> 2 Good        128\n#> 3 Very Good   386\n#> 4 Premium     363\n#> 5 Ideal       582\n# stat = \"identity\"\nggplot(data = sum_data) +\n  geom_bar(mapping = aes(x = cut, y = count),\n           stat = \"identity\") +\n  labs(title = 'stat = \"identity\"')\n\n# stat = \"count\" (geom_bar 預設)\nggplot(data = diam) +\n  geom_bar(mapping = aes(x = cut),\n           stat = \"count\") +\n  labs(title = 'stat = \"count\" (default)')"},{"path":"ch05.html","id":"geom_-與-stat-預設","chapter":"5 視覺化：ggplot2","heading":"5.7.1 geom_*() 與 stat 預設","text":"所有的 geom_*() 函數都會有一個 stat 的預設值：\ngeom_point() 預設 stat = \"identity\"，所以給定 x 與 y 兩個 mapping，便會將 data frame 中的變項對應至圖上的 x 軸與 y 軸。\ngeom_bar() 預設 stat = \"count\"，會從對應至 x 的變項中計算出該變項各個類別的次數，並將此次數繪於圖上的 y 軸\ngeom_point() 預設 stat = \"identity\"，所以給定 x 與 y 兩個 mapping，便會將 data frame 中的變項對應至圖上的 x 軸與 y 軸。geom_bar() 預設 stat = \"count\"，會從對應至 x 的變項中計算出該變項各個類別的次數，並將此次數繪於圖上的 y 軸","code":""},{"path":"ch05.html","id":"position-adjustments","chapter":"5 視覺化：ggplot2","heading":"5.8 Position Adjustments","text":"透過提供第二個 mapping, fill, geom_bar 能夠將每個長條再依據第二個類別變項進行細分。","code":"\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity))\n# position: stack (default)\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity),\n           position = \"stack\")\n\n# position: fill\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity),\n           position = \"fill\")\n\n# postion: dodge\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity),\n           position = \"dodge\")"},{"path":"ch05.html","id":"template-2","chapter":"5 視覺化：ggplot2","heading":"5.9 Template 2","text":"","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  )"},{"path":"ch05.html","id":"facet","chapter":"5 視覺化：ggplot2","heading":"5.10 Facet","text":"1 個類別變項\n\nggplot(data = diam) +\n  geom_point(aes(x = carat, y = price)) +\n  facet_wrap(vars(cut))\n1 個類別變項2 個類別變項\n\nggplot(data = diam) +\n      geom_point(mapping = aes(x = carat, \n                               y = price)) +\n      facet_grid(rows = vars(cut),\n                 cols = vars(clarity))\n2 個類別變項","code":"\nggplot(data = diam) +\n  geom_point(aes(x = carat, y = price)) +\n  facet_wrap(vars(cut))\nggplot(data = diam) +\n      geom_point(mapping = aes(x = carat, \n                               y = price)) +\n      facet_grid(rows = vars(cut),\n                 cols = vars(clarity))"},{"path":"ch05.html","id":"template-3","chapter":"5 視覺化：ggplot2","heading":"5.11 Template 3","text":"","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  ) +\n  <FACET_FUNCTION>"},{"path":"ch05.html","id":"geoms","chapter":"5 視覺化：ggplot2","heading":"5.12 Geoms","text":"","code":"\nggplot(mpg) +\n  geom_point(aes(class, hwy))\n#ggsave('mpg_class_hwy_point.png', width = 14, height = 12, units = 'cm')\n\nggplot(mpg) +\n  geom_boxplot(aes(class, hwy))\n#ggsave('mpg_class_hwy_boxplot.png', width = 14, height = 12, units = 'cm')\n\nggplot(mpg) +\n  geom_point(aes(class, hwy, color = drv))\n#ggsave('mpg_class_hwy_color.png', width = 16, height = 12, units = 'cm')"},{"path":"ch05.html","id":"參考資源-務必閱讀","chapter":"5 視覺化：ggplot2","heading":"參考資源 (務必閱讀)","text":"Wickham, H., & Grolemund, G. (2017). R Data Science: Data visualisation","code":""},{"path":"ch06.html","id":"ch06","chapter":"6 Simulating Data with R","heading":"6 Simulating Data with R","text":"(投影片 /\n程式碼 /\n影片)這堂實習課將介紹 R 語言裡面一些非常實用的統計學函數，並會以實例示範如何透過這些函數去模擬 (simulate) 統計學裡常見的一些概念與現象。","code":""},{"path":"ch06.html","id":"分配-distribution","chapter":"6 Simulating Data with R","heading":"6.1 分配 (Distribution)","text":"R 內建許多統計分配的函數，例如 *unif (均勻分配, Uniform), *norm (常態分配, Normal), *binom (二項分配, Binomial), *pois (泊松分配, Poisson) 等R 內建許多統計分配的函數，例如 *unif (均勻分配, Uniform), *norm (常態分配, Normal), *binom (二項分配, Binomial), *pois (泊松分配, Poisson) 等每種分配都有一個「家族」的函數，用來做不同事情。例如，以常態分配為例 (詳見說明文件 ?dnorm)：\ndnorm(): 常態分配的機率密度\npnorm(): 常態分配的累積機率密度\nrnorm(): 從常態分配抽取出來的樣本 (隨機數)\nqnorm(): 常態分配的 分位數 (quantile function)\n每種分配都有一個「家族」的函數，用來做不同事情。例如，以常態分配為例 (詳見說明文件 ?dnorm)：dnorm(): 常態分配的機率密度pnorm(): 常態分配的累積機率密度rnorm(): 從常態分配抽取出來的樣本 (隨機數)qnorm(): 常態分配的 分位數 (quantile function)接下來，我們會以常態分配作為例子示範。","code":""},{"path":"ch06.html","id":"dnorm","chapter":"6 Simulating Data with R","heading":"6.1.1 dnorm()","text":"我們可以使用 dnorm() 繪製常態分配 (鐘型曲線)。想法很簡單：製造一個 (間距很小的) 數列為每一個數列裡的值計算出相對應的機率密度以平均 = 160、標準差 = 5 的常態分配 (台灣成人女性身高) 為例:\\[\nHeight \\sim Normal(\\mu = 160, \\sigma = 5)\n\\]","code":"\nlibrary(ggplot2)\nggplot2::theme_set(ggplot2::theme_bw())\n\nheight <- seq(140, 180, by = 0.01)\ndensity <- dnorm(x = height, mean = 160, sd = 5)\n\ndf <- data.frame(\n    height = height,\n    density = density\n)\n\nggplot(df) +\n   geom_point(aes(x = height, y = density), \n              size = 0.1)"},{"path":"ch06.html","id":"rnorm","chapter":"6 Simulating Data with R","heading":"6.1.2 rnorm()","text":"rnorm() 則可以讓我們從常態分配裡取抽取出樣本。例如，若我們想從剛剛的女性身高分配 (\\(\\mu = 160, \\sigma = 5\\)) 裡抽取出 3 個樣本：注意，因為 rnorm() 是隨機抽取14，所以每次的結果都會不同。但當我們抽取的樣本數夠大時，這些樣本形成的分配就會趨近樣本所來自的常態分配。我們可以用 rnorm() 來示範這件事：我們計算所得到的樣本平均數 (160.0583821) 與標準差 (5.0541591) 與原本的常態分配相當接近 (平均 = 160, 標準差 = 5)。除此之外，我們可以將還可以將原本的分配與抽樣的分配進行比較：上圖的曲線即是透過剛剛 dnorm() 計算出來的常態分配機率密度。粉紅色的直方圖則是樣本的資料。","code":"\nrnorm(n = 3, mean = 160, sd = 5)#> [1] 158.4752 155.9250 159.7559\nsampled_height <- rnorm(n = nrow(df), mean = 160, sd = 5)\nmean(sampled_height)  # Sample's mean\nsd(sampled_height)    # Sample's standard deviation#> [1] 160.0584\n#> [1] 5.054159\nggplot() +\n   geom_histogram(mapping = aes(x = sampled_height, \n                                y = ..density..),\n                  binwidth = 0.8, fill = \"pink\", color = \"grey\") +\n   geom_point(data = df,\n             mapping = aes(x = height, y = density),\n             size = 0.1)"},{"path":"ch06.html","id":"相關-correlation","chapter":"6 Simulating Data with R","heading":"6.2 相關 (Correlation)","text":"在 R 裡面，我們可以使用 cor() 計算兩組向量之間的皮爾森相關係數：我們可以透過 rnorm() 為 y 增添一些雜訊，讓 x, y 的相關不會是完美的：在自然界中，很多變項都呈現常態分配，除此之外，有時候不同變項之間會有線性相關。例如，兒子的身高受父親影響，所以兩者會有正向關係。此外，兩者的身高各自都會呈現常態分配 (有不同的平均與標準差)。透過 rnorm()，我們可以很容易地模擬這些關係：假設父親的身高 \\(x_i \\sim Normal(\\mu=165, \\sigma=5)\\)假設兒子的身高 (\\(y_i\\)) 受父親的直接影響：\\(y_i \\sim Normal(\\mu = x_i, \\sigma=5)\\)透過剛剛的模擬，可以得到父親與兒子的身高之間的相關是 0.7220075。學過迴歸統計的同學，應該會記得我們也可以透過簡單線性迴歸得到這個相關係數：若將父親與兒子的身高標準化 (取 Z 分數) 再去做迴歸 \\(y = \\alpha + \\beta x\\)，則這裡的 \\(\\beta\\) 即會是剛剛所得到的相關係數 0.7220075。在 R 裡面要使用線性迴歸可以透過 lm()。lm() 裡面放的是公式 (formula)，例如下方的 son_std ~ dad_std 即是在表達 \\(y = \\alpha + \\beta x\\) 這個關係。在上方的輸出裡，Coefficients 的 Estimate 即是 \\(\\alpha\\) (Intercept) 與 \\(\\beta\\) (dad_std) 的估計。可以看到這裡的 \\(\\beta\\) 與先前計算出來的相關係數是相同的。","code":"\n# Perfect correlation\nx <- 1:60\ny <- x + 10\nplot(x, y)\ncor(x, y)#> [1] 1\n# Add some noise\ny <- x + rnorm(n = length(x), mean = 0, sd = 7)\nplot(x, y)\ncor(x, y)#> [1] 0.927755\n# Simulating correlation b/t two normal distributions\ndad <- rnorm(n = 1000, mean = 165, sd = 5)\nson <- rnorm(n = 1000, mean = dad, sd = 5)\nplot(dad, son)\ncor(dad, son)#> [1] 0.7220075\n# 標準化\nZ <- function(x) (x - mean(x)) / sd(x)\ndad_std <- Z(dad)\nson_std <- Z(son)\n\n# Simple linear regression\nfit <- lm(son_std ~ dad_std)\nsummary(fit)#> \n#> Call:\n#> lm(formula = son_std ~ dad_std)\n#> \n#> Residuals:\n#>      Min       1Q   Median       3Q      Max \n#> -2.31852 -0.47300  0.00727  0.46413  2.22054 \n#> \n#> Coefficients:\n#>               Estimate Std. Error t value Pr(>|t|)    \n#> (Intercept) -1.337e-15  2.189e-02    0.00        1    \n#> dad_std      7.220e-01  2.190e-02   32.97   <2e-16 ***\n#> ---\n#> Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n#> \n#> Residual standard error: 0.6922 on 998 degrees of freedom\n#> Multiple R-squared:  0.5213, Adjusted R-squared:  0.5208 \n#> F-statistic:  1087 on 1 and 998 DF,  p-value: < 2.2e-16"},{"path":"ch06.html","id":"因果與相關-causation-vs.-correlation","chapter":"6 Simulating Data with R","heading":"6.3 因果與相關 (Causation vs. Correlation)","text":"大家應該都知道變項之間相關的存在不代表因果關係的存在15。但當變項間存在因果關係時，(在多數情況下) 變項之間也會存在相關。上方父親與兒子身高的例子，實際上就是在模擬這兩個變項之間的因果關係16。透過這類模擬，可以幫助我們去理解一些更複雜的概念。接下來，我們要透過剛剛所學的東西去模擬統計學中的混淆因子 (confounder) 與對撞因子 (collider)。","code":""},{"path":"ch06.html","id":"混淆因子-confounder-confounding-variable","chapter":"6 Simulating Data with R","heading":"6.4 混淆因子 (Confounder / Confounding Variable)","text":"下方的這張散布圖顯示出一個奇怪的現象：手搖杯的銷售量越高，溺水的人數就越多為什麼？難道是因為喝太多手搖杯會讓大家更容易抽筋，進而導致溺水人數的增加？\nFigure 6.1: 飲料銷售量與溺水人數關聯\n這個例子是一個經典的混淆因子的例子。混淆因子 (.k.. 混淆變項、干擾因子、干擾變項) 指的是對獨變項以及依變項皆有因果影響的變項 (Figure 6.2)。當混淆變項存在時，會造成獨變項與依變項之間產生虛假的關聯，例如：本來獨立的獨變項與依變項，會因為混淆變項而產生關聯本來關聯性不強的獨變項與依變項，會因為混淆變項而變得更強在上方的例子裡，手搖杯與溺水人數兩者本來應該是獨立的，但因為溫度這個混淆變項使兩者產生了正向關聯：溫度越高，越多人會去買手搖杯 (造成銷售量增高)，也越多人會去玩水 (造成溺水人數變多)。\nFigure 6.2: 混淆因子 (Confounder)\n","code":""},{"path":"ch06.html","id":"simulating-confounder","chapter":"6 Simulating Data with R","heading":"6.4.1 Simulating Confounder","text":"在 R 裡面，我們可以很容易地去模擬手搖杯的例子。首先，我們先模擬出這三個變項之間的因果結構:temp: 溫度drown: 溺水人數。高溫會造成溺水人數增加。drink: 飲料銷售量。高溫會造成飲料銷售量增加。這裡，我們假設這三個變項都來自標準差 = 1 的常態分配。為了讓資料更真實一點，這裡將這些變項做了線性轉換17，讓它們的值落在合理的範圍：temp: 10-40 度drown: 0-1234 人drink: 300-2000 杯接下來，我們就可以看看這三個變項之間彼此的關聯：上圖中間那欄最下方 (row = 3, column = 2) 的散布圖即是上方的手搖杯銷售量與溺水人數散布圖 (Figure 6.1)。在 (2, 3) 位置上的數字 (0.53) 即是手搖杯銷售量與溺水人數的相關係數。","code":"\nset.seed(2021)  # Make results reproducible\nN <- 500\ntemp <- rnorm(n = N, mean = 0, sd = 1)\ndrown <- rnorm(n = N, mean = temp, sd = 1)\ndrink <- rnorm(n = N, mean = temp, sd = 1)\nsource(\"functions.R\")\n\n# Scale to make data more realistic\ndf <- data.frame(\n    temp = minMaxScale(temp, m = 10, M = 40),\n    drown = minMaxScale(drown, m = 0, M = 1234), \n    drink = minMaxScale(drink, m = 300, M = 2000)\n)\n# Requires package `psych`, see functions.R\nplotPairs(df)"},{"path":"ch06.html","id":"controlling-for-confounder","chapter":"6 Simulating Data with R","heading":"6.4.2 Controlling for Confounder","text":"透過這幾張散布圖，我們能夠得知這三個變項之間彼此都有正向關聯。但這些圖本身並無法告訴我們哪些變項造成了哪些變項。要知道這點，我們需要兩個東西：這些變項之間的因果結構 (這樣我們才知道混淆變項是誰)更複雜的統計模型用來控制混淆變項的影響第一點我們已經知道了 (因為資料是我們自己模擬出來的)，但在現實世界中，我們通常不會知道真正的因果結構長什麼樣子。這時候就需要動用領域知識去做出因果結構的假設 (可以有很多種)，然後透過資料去檢驗並剔除不符的因果結構。至於第二點，我們可以使用多元迴歸模型。在只使用簡單迴歸模型的情況下，我們可能會錯誤推斷溺水人數的原因來自手搖杯銷售量：但若在迴歸模型中加入混淆變項，模型就會幫我們控制混淆變項的影響。這時，我們就可以得知在沒有混淆變項的影響下，手搖杯銷售量的提升對溺水人數的影響為何：透過多元迴歸的控制，可以看到 drink 對 drown 的影響從原本的 0.525 變成 0.045。換言之，飲料銷售量對於溺水人數幾乎沒有影響。在簡單迴歸裡，drink 對 drown 的影響其實來自溫度 temp (temp 對 drown 的影響是 0.692)。","code":"\nfit <- lm(Z(drown) ~ Z(drink), data = df)\nsummary(fit)$coefficients#>                 Estimate Std. Error      t value     Pr(>|t|)\n#> (Intercept) 1.896855e-16 0.03809807 4.978874e-15 1.000000e+00\n#> Z(drink)    5.250932e-01 0.03813623 1.376888e+01 8.849357e-37\nfit <- lm(Z(drown) ~ Z(drink) + Z(temp), data = df)\nsummary(fit)$coefficients#>                 Estimate Std. Error      t value     Pr(>|t|)\n#> (Intercept) 6.618100e-17 0.03092700 2.139910e-15 1.000000e+00\n#> Z(drink)    4.512621e-02 0.04299789 1.049498e+00 2.944589e-01\n#> Z(temp)     6.916087e-01 0.04299789 1.608471e+01 3.604313e-47"},{"path":"ch06.html","id":"dont-be-a-control-freak","chapter":"6 Simulating Data with R","heading":"6.5 Don’t be a Control Freak","text":"發現了多元迴歸的神奇功能之後，或許會以為在迴歸式裡面加入越多預測變項越好 (我當初就是如此認為)，因為這樣就能控制掉任何可能的混淆變項的影響，留下來最「乾淨」的迴歸係數 \\(\\beta_i\\)。這是錯的！！！18不經思考 (沒有因果結構) 地將變項丟進迴歸式裡不但會讓結果難以詮釋，甚至在某些情況下會製造出原本不存在的關聯。讓我們回到身高的例子。下方這筆資料包含 500 位男性的身高 (son) 以及這些男性的父親 (dad) 與母親 (mom) 的身高：假設我們想看父親的身高如何受母親以及兒子的身高影響19，這時我們可能就會很直觀地使用這個迴歸式：\\[\nDad = \\alpha + \\beta_{Mom} Mom + \\beta_{Son} Son\n\\]迴歸式的 \\(\\beta\\) 係數可能會讓我們得到一個結論：\\(\\beta_{mom}\\) = -0.519，所以…父親越高母親就越矮所以這代表什麼？矮的女性喜歡跟高的男性結婚？矮的男性也喜歡跟高的女性結婚？要不然為何父親與母親的身高會是負向關係？","code":"\nurl <- 'https://rlads2021.github.io/lab/src/collider.csv'\ndf <- readr::read_csv(url)\nhead(df)#> # A tibble: 6 x 3\n#>     mom   dad   son\n#>   <dbl> <dbl> <dbl>\n#> 1  158.  178.  173.\n#> 2  161.  163.  164.\n#> 3  162.  178.  175.\n#> 4  151.  163.  157.\n#> 5  170.  178.  178.\n#> 6  173.  167.  172.\nfit <- lm(Z(dad) ~ Z(mom) + Z(son), data = df)\nsummary(fit)$coefficient#>                  Estimate Std. Error       t value     Pr(>|t|)\n#> (Intercept)  4.725574e-16 0.03186325  1.483080e-14 1.000000e+00\n#> Z(mom)      -5.193205e-01 0.03986636 -1.302654e+01 1.404517e-33\n#> Z(son)       8.788082e-01 0.03986636  2.204386e+01 1.282788e-75"},{"path":"ch06.html","id":"對撞因子-collider","chapter":"6 Simulating Data with R","heading":"6.6 對撞因子 (Collider)","text":"其實在剛剛的資料裡，父親與母親的身高彼此是獨立的。它們之間的關聯之所以會產生，是因為在多元迴歸裡，我們控制了不該控制的變項。這筆身高的資料其實是來自於下圖的因果結構：\nFigure 6.3: 對撞因子 (Collider)\n母親與父親的身高對兒子的身高皆有直接的因果影響。在這種情況下，如果我們在迴歸式裡面去控制兒子的身高，就會造成原本獨立的父、母親身高產生虛假關聯。在這種因果結構中，兒子身高的這個變項稱為對撞因子 (Collider)。對撞因子指的是被多個變項直接影響的變項。因為有多個因果影響「匯入」同一個變項，所以稱作對撞因子。所以為何在控制了對撞因子之後，本來沒有關聯的變項會產生關聯呢？一個直觀的解釋是因為統計上的控制在概念上就是在固定某個變項的數值。所以在固定兒子的身高之後，一旦我知道母親的身高是矮的，我自然就會知道父親的身高是高的；反之亦成立，在固定兒子身高下，若父親是矮的，母親就會是高的20。接下來，我們來看看如何用 R 模擬這個現象。","code":""},{"path":"ch06.html","id":"simulating-collider","chapter":"6 Simulating Data with R","heading":"6.6.1 Simulating Collider","text":"首先，我們透過 rnorm() 模擬出上方的因果結構：mom: 母親身高dad: 父親身高son: 兒子身高。受父母身高的直接影響，且父親與母親的影響程度相同這裡，我們一樣將各變項進行線性轉換 (非必要)，讓資料看起來更直觀一點。我們將母親的身高平均轉換為 160；父親與兒子身高平均轉換為 170；三個變項的標準差皆轉換成 5。現在的這筆資料即與剛剛透過網路讀進來的 collider.csv 內容相同，我們可以透過相同的迴歸模型來檢驗看看：現在，若我們將對撞因子 son 從迴歸模型裡剔除，即可看到父親與母親的身高彼此之間沒有關聯：透過變項間的兩兩散布圖，我們也可以看到比較合理的趨勢：父母的身高是獨立的，兒子的身高與父母皆為正相關。","code":"\nset.seed(1914)  # Make results reproducible\nN <- 500        # Sample size\nmom <- rnorm(N)\ndad <- rnorm(N)\nson <- rnorm(N, mom + dad) # dad & mom causally influence son's height\n\n# Scale variables to make them more realistic\ndf <- data.frame(\n    mom = 160 + 5 * mom,    # Scale to Normal(160, 5)\n    dad = 170 + 5 * dad,    # Scale to Normal(170, 5)\n    son = 170 + 5 * Z(son)  # Scale to Normal(170, 5)\n)\nfit <- lm(Z(dad) ~ Z(mom) + Z(son), data = df)\nsummary(fit)$coefficient#>                  Estimate Std. Error       t value     Pr(>|t|)\n#> (Intercept)  4.725574e-16 0.03186325  1.483080e-14 1.000000e+00\n#> Z(mom)      -5.193205e-01 0.03986636 -1.302654e+01 1.404517e-33\n#> Z(son)       8.788082e-01 0.03986636  2.204386e+01 1.282788e-75\nfit <- lm(Z(dad) ~ Z(mom), data = df)\nsummary(fit)$coefficient#>                  Estimate Std. Error       t value  Pr(>|t|)\n#> (Intercept) -1.587427e-16 0.04476484 -3.546147e-15 1.0000000\n#> Z(mom)       7.903449e-03 0.04480967  1.763782e-01 0.8600685\nplotPairs(df)"},{"path":"ch06.html","id":"explaining-collider","chapter":"6 Simulating Data with R","heading":"6.6.2 Explaining Collider","text":"前文只透過文字描述為何「控制」對撞因子會造成原本獨立的變項產生關聯。現在我們可以透過剛剛的身高資料來幫助我們理解這件事情。下方的這幾張散布圖中，灰色的點是所有的資料，黑色的點則是身高被固定在某個數值21的樣本，藍色的線則是透過這些黑色的點所算出來的迴歸線。在這裡我們可以看到控制兒子身高的作用：父親與母親的身高產生了負向相關。","code":"\nplotRange <- function(df, lower, upper) {\n  \n  df_filt <- df[lower <= df$son & df$son < upper, ]\n  r <-  round(cor(df_filt$mom, df_filt$dad), 3)\n\n  pl <- ggplot(mapping = aes(mom, dad)) +\n      geom_point(data = df, color = \"grey\", size = 1) +\n      geom_point(data = df_filt, size = 1) +\n      geom_smooth(data = df_filt, size = 1,\n                  method = \"lm\", se=F) +\n      labs(subtitle = paste0(\"r = \", r, \"; son's height fixed at \", lower, \"~\", upper, \" cm\"))\n  return(pl)\n}\nrng <- seq(165, 175, by = 1.5)\nplts <- vector(\"list\", length = length(rng) - 1)\nfor (i in seq_along(rng)) {\n  if (i == length(rng)) break\n  plts[[i]] <- plotRange(df, rng[i], rng[i + 1])\n}\npatchwork::wrap_plots(plts, ncol = 2)"},{"path":"ch06.html","id":"進階閱讀","chapter":"6 Simulating Data with R","heading":"進階閱讀","text":"Pearl, J., Glymour, M., & Jewell, N. P. (2016). Causal inference statistics: primerPearl, J. (2009). Causality (2nd ed.)McElreath, R. (2020). Statistical rethinking: Bayesian course examples R Stan (2nd ed.)","code":""},{"path":"ch07.html","id":"ch07","chapter":"7 字串處理","heading":"7 字串處理","text":"(投影片 /\n程式碼 /\n影片)","code":""},{"path":"ch07.html","id":"regular-expression-️","chapter":"7 字串處理","heading":"7.1 Regular Expression (✍️)","text":"","code":""},{"path":"ch07.html","id":"basics-.-escape","chapter":"7 字串處理","heading":"7.1.1 Basics: ., ^, $, |, \\ (escape)","text":".: 萬用字元\n\n妹妹.正\n我妹妹很正我妹妹超正我妹妹超級正我妹妹 正\n\n\n妹妹..正\n我妹妹很正我妹妹超正我妹妹超級正我妹妹 正\n.: 萬用字元^, $: Anchors\n\n^你\n你妹妹很正我妹妹超正你沒有妹妹\n\n\n超正$\n你妹妹很正我妹妹超正你沒有妹妹\n^, $: Anchors(), |: group\n\ngre|ay\ngreygray\n\n\ngr(e|)y\ngreygray\n\n\n(很|超|超級)正\n我妹妹很正我妹妹超正我妹妹超級正\n(), |: group\\: escape\n\n妹妹超\\.級\\.正\n我妹妹超.級.正我妹妹超～級～正\n\\: escape","code":"我妹妹很正我妹妹超正我妹妹超級正我妹妹 正我妹妹很正我妹妹超正我妹妹超級正我妹妹 正你妹妹很正我妹妹超正你沒有妹妹你妹妹很正我妹妹超正你沒有妹妹greygraygreygray我妹妹很正我妹妹超正我妹妹超級正我妹妹超.級.正我妹妹超～級～正"},{"path":"ch07.html","id":"repetition","chapter":"7 字串處理","heading":"7.1.2 Repetition","text":"+, ?\n\n超+正\n我妹妹超正我妹妹超級正我妹妹超超超超正\n\n\n超級?正\n我妹妹超正我妹妹超級正我妹妹超超超超正\n\n\n超+級?正\n我妹妹超正我妹妹超級正我妹妹超超超超正\n+, ?{num}, {min,}, {,max}, {min,max}\n\n\\d{4}-\\d{2}-\\d{2}\n今天是 2019-10-31今天是 2019-2-10今天是 2019-1-1\n\n\n\\d{4}-\\d{1,2}-\\d{1,2}\n今天是 2019-10-31今天是 2019-2-10今天是 2019-1-1\n\n\n\\d{4}-\\d{1,}-\\d{1,}\n今天是 2019-1-10不存在 2019-555-555\n{num}, {min,}, {,max}, {min,max}","code":"我妹妹超正我妹妹超級正我妹妹超超超超正我妹妹超正我妹妹超級正我妹妹超超超超正我妹妹超正我妹妹超級正我妹妹超超超超正今天是 2019-10-31今天是 2019-2-10今天是 2019-1-1今天是 2019-10-31今天是 2019-2-10今天是 2019-1-1今天是 2019-1-10不存在 2019-555-555"},{"path":"ch07.html","id":"character-classes","chapter":"7 字串處理","heading":"7.1.3 Character classes","text":"\\s\n\n妹妹\\s超正\n我妹妹超正1 space: 我妹妹 超正1 tab: 我妹妹  超正2 tabs: 我妹妹        超正\n\n\n妹妹\\s+超正\n我妹妹超正我妹妹 超正我妹妹 超正我妹妹        超正\n\\s[]\n\n[超很極]正\n我妹妹超正我妹妹很正我妹妹極正我妹妹不正\n\n\n[B-D]1\nA1 B1 C1 D1 E1 F1 G1 H1 I1 J1 K1 L1 M1 N1 O1 P1 Q1 R1 S1 T1 U1 V1 W1 X1 Y1 Z1\n\n\n[2-5]\na1 a2 a3 a4 a5 a6 a7 a8 a9 a10\n\n\n[^2-5]\na1 a2 a3 a4 a5 a6 a7 a8 a9 a10\n[]","code":"我妹妹超正1 space: 我妹妹 超正1 tab: 我妹妹  超正2 tabs: 我妹妹        超正我妹妹超正我妹妹 超正我妹妹 超正我妹妹        超正我妹妹超正我妹妹很正我妹妹極正我妹妹不正A1 B1 C1 D1 E1 F1 G1 H1 I1 J1 K1 L1 M1 N1 O1 P1 Q1 R1 S1 T1 U1 V1 W1 X1 Y1 Z1a1 a2 a3 a4 a5 a6 a7 a8 a9 a10a1 a2 a3 a4 a5 a6 a7 a8 a9 a10"},{"path":"ch07.html","id":"your-turn","chapter":"7 字串處理","heading":"7.1.4 Your Turn","text":"找出所有記者姓名\n\n【.{3}╱.+報導】\n【賴德剛╱綜合報導】大聯盟勞資協議昨獲共識，要繳交超出部分的17.5%稅額，連續第2年則課30%，連續第3年40%，第4年起都是50%。新版協議，第1年稅額調高為20%，第2年不變，第3年起都是50％。【曾雪蒨╱台中報導】一名35歲OL是「3C控」，白天上班打電腦、訊軟體聲響，竟忍不住低頭滑手機看內容...【蔡裕隆╱彰化報導】台灣啤酒「台版天兵麥基(JaVale McGee)」周伯勳，昨出戰臺灣銀行，轟出全隊次高...【韓政燕╱綜合外電報導】日本前晚從鹿兒島縣種子島宇宙中心成功發射搭載無人補給太空船「鸛」6號的...【國際中心╱綜合外電報導】今年美國總統大選期間，大量假新聞充斥推特、臉書等社交網站，遭質疑扭曲真相...【鍾裕能╱綜合報導】巨人季後簽了陽岱鋼、山口俊、森福允彥共3名自由球員，又網羅前樂天大砲...\n找出所有記者姓名找出所有百分比 (e.g. 20%, 17.5%)\n\n[0-9.]+%\n【賴德剛╱綜合報導】大聯盟勞資協議昨獲共識，要繳交超出部分的17.5%稅額，連續第2年則課30%，連續第3年40%，第4年起都是50%。新版協議，第1年稅額調高為20%，第2年不變，第3年起都是50％。【曾雪蒨╱台中報導】一名35歲OL是「3C控」，白天上班打電腦、訊軟體聲響，竟忍不住低頭滑手機看內容...【蔡裕隆╱彰化報導】台灣啤酒「台版天兵麥基(JaVale McGee)」周伯勳，昨出戰臺灣銀行，轟出全隊次高...【韓政燕╱綜合外電報導】日本前晚從鹿兒島縣種子島宇宙中心成功發射搭載無人補給太空船「鸛」6號的...【國際中心╱綜合外電報導】今年美國總統大選期間，大量假新聞充斥推特、臉書等社交網站，遭質疑扭曲真相...【鍾裕能╱綜合報導】巨人季後簽了陽岱鋼、山口俊、森福允彥共3名自由球員，又網羅前樂天大砲...\n找出所有百分比 (e.g. 20%, 17.5%)","code":"【賴德剛╱綜合報導】大聯盟勞資協議昨獲共識，要繳交超出部分的17.5%稅額，連續第2年則課30%，連續第3年40%，第4年起都是50%。新版協議，第1年稅額調高為20%，第2年不變，第3年起都是50％。【曾雪蒨╱台中報導】一名35歲OL是「3C控」，白天上班打電腦、訊軟體聲響，竟忍不住低頭滑手機看內容...【蔡裕隆╱彰化報導】台灣啤酒「台版天兵麥基(JaVale McGee)」周伯勳，昨出戰臺灣銀行，轟出全隊次高...【韓政燕╱綜合外電報導】日本前晚從鹿兒島縣種子島宇宙中心成功發射搭載無人補給太空船「鸛」6號的...【國際中心╱綜合外電報導】今年美國總統大選期間，大量假新聞充斥推特、臉書等社交網站，遭質疑扭曲真相...【鍾裕能╱綜合報導】巨人季後簽了陽岱鋼、山口俊、森福允彥共3名自由球員，又網羅前樂天大砲...【賴德剛╱綜合報導】大聯盟勞資協議昨獲共識，要繳交超出部分的17.5%稅額，連續第2年則課30%，連續第3年40%，第4年起都是50%。新版協議，第1年稅額調高為20%，第2年不變，第3年起都是50％。【曾雪蒨╱台中報導】一名35歲OL是「3C控」，白天上班打電腦、訊軟體聲響，竟忍不住低頭滑手機看內容...【蔡裕隆╱彰化報導】台灣啤酒「台版天兵麥基(JaVale McGee)」周伯勳，昨出戰臺灣銀行，轟出全隊次高...【韓政燕╱綜合外電報導】日本前晚從鹿兒島縣種子島宇宙中心成功發射搭載無人補給太空船「鸛」6號的...【國際中心╱綜合外電報導】今年美國總統大選期間，大量假新聞充斥推特、臉書等社交網站，遭質疑扭曲真相...【鍾裕能╱綜合報導】巨人季後簽了陽岱鋼、山口俊、森福允彥共3名自由球員，又網羅前樂天大砲..."},{"path":"ch07.html","id":"backreference","chapter":"7 字串處理","heading":"7.1.5 Backreference","text":"","code":"防不勝防精益求精眉下添眉年復一年噩噩渾渾沸沸揚揚紛紛攘攘風風雨雨防不勝防精益求精眉下添眉年復一年噩噩渾渾沸沸揚揚紛紛攘攘風風雨雨"},{"path":"ch07.html","id":"your-turn-1","chapter":"7 字串處理","heading":"7.1.6 Your Turn","text":"","code":"一口接一口一口接著一口一口接著又一口一巴掌接著一巴掌"},{"path":"ch07.html","id":"stringr","chapter":"7 字串處理","heading":"7.2 stringr","text":"stringr 套件是 tidyverse 裡面用來處理字串的套件，比起 base R 的字串處理函數，stringr 中的函數在命名上相當一致 (str_*)、函數名稱也較「透明」因此比較容易記得。stringr 套件是 tidyverse 裡面用來處理字串的套件，比起 base R 的字串處理函數，stringr 中的函數在命名上相當一致 (str_*)、函數名稱也較「透明」因此比較容易記得。在 R 裡面，Regular Expression 是以字串的資料類型 (.e. character) 去表徵，因此有一點需特別注意：\n\n若 Regular Expression 裡面出現反斜線，則在將此 Regex 寫進 R 的函數時，需要在每一個反斜線之前再加上一個反斜線\n\nRegular Expression: today\\.$\n\ntoday\\.$\nsunny today.\n\nRegular Expression R function: \"today\\\\.$\"\n\nlibrary(stringr)\nstr_view(\"sunny today.\", \"today\\\\.$\")\n\n{\"x\":{\"html\":\"<ul>\\n  <li>sunny <span class='match'>today.<\\/span><\\/li>\\n<\\/ul>\"},\"evals\":[],\"jsHooks\":[]}\n在 R 裡面，Regular Expression 是以字串的資料類型 (.e. character) 去表徵，因此有一點需特別注意：若 Regular Expression 裡面出現反斜線，則在將此 Regex 寫進 R 的函數時，需要在每一個反斜線之前再加上一個反斜線Regular Expression: today\\.$\n\ntoday\\.$\nsunny today.\nRegular Expression: today\\.$Regular Expression R function: \"today\\\\.$\"\n\nlibrary(stringr)\nstr_view(\"sunny today.\", \"today\\\\.$\")\n\n{\"x\":{\"html\":\"<ul>\\n  <li>sunny <span class='match'>today.<\\/span><\\/li>\\n<\\/ul>\"},\"evals\":[],\"jsHooks\":[]}Regular Expression R function: \"today\\\\.$\"","code":"It is sunny today.\nlibrary(stringr)\nstr_view(\"It is sunny today.\", \"today\\\\.$\")"},{"path":"ch07.html","id":"str_detect","chapter":"7 字串處理","heading":"7.2.1 str_detect()","text":"str_detect() 可與 [] 或 dplyr::filter() 結合，用來篩選資料：\n\ns <- c(\"cat\", \"bed\", \"car\", \"Mr.\")\ns[str_detect(s, \"^c\")]\n#> [1] \"cat\" \"car\"str_detect() 可與 [] 或 dplyr::filter() 結合，用來篩選資料：","code":"\ns <- c(\"cat\", \"bed\", \"car\", \"Mr.\")\nstr_detect(s, \"a\")#> [1]  TRUE FALSE  TRUE FALSE\nstr_detect(s, \"\\\\.\")#> [1] FALSE FALSE FALSE  TRUE\ns <- c(\"cat\", \"bed\", \"car\", \"Mr.\")\ns[str_detect(s, \"^c\")]#> [1] \"cat\" \"car\""},{"path":"ch07.html","id":"str_match-str_match_all","chapter":"7 字串處理","heading":"7.2.2 str_match() / str_match_all()","text":"str_match() 可從文字裡抓出符合 RegEx 的字串。str_match() 只會抓出 str 每個元素裡第一個符合的字串，並且以 matrix 的資料結構回傳：\n\ns <- c(\"match.\", \n       \"One two three, four five six.\", \n       \"Seven eight nine.\")\nstr_match(s, \"([-zA-Z]+) ([-zA-Z]+) ([-zA-Z]+)\")\n#>      [,1]               [,2]    [,3]    [,4]   \n#> [1,] NA                 NA      NA      NA     \n#> [2,] \"One two three\"    \"One\"   \"two\"   \"three\"\n#> [3,] \"Seven eight nine\" \"Seven\" \"eight\" \"nine\"\n回傳的 matrix 中，\n每列 (row) 對應到 str 中的一個元素。在此，因為 str 長度為 3，因此回傳的 matrix 有 3 列。matrix 的每列代表 str 中每個元素 (字串) 中第一個符合 RegEx 的部份。\n第一行 (column) 是整個 RegEx 抓到的字串，.e. 符合 (\\w+) (\\w+) (\\w+) 的字串。後面幾行依序是 RegEx 中，各個 group 所抓到的字串，.e. 各個 () 裡的 RegEx。例如，第二行是第一個 (\\w+) 所抓到的內容；第三行則是第二個 (\\w+) 所抓到的內容；依此類推。\n\nstr_match() 可從文字裡抓出符合 RegEx 的字串。str_match() 只會抓出 str 每個元素裡第一個符合的字串，並且以 matrix 的資料結構回傳：回傳的 matrix 中，\n每列 (row) 對應到 str 中的一個元素。在此，因為 str 長度為 3，因此回傳的 matrix 有 3 列。matrix 的每列代表 str 中每個元素 (字串) 中第一個符合 RegEx 的部份。\n第一行 (column) 是整個 RegEx 抓到的字串，.e. 符合 (\\w+) (\\w+) (\\w+) 的字串。後面幾行依序是 RegEx 中，各個 group 所抓到的字串，.e. 各個 () 裡的 RegEx。例如，第二行是第一個 (\\w+) 所抓到的內容；第三行則是第二個 (\\w+) 所抓到的內容；依此類推。\n每列 (row) 對應到 str 中的一個元素。在此，因為 str 長度為 3，因此回傳的 matrix 有 3 列。matrix 的每列代表 str 中每個元素 (字串) 中第一個符合 RegEx 的部份。第一行 (column) 是整個 RegEx 抓到的字串，.e. 符合 (\\w+) (\\w+) (\\w+) 的字串。後面幾行依序是 RegEx 中，各個 group 所抓到的字串，.e. 各個 () 裡的 RegEx。例如，第二行是第一個 (\\w+) 所抓到的內容；第三行則是第二個 (\\w+) 所抓到的內容；依此類推。若要抓出所有符合的字串，需使用 str_match_all()22。str_match_all() 會抓出 str 每個元素裡所有符合的字串，並以 list 的資料結構回傳：\n\nstr_match_all(s, \"([-zA-Z]+) ([-zA-Z]+) ([-zA-Z]+)\")\n#> [[1]]\n#>      [,1] [,2] [,3] [,4]\n#> \n#> [[2]]\n#>      [,1]            [,2]   [,3]   [,4]   \n#> [1,] \"One two three\" \"One\"  \"two\"  \"three\"\n#> [2,] \"four five six\" \"four\" \"five\" \"six\"  \n#> \n#> [[3]]\n#>      [,1]               [,2]    [,3]    [,4]  \n#> [1,] \"Seven eight nine\" \"Seven\" \"eight\" \"nine\"\n回傳的 list 中，list 的每個元素依序對應到 str 的每個元素。因此，回傳的 list 長度為 3 (與 str 相同)\nlist 的每個元素內儲存的是一個 matrix，這個 matrix 的每列 (row) 對應到一個符合 RegEx 的字串。每行 (column) 的意義則與 str_match() 回傳的 matrix 相同。\n\n若要抓出所有符合的字串，需使用 str_match_all()22。str_match_all() 會抓出 str 每個元素裡所有符合的字串，並以 list 的資料結構回傳：回傳的 list 中，list 的每個元素依序對應到 str 的每個元素。因此，回傳的 list 長度為 3 (與 str 相同)\nlist 的每個元素內儲存的是一個 matrix，這個 matrix 的每列 (row) 對應到一個符合 RegEx 的字串。每行 (column) 的意義則與 str_match() 回傳的 matrix 相同。\nlist 的每個元素內儲存的是一個 matrix，這個 matrix 的每列 (row) 對應到一個符合 RegEx 的字串。每行 (column) 的意義則與 str_match() 回傳的 matrix 相同。","code":"\ns <- c(\"Won't match.\", \n       \"One two three, four five six.\", \n       \"Seven eight nine.\")\nstr_match(s, \"([a-zA-Z]+) ([a-zA-Z]+) ([a-zA-Z]+)\")#>      [,1]               [,2]    [,3]    [,4]   \n#> [1,] NA                 NA      NA      NA     \n#> [2,] \"One two three\"    \"One\"   \"two\"   \"three\"\n#> [3,] \"Seven eight nine\" \"Seven\" \"eight\" \"nine\"\nstr_match_all(s, \"([a-zA-Z]+) ([a-zA-Z]+) ([a-zA-Z]+)\")#> [[1]]\n#>      [,1] [,2] [,3] [,4]\n#> \n#> [[2]]\n#>      [,1]            [,2]   [,3]   [,4]   \n#> [1,] \"One two three\" \"One\"  \"two\"  \"three\"\n#> [2,] \"four five six\" \"four\" \"five\" \"six\"  \n#> \n#> [[3]]\n#>      [,1]               [,2]    [,3]    [,4]  \n#> [1,] \"Seven eight nine\" \"Seven\" \"eight\" \"nine\""},{"path":"ch07.html","id":"配合閱讀","chapter":"7 字串處理","heading":"7.3 配合閱讀","text":"R Data Science: StringsRegular Expressionstringr cheatsheet","code":""},{"path":"ch07.html","id":"相關資源","chapter":"7 字串處理","heading":"7.4 相關資源","text":"Regex One: RegEx 互動式學習RegEx Online Tester","code":""},{"path":"ch08.html","id":"ch08","chapter":"8 中文文本資料處理","heading":"8 中文文本資料處理","text":"(投影片 /\n程式碼 /\n影片)","code":""},{"path":"ch08.html","id":"斷詞","chapter":"8 中文文本資料處理","heading":"8.1 斷詞","text":"jieba 是一個用於中文斷詞的 (Python) 套件。jiebaR 則是 jieba 的 R 版本。使用 jiebaR 進行斷詞只須兩個步驟：使用 worker() 初始化斷詞設定使用 segment() 將文字斷詞jiebaR::segment() 回傳一個 character vector，vector 內的每個元素都是一個被斷出來的詞：\n\nlibrary(jiebaR)\nseg <- worker()\ntxt <- \"失業的熊讚陪柯文哲看銀翼殺手\" \nsegment(txt, seg)\n#> [1] \"失業\" \"的熊\" \"讚\"   \"陪\"   \"柯文\" \"哲看\" \"銀翼\" \"殺手\"jiebaR::segment() 回傳一個 character vector，vector 內的每個元素都是一個被斷出來的詞：jiebaR 的斷詞有時會不太精準，尤其是遇到專有名詞或是特殊詞彙時，這些詞彙時常會被斷開。若想避免這種情況，可以新增一份自訂辭典 (儲存在一份純文字檔，每個詞佔一行)，例如 user_dict.txt 的內容如下：\n熊讚\n柯文哲\n銀翼殺手\n如此在 worker() 中設定自訂辭典，jiebaR 就不會將這些詞彙斷開：\n\n# user dict\nseg <- worker(user = \"assets/corpus/user_dict.txt\")\nsegment(txt, seg)\n#> [1] \"失業\"     \"的\"       \"熊讚\"     \"陪\"       \"柯文哲\"   \"看\"       \"銀翼殺手\"jiebaR 的斷詞有時會不太精準，尤其是遇到專有名詞或是特殊詞彙時，這些詞彙時常會被斷開。若想避免這種情況，可以新增一份自訂辭典 (儲存在一份純文字檔，每個詞佔一行)，例如 user_dict.txt 的內容如下：如此在 worker() 中設定自訂辭典，jiebaR 就不會將這些詞彙斷開：","code":"\nlibrary(jiebaR)\nseg <- worker()\ntxt <- \"失業的熊讚陪柯文哲看銀翼殺手\" \nsegment(txt, seg)#> [1] \"失業\" \"的熊\" \"讚\"   \"陪\"   \"柯文\" \"哲看\" \"銀翼\" \"殺手\"熊讚\n柯文哲\n銀翼殺手\n# With user dict\nseg <- worker(user = \"assets/corpus/user_dict.txt\")\nsegment(txt, seg)#> [1] \"失業\"     \"的\"       \"熊讚\"     \"陪\"       \"柯文哲\"   \"看\"       \"銀翼殺手\""},{"path":"ch08.html","id":"使用-data-frame-建立語料庫","chapter":"8 中文文本資料處理","heading":"8.2 使用 data frame 建立語料庫","text":"我們的目標是建立一個 data frame 儲存文本資料。在這個 data frame 中，每一個 row 代表一篇文章，每個變項 (column) 記錄著該篇文章的某個資訊。根據文本資料的來源，該 data frame 可能會有不同數量的變項，例如，「文章發表日期」、「作者」、「標題」、「主題」等。但最重要的是，此 data frame 至少需具備兩個變項 — 「文章 id」與「(斷完詞的) 文章內文」。下方使用一個簡單的例子 (3 篇文章) 說明如何建立這種 data frame。第一步是將 docs 內的各篇文章 (character vector)\n進行斷詞，並在斷完詞後，將文章的內容存入另一個等長的 character vector 中。同篇文章中，被斷開的詞之間以一個全形空白字元分隔:\n\nlibrary(jiebaR)\n\n# Data: 3 篇文章\ndocs <- c(\n  \"蝴蝶和蜜蜂們帶著花朵的蜜糖回來了，羊隊和牛群告別了田野回家了，火紅的太陽也滾著火輪子回家了，當街燈亮起來向村莊道過晚安，夏天的夜就輕輕地來了。\",\n  \"朋友買了一件衣料，綠色的底子帶白色方格，當她拿給我們看時，一位對圍棋十分感與趣的同學說：「啊，好像棋盤似的。」「我看倒有點像稿紙。」我說。「真像一塊塊綠豆糕。」一位外號叫「大食客」的同學緊接著說。\",\n  \"每天，天剛亮時，我母親便把我喊醒，叫我披衣坐起。我從不知道她醒來坐了多久了。她看我清醒了，便對我說昨天我做錯了什麼事，說錯了什麼話，要我認錯，要我用功讀書。\"\n  )\n\n# Initialize jiebaR\nseg <- worker()\n\ndocs_segged <- vector(\"character\", length = length(docs))\n(seq_along(docs)) {\n  # Segment element docs\n  segged <- segment(docs[], seg)\n\n  # Collapse character vector string, separated space\n  docs_segged[] <- paste0(segged, collapse = \"\\u3000\")\n}\n\ndocs_segged\n#> [1] \"蝴蝶　和　蜜蜂　們　帶　著　花朵　的　蜜糖　回來　了　羊隊　和　牛群　告別　了　田野　回家　了　火紅　的　太陽　也　滾　著火　輪子　回家　了　當　街燈　亮　起來　向　村莊　道過　晚安　夏天　的　夜　就　輕輕地　來　了\"                                      \n#> [2] \"朋友　買　了　一件　衣料　綠色　的　底子　帶　白色　方格　當　她　拿給　我們　看時　一位　對　圍棋　十分　感與趣　的　同　學說　啊　好像　棋盤　似的　我　看　倒　有點像　稿紙　我　說　真　像　一塊塊　綠豆糕　一位　外號　叫　大　食客　的　同學　緊接著　說\"\n#> [3] \"每天　天剛亮　時　我　母親　便　把　我　喊醒　叫　我　披衣　坐起　我　從不　知道　她　醒來　坐　了　多久　了　她　看　我　清醒　了　便　對　我　說　昨天　我　做　錯　了　什麼　事　說錯　了　什麼　話　要　我　認錯　要　我　用功讀書\"第一步是將 docs 內的各篇文章 (character vector)\n進行斷詞，並在斷完詞後，將文章的內容存入另一個等長的 character vector 中。同篇文章中，被斷開的詞之間以一個全形空白字元分隔:如此，我們就能使用這個斷完詞的 docs_segged 製作 data frame:\n\ndocs_df <- tibble::tibble(\n  doc_id = seq_along(docs_segged),\n  content = docs_segged\n)\n\nknitr::kable(docs_df, align = \"c\")\ndoc_id\ncontent\n1\n蝴蝶　和　蜜蜂　們　帶　著　花朵　的　蜜糖　回來　了　羊隊　和　牛群　告別　了　田野　回家　了　火紅　的　太陽　也　滾　著火　輪子　回家　了　當　街燈　亮　起來　向　村莊　道過　晚安　夏天　的　夜　就　輕輕地　來　了\n2\n朋友　買　了　一件　衣料　綠色　的　底子　帶　白色　方格　當　她　拿給　我們　看時　一位　對　圍棋　十分　感與趣　的　同　學說　啊　好像　棋盤　似的　我　看　倒　有點像　稿紙　我　說　真　像　一塊塊　綠豆糕　一位　外號　叫　大　食客　的　同學　緊接著　說\n3\n每天　天剛亮　時　我　母親　便　把　我　喊醒　叫　我　披衣　坐起　我　從不　知道　她　醒來　坐　了　多久　了　她　看　我　清醒　了　便　對　我　說　昨天　我　做　錯　了　什麼　事　說錯　了　什麼　話　要　我　認錯　要　我　用功讀書\n如此，我們就能使用這個斷完詞的 docs_segged 製作 data frame:","code":"\nlibrary(jiebaR)\n\n# Data: 3 篇文章\ndocs <- c(\n  \"蝴蝶和蜜蜂們帶著花朵的蜜糖回來了，羊隊和牛群告別了田野回家了，火紅的太陽也滾著火輪子回家了，當街燈亮起來向村莊道過晚安，夏天的夜就輕輕地來了。\",\n  \"朋友買了一件衣料，綠色的底子帶白色方格，當她拿給我們看時，一位對圍棋十分感與趣的同學說：「啊，好像棋盤似的。」「我看倒有點像稿紙。」我說。「真像一塊塊綠豆糕。」一位外號叫「大食客」的同學緊接著說。\",\n  \"每天，天剛亮時，我母親便把我喊醒，叫我披衣坐起。我從不知道她醒來坐了多久了。她看我清醒了，便對我說昨天我做錯了什麼事，說錯了什麼話，要我認錯，要我用功讀書。\"\n  )\n\n# Initialize jiebaR\nseg <- worker()\n\ndocs_segged <- vector(\"character\", length = length(docs))\nfor (i in seq_along(docs)) {\n  # Segment each element in docs\n  segged <- segment(docs[i], seg)\n\n  # Collapse the character vector into a string, separated by space\n  docs_segged[i] <- paste0(segged, collapse = \"\\u3000\")\n}\n\ndocs_segged#> [1] \"蝴蝶　和　蜜蜂　們　帶　著　花朵　的　蜜糖　回來　了　羊隊　和　牛群　告別　了　田野　回家　了　火紅　的　太陽　也　滾　著火　輪子　回家　了　當　街燈　亮　起來　向　村莊　道過　晚安　夏天　的　夜　就　輕輕地　來　了\"                                      \n#> [2] \"朋友　買　了　一件　衣料　綠色　的　底子　帶　白色　方格　當　她　拿給　我們　看時　一位　對　圍棋　十分　感與趣　的　同　學說　啊　好像　棋盤　似的　我　看　倒　有點像　稿紙　我　說　真　像　一塊塊　綠豆糕　一位　外號　叫　大　食客　的　同學　緊接著　說\"\n#> [3] \"每天　天剛亮　時　我　母親　便　把　我　喊醒　叫　我　披衣　坐起　我　從不　知道　她　醒來　坐　了　多久　了　她　看　我　清醒　了　便　對　我　說　昨天　我　做　錯　了　什麼　事　說錯　了　什麼　話　要　我　認錯　要　我　用功讀書\"\ndocs_df <- tibble::tibble(\n  doc_id = seq_along(docs_segged),\n  content = docs_segged\n)\n\nknitr::kable(docs_df, align = \"c\")"},{"path":"ch08.html","id":"tidytext-framework","chapter":"8 中文文本資料處理","heading":"8.3 tidytext framework","text":"tidytext 套件是 R 生態圈中比較近期的 text mining 套件，它將 tidyverse 的想法運用到文本資料處理上，換言之，就是使用 data frame 的資料結構去表徵和處理文本資料。tidytext 套件是 R 生態圈中比較近期的 text mining 套件，它將 tidyverse 的想法運用到文本資料處理上，換言之，就是使用 data frame 的資料結構去表徵和處理文本資料。使用 tidytext 的方法處理文本資料有好有壞。\n好處是使用者能輕易地結合 dplyr 與 ggplot2 於文本分析中，因而能快速地視覺化文本資料。\n壞處是，在 tidytext framework 之下，文章的內部 (.e. 詞彙與詞彙之間的) 結構會消失，因為它對於文本的想法是 bag--words。\ntidytext 所倡導的儲存文本資料的格式是 one-token-per-document-per-row，亦即，在一個 data frame 中，每一橫列 (row) 是一篇文章中的一個 token。因此，若有兩篇文章，第一篇被斷成 38 個詞彙，第二篇被斷成 20 個詞彙，則共需要一個 58 列 (row) 的 data frame 來儲存這兩篇文章。\n使用 tidytext 的方法處理文本資料有好有壞。好處是使用者能輕易地結合 dplyr 與 ggplot2 於文本分析中，因而能快速地視覺化文本資料。好處是使用者能輕易地結合 dplyr 與 ggplot2 於文本分析中，因而能快速地視覺化文本資料。壞處是，在 tidytext framework 之下，文章的內部 (.e. 詞彙與詞彙之間的) 結構會消失，因為它對於文本的想法是 bag--words。\ntidytext 所倡導的儲存文本資料的格式是 one-token-per-document-per-row，亦即，在一個 data frame 中，每一橫列 (row) 是一篇文章中的一個 token。因此，若有兩篇文章，第一篇被斷成 38 個詞彙，第二篇被斷成 20 個詞彙，則共需要一個 58 列 (row) 的 data frame 來儲存這兩篇文章。壞處是，在 tidytext framework 之下，文章的內部 (.e. 詞彙與詞彙之間的) 結構會消失，因為它對於文本的想法是 bag--words。tidytext 所倡導的儲存文本資料的格式是 one-token-per-document-per-row，亦即，在一個 data frame 中，每一橫列 (row) 是一篇文章中的一個 token。因此，若有兩篇文章，第一篇被斷成 38 個詞彙，第二篇被斷成 20 個詞彙，則共需要一個 58 列 (row) 的 data frame 來儲存這兩篇文章。一般而言，tidytext 的架構適合用於與詞頻有關的分析，例如，計算文章的 lexical diversity 或是透過情緒詞的詞頻進行情緒分析。一般而言，tidytext 的架構適合用於與詞頻有關的分析，例如，計算文章的 lexical diversity 或是透過情緒詞的詞頻進行情緒分析。透過 tidytext::unnest_tokens()，可以將 docs_df 中儲存之 (已斷詞) 文本資料，變成 tidytext format，.e.，one-token-per-document-per-row 的 data frame:\n\nlibrary(tidytext)\nlibrary(dplyr)\n\ntidy_text_format <- docs_df %>%\n  unnest_tokens(output = \"word\", input = \"content\",\n                token = \"regex\", pattern = \"\\u3000\")  # 以空白字元作為 token 分隔依據\n\ntidy_text_format\n#> # tibble: 139 x 2\n#>    doc_id word \n#>     <int> <chr>\n#>  1      1 蝴蝶 \n#>  2      1 和   \n#>  3      1 蜜蜂 \n#>  4      1 們   \n#>  5      1 帶   \n#>  6      1 著   \n#>  7      1 花朵 \n#>  8      1 的   \n#>  9      1 蜜糖 \n#> 10      1 回來 \n#> # … 129 rows透過 tidytext::unnest_tokens()，可以將 docs_df 中儲存之 (已斷詞) 文本資料，變成 tidytext format，.e.，one-token-per-document-per-row 的 data frame:","code":"\nlibrary(tidytext)\nlibrary(dplyr)\n\ntidy_text_format <- docs_df %>%\n  unnest_tokens(output = \"word\", input = \"content\",\n                token = \"regex\", pattern = \"\\u3000\")  # 以空白字元作為 token 分隔依據\n\ntidy_text_format#> # A tibble: 139 x 2\n#>    doc_id word \n#>     <int> <chr>\n#>  1      1 蝴蝶 \n#>  2      1 和   \n#>  3      1 蜜蜂 \n#>  4      1 們   \n#>  5      1 帶   \n#>  6      1 著   \n#>  7      1 花朵 \n#>  8      1 的   \n#>  9      1 蜜糖 \n#> 10      1 回來 \n#> # … with 129 more rows"},{"path":"ch08.html","id":"詞頻表","chapter":"8 中文文本資料處理","heading":"8.3.1 詞頻表","text":"可以使用 dplyr 的 group_by() 與 summarise() 計算詞頻表：\n\ntidy_text_format %>%\n  group_by(word) %>%\n  summarise(n = n()) %>%\n  arrange(desc(n))\n#> # tibble: 99 x 2\n#>    word      n\n#>    <chr> <int>\n#>  1 了       11\n#>  2 我       11\n#>  3 的        6\n#>  4 她        3\n#>  5 說        3\n#>  6 一位      2\n#>  7 什麼      2\n#>  8 便        2\n#>  9 叫        2\n#> 10 和        2\n#> # … 89 rows\n\n# Equivalent ...\ntidy_text_format %>%\n  count(word) %>%\n  arrange(desc(n))\n#> # tibble: 99 x 2\n#>    word      n\n#>    <chr> <int>\n#>  1 了       11\n#>  2 我       11\n#>  3 的        6\n#>  4 她        3\n#>  5 說        3\n#>  6 一位      2\n#>  7 什麼      2\n#>  8 便        2\n#>  9 叫        2\n#> 10 和        2\n#> # … 89 rows可以使用 dplyr 的 group_by() 與 summarise() 計算詞頻表：","code":"\ntidy_text_format %>%\n  group_by(word) %>%\n  summarise(n = n()) %>%\n  arrange(desc(n))#> # A tibble: 99 x 2\n#>    word      n\n#>    <chr> <int>\n#>  1 了       11\n#>  2 我       11\n#>  3 的        6\n#>  4 她        3\n#>  5 說        3\n#>  6 一位      2\n#>  7 什麼      2\n#>  8 便        2\n#>  9 叫        2\n#> 10 和        2\n#> # … with 89 more rows\n# Equivalent to ...\ntidy_text_format %>%\n  count(word) %>%\n  arrange(desc(n))#> # A tibble: 99 x 2\n#>    word      n\n#>    <chr> <int>\n#>  1 了       11\n#>  2 我       11\n#>  3 的        6\n#>  4 她        3\n#>  5 說        3\n#>  6 一位      2\n#>  7 什麼      2\n#>  8 便        2\n#>  9 叫        2\n#> 10 和        2\n#> # … with 89 more rows"},{"path":"ch08.html","id":"視覺化","chapter":"8 中文文本資料處理","heading":"8.3.2 視覺化","text":"","code":"\nlibrary(ggplot2)\ntidy_text_format %>%\n  count(word) %>%\n  mutate(word = reorder(word, n)) %>%   # 依照 n 排序文字\n  top_n(10, n) %>%                      # 取 n 排名前 10 者\n  ggplot() +\n    geom_bar(aes(word, n), stat = \"identity\") +\n    coord_flip()"},{"path":"ch08.html","id":"quanteda-framework","chapter":"8 中文文本資料處理","heading":"8.4 quanteda framework","text":"傳統 R 的 text mining 生態圈中，使用的是另一種 (高階) 資料結構儲存文本資料 — 語料庫 (corpus)。不同的套件有自己定義 corpus 的方式，且各自進行文本分析的流程與想法差異頗大。目前最流行、支援最多的兩個套件是 quanteda 與 tm。其中，quanteda 在中文支援以及說明與教學文件的完整度較高。下方為 quanteda 套件的一些使用範例。欲比較完整地了解 quanteda，請閱讀 quanteda tutorials。使用 quanteda 的好處在於它保留了文章的內部結構，例如，可以透過 quanteda::kwic() 去檢視特定詞彙或是片語出現的語境。與此同時，quanteda 也提供許多 bag--words 想法之下的函數。但 quanteda 的缺點在於其內容龐雜，需要一些語料庫語言學的背景知識以及相當的時間摸索才能掌握。Key Word Context\n\n# tokenize corpus \nq_tokens <- tokenizers::tokenize_regex(quanteda_corpus, \"\\u3000\") %>%\n  tokens()\n\nkwic(q_tokens, \"我\", window = 5, valuetype = \"regex\") %>%\n  knitr::kable(align = \"c\")\ndocname\n\n\npre\nkeyword\npost\npattern\n2\n15\n15\n白色 方格 當 她 拿給\n我們\n看時 一位 對 圍棋 十分\n我\n2\n29\n29\n學說 啊 好像 棋盤 似的\n我\n看 倒 有點像 稿紙 我\n我\n2\n34\n34\n我 看 倒 有點像 稿紙\n我\n說 真 像 一塊塊 綠豆糕\n我\n3\n4\n4\n每天 天剛亮 時\n我\n母親 便 把 我 喊醒\n我\n3\n8\n8\n時 我 母親 便 把\n我\n喊醒 叫 我 披衣 坐起\n我\n3\n11\n11\n便 把 我 喊醒 叫\n我\n披衣 坐起 我 從不 知道\n我\n3\n14\n14\n喊醒 叫 我 披衣 坐起\n我\n從不 知道 她 醒來 坐\n我\n3\n25\n25\n了 多久 了 她 看\n我\n清醒 了 便 對 我\n我\n3\n30\n30\n我 清醒 了 便 對\n我\n說 昨天 我 做 錯\n我\n3\n33\n33\n便 對 我 說 昨天\n我\n做 錯 了 什麼 事\n我\n3\n44\n44\n說錯 了 什麼 話 要\n我\n認錯 要 我 用功讀書\n我\n3\n47\n47\n話 要 我 認錯 要\n我\n用功讀書\n我\nKey Word Context","code":"\nlibrary(quanteda)\n\n# 將 data frame 轉換成 Corpus object\nquanteda_corpus <- corpus(docs_df, \n                          docid_field = \"doc_id\", \n                          text_field = \"content\")\n# tokenize the corpus \nq_tokens <- tokenizers::tokenize_regex(quanteda_corpus, \"\\u3000\") %>%\n  tokens()\n\nkwic(q_tokens, \"我\", window = 5, valuetype = \"regex\") %>%\n  knitr::kable(align = \"c\")"},{"path":"ch09.html","id":"ch09","chapter":"9 文本與詞彙的向量表徵","heading":"9 文本與詞彙的向量表徵","text":"(投影片 /\n程式碼 /\n影片)","code":""},{"path":"ch09.html","id":"representing-documents","chapter":"9 文本與詞彙的向量表徵","heading":"9.1 Representing Documents","text":"由於資料科學以及統計學方法上的限制，要對文本進行量化分析之前，常常需要將原本以符碼 (文字) 去表徵的文本轉換成數值的表徵，如此我們才有辦法對文本去進行一些資料科學中常見的分析，例如相似度計算、分群、分類等。","code":""},{"path":"ch09.html","id":"document-term-matrix-a-toy-example","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.1 Document-Term Matrix: A Toy Example","text":"將文本轉換成數值的表徵方式相當多，其中一種最簡單的方式，即是使用 document-term matrix 將文本以數值向量去表徵。document-term matrix 裡面記錄著各個文本中的各種詞彙出現的次數。以這 3 篇文本為例：doc1: baked cake muffindoc2: loved cakedoc3: wrote book我們可以使用下方的矩陣 dtm 去表示這 3 篇文本。在這個矩陣中，每個 row 即是一篇文本的向量表徵 (由上至下依序為 doc1, doc2, doc3)；每個 column 是某個特定的詞彙；矩陣中的數值則是該種詞彙出現在該篇文本的次數，例如 cell (2, 1) 代表 這個詞彙在 doc2 中出現了 1 次。有了文本的向量表徵之後，我們就能去量化比較文本之間的相似度，方法是直接利用向量之間的距離公式 \\(d(\\overrightarrow{p}, \\overrightarrow{q})\\) 以及相似度公式 \\(cos(\\theta)\\)：\\[\nd(\\overrightarrow{p}, \\overrightarrow{q}) = \\sqrt{ (p_1 - q_1)^2 + (p_2 - q_2)^2 + ... + (p_n - q_n)^2 }\n\\]\\[\ncos(\\theta) = \\frac{\\overrightarrow{p} \\cdot \\overrightarrow{q}}{\\lVert p \\rVert \\lVert q \\rVert }\n\\]為了避免每篇文本長度不同造成的文本向量長度不同，在使用距離公式時，我們通常會多一個將向量常規化的動作，讓兩個文本向量的長度變得一樣 (.e., 皆變成單位向量)","code":"\n#' doc1:    \"I baked the cake and the muffin\"\n#' doc2:    \"I loved the cake\"\n#' doc3:    \"I wrote the book\"\n#' TERMS:        I  baked loved wrote the and cake muffin book\ndtm <- matrix(c( 1,   1,    0,    0,   2,  1,   1,    1,   0 ,\n                 1,   0,    1,    0,   1,  0,   1,    0,   0 , \n                 1,   0,    0,    1,   1,  0,   0,    0,   1 ), \n              nrow = 3, ncol = 9, byrow = TRUE)\ndtm#>      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n#> [1,]    1    1    0    0    2    1    1    1    0\n#> [2,]    1    0    1    0    1    0    1    0    0\n#> [3,]    1    0    0    1    1    0    0    0    1\n#### Distance / Similarity Measures ####\ncossim <- function(x1, x2)\n  sum(x1 * x2) / sqrt( sum(x1^2) * sum(x2^2) )\n\neudist <- function(x1, x2) \n  sqrt( sum( (as_unit_vec(x1) - as_unit_vec(x2))^2 ) )\n\nas_unit_vec <- function(x) x / sqrt(sum(x^2))  # Normalize vector length\neudist(dtm[1, ], dtm[2, ])\neudist(dtm[1, ], dtm[3, ])\neudist(dtm[2, ], dtm[3, ])#> [1] 0.8164966\n#> [1] 1\n#> [1] 1\ncossim(dtm[1, ], dtm[2, ])\ncossim(dtm[1, ], dtm[3, ])\ncossim(dtm[2, ], dtm[3, ])#> [1] 0.6666667\n#> [1] 0.5\n#> [1] 0.5"},{"path":"ch09.html","id":"creating-document-term-matrix-with-quanteda","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.2 Creating Document-Term Matrix with quanteda","text":"在上方的例子，我們是自己透過手刻的方式去製作 document-term matrix。quanteda 則提供了將 tokens object 轉換成 document-term matrix 的函數：","code":"\nlibrary(dplyr)\nlibrary(quanteda)\nlibrary(quanteda.textstats)\nlibrary(quanteda.textmodels)\n\n# Document data frame\ndocs_df <- readRDS(\"samesex_marriage.rds\")\n\n# Token object\nq_tokens <- corpus(docs_df, docid_field = \"id\", text_field = \"content\") %>%\n  tokenizers::tokenize_regex(pattern = \"\\u3000\") %>%\n  tokens()\n\n# Document-term matrix (feature selection)\nq_dfm <- dfm(q_tokens) %>% \n  dfm_remove(pattern = readLines(\"stopwords.txt\"), valuetype = \"fixed\") %>%\n  dfm_select(pattern = \"[\\u4E00-\\u9FFF]\", valuetype = \"regex\") %>%\n  dfm_trim(min_termfreq = 5) %>%\n  dfm_tfidf()\nq_dfm#> Document-feature matrix of: 300 documents, 4,781 features (95.54% sparse) and 0 docvars.\n#>               features\n#> docs               去年   全國性      是否      同意     民法      婚姻\n#>   anti_1.txt   1.457866 1.273001 0.4240428 3.2552323 4.300816 1.6543448\n#>   anti_10.txt  0        0        0         0         0        0        \n#>   anti_100.txt 0        0        2.1202141 0.6510465 0        2.7572413\n#>   anti_101.txt 0        0        0.4240428 0         0        0        \n#>   anti_102.txt 0        0        0.4240428 1.9531394 1.075204 0.5514483\n#>   anti_103.txt 0        0        0         0         0        0        \n#>               features\n#> docs                規定        應     限定  一男一女\n#>   anti_1.txt   3.9804537 1.4183996 4.704365 3.7921393\n#>   anti_10.txt  0         0         0        0        \n#>   anti_100.txt 0         0.9455998 0        0.6320232\n#>   anti_101.txt 0         0         0        0        \n#>   anti_102.txt 0.5686362 0.4727999 0        0        \n#>   anti_103.txt 0         1.8911995 0        0        \n#> [ reached max_ndoc ... 294 more documents, reached max_nfeat ... 4,771 more features ]"},{"path":"ch09.html","id":"pairwise-document-similarity-by-raw-document-term-matrix","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.3 Pairwise Document Similarity by raw Document-Term Matrix","text":"quanteda.textstats::textstat_simil() 能夠計算 document-term matrix 內文本間的兩兩相似度。如此我們便可透過回傳的矩陣去取得與某篇文章 (e.g., anti_1.txt) 最相似的幾篇文章：","code":"\ndoc_sim <- textstat_simil(q_dfm, method = \"cosine\") %>% as.matrix()\ndim(doc_sim)#> [1] 300 300\nsort(doc_sim[\"anti_1.txt\", ], decreasing = T)[1:8]#>   anti_1.txt  anti_95.txt anti_122.txt   pro_18.txt  anti_54.txt  anti_55.txt \n#>    1.0000000    0.3846162    0.2652598    0.2584759    0.2577859    0.2548753 \n#> anti_132.txt anti_106.txt \n#>    0.2422925    0.2371465"},{"path":"ch09.html","id":"clustering-using-pairwise-similarity","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.3.1 Clustering Using Pairwise Similarity","text":"quanteda.textstats::textstat_simil() 所回傳的相似度矩陣也可作為分群演算法的輸入：","code":"\ndoc_name <- function(name, end = 8) \n  paste0(name, '\\n', substr(lookup[name], 1, end))\n\nidx <- c(1:10, 151:160)\nlookup <- docs_df$title\nnames(lookup) <- docs_df$id\n\ndoc_sim2 <- doc_sim[idx, idx]\nrow.names(doc_sim2) <- doc_name(row.names(doc_sim2))\ncolnames(doc_sim2) <- doc_name(colnames(doc_sim2))\n\n## create hclust\nclust <- (1 - doc_sim2) %>% as.dist %>% hclust\n\n## plot dendrogram\nplot(clust, main = \"20 Selected Posts\", cex = 0.7,\n     xlab=\"\", sub=\"\")"},{"path":"ch09.html","id":"network-plot-using-pairwise-similarity","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.3.2 Network Plot Using Pairwise Similarity","text":"","code":"\nlibrary(quanteda.textplots)\nset.seed(10)\ntextplot_network(as.dfm(doc_sim2),\n                 vertex_labelsize = 2)"},{"path":"ch09.html","id":"latent-semantic-anlysis-dimensionality-reduction","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.4 Latent Semantic Anlysis (Dimensionality Reduction)","text":"由於 document-term matrix 通常很稀疏 (.e., 很多值是 0)，使文本向量可能無法抓到某些文本之間的語意關聯。例如，在下圖的例子中，doc2 與 doc4 雖然語意相近，但此二文本的向量的相似度 (cosine similarity) 為零，因為這兩篇文本並未使用到相同的詞彙。面對這種情形，我們可以將高維的 document-term matrix 透過數學方式轉換成維度比較小的矩陣。在這個過程中，document-term matrix 中一些語意相近的詞彙會被壓縮到某個或是某些維度中，讓這個維度比較小的矩陣反而比較能表徵文本之間的語意關聯。這種方式稱為 Latent Semantic Analysis (LSA)，而用來將矩陣分解降維的數學方法稱為 Singular Value Decomposition (SVD)。","code":"\nlsa_model <- quanteda.textmodels::textmodel_lsa(q_dfm, nd = 15)\ndim(lsa_model$docs)#> [1] 300  15\n# Document similarity\ndoc_sim2 <- textstat_simil(as.dfm(lsa_model$docs), method = \"cosine\")\nsort(doc_sim2[\"anti_1.txt\", ], decreasing = T)[1:8]#>   anti_1.txt    pro_2.txt anti_102.txt anti_146.txt   pro_94.txt   pro_84.txt \n#>    1.0000000    0.9963039    0.9959590    0.9936474    0.9933724    0.9933206 \n#>  anti_94.txt  pro_133.txt \n#>    0.9923490    0.9921601"},{"path":"ch09.html","id":"converting-unseen-documents-to-vectors","chapter":"9 文本與詞彙的向量表徵","heading":"9.1.5 Converting unseen documents to vectors","text":"現在我們已經知道如何將一個語料庫內的所有文本轉換成向量表徵。現在要處理的是新的資料：若今天有一篇新的文本，我們要如何將此篇文本轉換成向量，好讓我們可以去將這篇文本與語料庫中的其它文本進行比較？要達成這件事，在將新文本轉換成 document-term matrix 時，需要讓新文本的 document-term matrix 在維度上 (詞彙種類以及其在矩陣中順序) 能夠與語料庫的 document-term matrix 對應起來。這可以透過 quanteda::dfm_match() 達成。確保了 document-term matrix 的維度相同之後，接著就可以將這個 document-term matrix 餵到 LSA 模型，讓它為這個 document-term matrix 進行降維，進而得到新文本的向量表徵：如此，我們便可使用這個新文本的向量去和語料庫中的其它文本進行比較：","code":"\n#### Converting new texts to vector representation ####\n\n# New document\ndoc <- readLines(\"sample_post.txt\") %>% \n  paste(collapse = \"\\n\")\n\n# Convert raw text to document term matrix\nlibrary(jiebaR)\nseg <- worker(user = \"user_dict.txt\")\nnew_doc_dtm <- list(segment(doc, seg)) %>%\n  tokens() %>%\n  dfm() %>%\n  dfm_match(features = featnames(q_dfm))\n\n# Dimensionality reduction with LSA\np <- predict(lsa_model, newdata = new_doc_dtm)\ndoc_vec_lsa <- p$docs_newspace[1, ]\ndoc_vec_lsa#>  [1]  0.010827972 -0.005043434  0.019064686  0.021167702 -0.012646628\n#>  [6]  0.017416307  0.030359762  0.024489521 -0.010629365 -0.005384180\n#> [11] -0.033654985  0.005100957 -0.015062376 -0.007130964  0.001976622\ncossim(doc_vec_lsa, lsa_model$docs[\"pro_18.txt\", ])\ncossim(doc_vec_lsa, lsa_model$docs[\"anti_18.txt\", ])#> [1] 0.7625148\n#> [1] -0.1026607"},{"path":"ch09.html","id":"using-word-vectors","chapter":"9 文本與詞彙的向量表徵","heading":"9.2 Using Word Vectors","text":"詞彙與文本類似，一樣可以透過數值性的向量去表徵。在近幾年表徵詞彙的詞向量技術進展相當快速，且能抓到一些相當細微的語意。但這些詞向量通常需要透過相對大量的資料訓練，其表現才會相對穩定。通常我們也不必自行蒐集語料訓練這些詞向量，因為網路上已有相當多公開的詞向量資源，可直接下載使用。下方的例子即是使用預先訓練好的詞向量 (儲存於 ppmi_embeddings_50dim.txt)。這份詞向量23是透過中研院平衡語料庫訓練而來的，可以透過 functions.R 中的 read_ppmi() 以 matrix 的格式讀進 R 裡：讀進來後，就可以透過 wv[\"{詞彙}\", ] 去取得詞向量 (length == 50 的 numeric vector)：並可以套用 cosine similarity 的公式去計算兩個詞彙間的相似度：","code":"\nsource(\"functions.R\")\nwv <- read_ppmi(\"ppmi_embeddings_50dim.txt\")\nwv[\"爸爸\", ]#>  [1] -0.046565545  0.460913664 -0.053094442 -0.057553476 -0.024442142\n#>  [6]  0.001117499 -0.179143899 -0.213770824 -0.087744568  0.044913735\n#> [11] -0.011217009  0.081547154  0.127092145  0.067408753  0.036906909\n#> [16]  0.085890520  0.102822128 -0.199562705  0.040325577  0.150103819\n#> [21]  0.232702185  0.007350324  0.131141177  0.146634070 -0.049885084\n#> [26] -0.192042121  0.027501879 -0.238921004  0.113918191  0.001545429\n#> [31] -0.027848669 -0.098988912 -0.079275493  0.074673585  0.113090980\n#> [36]  0.222950818  0.096059215 -0.089295350 -0.157370032 -0.089475721\n#> [41]  0.025158373  0.236198917 -0.023956936  0.169465113  0.228609064\n#> [46]  0.038412816  0.037344191  0.184070583  0.224648376 -0.131128332\ncossim(wv[\"媽媽\", ], wv[\"爸爸\", ])\ncossim(wv[\"老師\", ], wv[\"爸爸\", ])#> [1] 0.9721566\n#> [1] 0.3958473"},{"path":"ch09.html","id":"finding-most-similar-words","chapter":"9 文本與詞彙的向量表徵","heading":"9.2.1 Finding Most Similar Words","text":"由於詞向量的檔案通常非常大 (因為詞彙的種類通常遠比文本的數量多很多)，我們無法透過 quanteda.textstats::textstat_simil() 去計算詞彙間的兩兩相似度 (運算時間太長)。因此，若想找出與某個特定詞彙 (e.g., 媽媽) 語意最相似的詞彙，我們可以透過 base R 的 apply() 去將 媽媽 的詞向量去跟所有的詞向量算出相似度之後再進行排序：","code":"\nmost_simil <- function(word_vec, topn = 10) {\n  siml <- apply(wv, 1, function(row) cossim(row, word_vec))\n  return(sort(siml, decreasing = T)[1:topn])\n}\n\nmost_simil(wv[\"媽媽\", ])#>      媽媽      爸爸      妹妹      哥哥      小孩      高興      弟弟      孩子 \n#> 1.0000000 0.9721566 0.8704723 0.8639341 0.8603998 0.8585911 0.8536466 0.8528005 \n#>      回家      回來 \n#> 0.8485474 0.8395401"},{"path":"ch09.html","id":"word-analogy","chapter":"9 文本與詞彙的向量表徵","heading":"9.2.2 Word Analogy","text":"近幾年的詞向量技術令人驚奇的其中一個地方來自它們抓到詞彙語意上類比關係的能力。透過詞向量的運算，我們可以要電腦為我們找出類似這種問題的答案：父親之於兒子相當於母親之於？弟弟之於哥哥相當於妹妹之於？","code":"父親 : 兒子 == 母親 :  ？\n弟弟 : 哥哥 == 妹妹 :  ？\nv1  -  v2   =  v3  -  v4\nv4  =  v3   -  v1  +  v2\nv1 <- wv[\"父親\", ]\nv2 <- wv[\"兒子\", ]\nv3 <- wv[\"母親\", ]\nv4 <- v3 - v1 + v2\nmost_simil(v4)#>      兒子      母親      女兒      小孩      父母      父親      孩子      丈夫 \n#> 0.9487272 0.9425165 0.9305924 0.8863384 0.8806144 0.8620591 0.8385362 0.8338454 \n#>      長大      媽媽 \n#> 0.8174763 0.8096411\nv1 <- wv[\"弟弟\", ]\nv2 <- wv[\"哥哥\", ]\nv3 <- wv[\"妹妹\", ]\nv4 <- v3 - v1 + v2\nmost_simil(v4)#>      哥哥      妹妹      爸爸      弟弟      回去      姊姊      媽媽      回家 \n#> 0.9663716 0.9476825 0.8894544 0.8650535 0.8603728 0.8535357 0.8396181 0.8242290 \n#>      高興      回來 \n#> 0.8238468 0.8150439"},{"path":"ch10.html","id":"ch10","chapter":"10 擷取網路資料：Web API","heading":"10 擷取網路資料：Web API","text":"(投影片 /\n程式碼)\n","code":""},{"path":"ch10.html","id":"http","chapter":"10 擷取網路資料：Web API","heading":"10.1 HTTP","text":"HTTP 是網路上，電腦與電腦 (伺服器) 之間進行溝通時，所遵循的一套規則。當你在瀏覽器當中輸入一個網址 (URL) 時，你的瀏覽器會幫你向位於該 URL 的伺服器發出一個 HTTP request。伺服器收到這個 HTTP request 之後，會解讀它，並依據解讀的結果，向你的電腦送出 HTTP response。若一切正常運作，HTTP response 應會包含你想要的內容 (e.g. 某個網頁)。你的瀏覽器在接收到 HTTP response 之後，會解讀它並將其所包含的內容 (e.g. HTML) (經處理後) 呈現在螢幕上。\nFigure 10.1: Hypertext Transfer Protocol (HTTP)\n通常，我們輸入網址後所收到的內容是 HTML 格式，因此我們在瀏覽器解讀 HTML 後，會在螢幕呈現出一個 (漂亮的) 網頁。但不一定所有網址都會回傳 HTML 的格式，有時候會是其它格式，例如 JSON 格式 (https://api.ratesapi.io/api/latest) 或是 text/plain (https://rlads2019.github.io/hw8/idioms.txt)。這時，瀏覽器上就會呈現出純文字的樣子:\nFigure 10.2: JSON shown Browser\n伺服器回傳 JSON 格式不是為了 (直接) 給人看的，而是為了方便程式與電腦處理。換言之，位在這個 URL 的伺服器希望使用者透過程式與自己互動，因此它不提供一個漂亮的界面 (.e. 網頁)，而是提供一個 Web API，讓使用者可以透過程式語言直接取得乾淨、結構化的資料。","code":""},{"path":"ch10.html","id":"url-structure","chapter":"10 擷取網路資料：Web API","heading":"10.2 URL 結構","text":"Web API 的設計常是透過讓使用者在 URL 加上一些訊息 (query string)，藉此得知使用者想取得哪些資料。\n例如，Foreign exchange rates API 透過使用者在 URL 之後加上的 base=<貨幣>，判斷回傳的資料以何種貨幣作為匯率計算的基準: https://api.ratesapi.io/api/latest?base=USD\n例如，Foreign exchange rates API 透過使用者在 URL 之後加上的 base=<貨幣>，判斷回傳的資料以何種貨幣作為匯率計算的基準: https://api.ratesapi.io/api/latest?base=USDURL 當中的 query string 具有一些特殊的結構。query string 讓使用者可以提供一或多個 key-value pairs (需看 API 說明文件)。例如，上方例子中的 base 即為 key-value pairs 中的 key，在 key 與 value 之間則用 = 分隔。詳見下圖的 URL 結構。\nFigure 10.3: URL 結構\n","code":""},{"path":"ch10.html","id":"httr","chapter":"10 擷取網路資料：Web API","heading":"10.3 httr","text":"\nFigure 10.4: HTTP R\n我們通常是透過瀏覽器與網路上的其它電腦 (伺服器) 互動 (.e. 透過瀏覽器發出/接收 HTTP request/response)。但我們也可以透過 R 做到這件事 — 套件 httr 即提供一些函數方便在 R 裡面處理 HTTP request/response。我們通常是透過瀏覽器與網路上的其它電腦 (伺服器) 互動 (.e. 透過瀏覽器發出/接收 HTTP request/response)。但我們也可以透過 R 做到這件事 — 套件 httr 即提供一些函數方便在 R 裡面處理 HTTP request/response。下方，我們使用 httr::GET() 向 https://api.ratesapi.io/api/latest?base=USD&symbols=JPY 發出 HTTP request，以取得最新的匯率資料:\n\nlibrary(httr)\nlibrary(magrittr)\n\n# https://api.ratesapi.io/api/latest?base=USD&symbols=JPY\nresp <- GET('https://api.ratesapi.io/',\n            path = 'api/latest',\n            query = list(base = \"USD\", symbols = \"JPY\"))\n雖然我們可以將整個 URL 以字串的形式寫在 httr::GET() 的第一個 argument，但我們通常會將 URL 拆開成 base URL, path 以及 query string 這三個部份 (見上 URL 結構)，再透過 httr::GET() 所提供的一些 argument 組出完整的 URL24:\n\nurl (first arg.): URL 中的 base URL，即上圖綠色部份 https://api.ratesapi.io/\npath: URL 中的 path，即上圖紫色部份 api/latest\nquery: URL 中的 query string。在 httr::GET() 中，query 是以 list 的資料結構提供。上方的 URL 因為有兩個 key-value pairs，所以 query 這個 argument 也由兩個元素 (皆有 name) 組成。\n\n下方，我們使用 httr::GET() 向 https://api.ratesapi.io/api/latest?base=USD&symbols=JPY 發出 HTTP request，以取得最新的匯率資料:雖然我們可以將整個 URL 以字串的形式寫在 httr::GET() 的第一個 argument，但我們通常會將 URL 拆開成 base URL, path 以及 query string 這三個部份 (見上 URL 結構)，再透過 httr::GET() 所提供的一些 argument 組出完整的 URL24:\n\nurl (first arg.): URL 中的 base URL，即上圖綠色部份 https://api.ratesapi.io/\npath: URL 中的 path，即上圖紫色部份 api/latest\nquery: URL 中的 query string。在 httr::GET() 中，query 是以 list 的資料結構提供。上方的 URL 因為有兩個 key-value pairs，所以 query 這個 argument 也由兩個元素 (皆有 name) 組成。\n雖然我們可以將整個 URL 以字串的形式寫在 httr::GET() 的第一個 argument，但我們通常會將 URL 拆開成 base URL, path 以及 query string 這三個部份 (見上 URL 結構)，再透過 httr::GET() 所提供的一些 argument 組出完整的 URL24:url (first arg.): URL 中的 base URL，即上圖綠色部份 https://api.ratesapi.io/path: URL 中的 path，即上圖紫色部份 api/latestquery: URL 中的 query string。在 httr::GET() 中，query 是以 list 的資料結構提供。上方的 URL 因為有兩個 key-value pairs，所以 query 這個 argument 也由兩個元素 (皆有 name) 組成。httr::GET() 會將 HTTP request 以及接收到的 HTTP response 轉換成 R 的物件。例如，resp$url 可以取得 HTTP request 目的地 URL，resp$status_code 則可以看到 request 是否成功 (2** 代表 request 成功，4** 代表失敗)：\n\nresp$url\n#> [1] \"https://api.ratesapi.io/api/latest?base=USD&symbols=JPY\"\n\nresp$status_code\n#> [1] 200httr::GET() 會將 HTTP request 以及接收到的 HTTP response 轉換成 R 的物件。例如，resp$url 可以取得 HTTP request 目的地 URL，resp$status_code 則可以看到 request 是否成功 (2** 代表 request 成功，4** 代表失敗)：若要取得 HTTP response 的內容，可使用 httr::content()。若 response 的內容格式是 JSON，XML 或 HTML，httr::content() 會自動將其轉換成 R 的物件，若不想自動進行這件事，可加入 = \"text\" 這個 argument：\n\ncontent(resp)\n#> $base\n#> [1] \"USD\"\n#> \n#> $rates\n#> $rates$JPY\n#> [1] 109.2881\n#> \n#> \n#> $date\n#> [1] \"2021-05-14\"\n\ncontent(resp, = \"text\") %>% cat()\n#> {\"base\":\"USD\",\"rates\":{\"JPY\":109.2881300008},\"date\":\"2021-05-14\"}若要取得 HTTP response 的內容，可使用 httr::content()。若 response 的內容格式是 JSON，XML 或 HTML，httr::content() 會自動將其轉換成 R 的物件，若不想自動進行這件事，可加入 = \"text\" 這個 argument：","code":"\nlibrary(httr)\nlibrary(magrittr)\n\n# https://api.ratesapi.io/api/latest?base=USD&symbols=JPY\nresp <- GET('https://api.ratesapi.io/',\n            path = 'api/latest',\n            query = list(base = \"USD\", symbols = \"JPY\"))\nresp$url#> [1] \"https://api.ratesapi.io/api/latest?base=USD&symbols=JPY\"\nresp$status_code#> [1] 200\ncontent(resp)#> $base\n#> [1] \"USD\"\n#> \n#> $rates\n#> $rates$JPY\n#> [1] 109.2881\n#> \n#> \n#> $date\n#> [1] \"2021-05-14\"\ncontent(resp, as = \"text\") %>% cat()#> {\"base\":\"USD\",\"rates\":{\"JPY\":109.2881300008},\"date\":\"2021-05-14\"}"},{"path":"ch10.html","id":"http-request-methods","chapter":"10 擷取網路資料：Web API","heading":"10.3.1 HTTP request methods","text":"HTTP request 有許多不同的「種類」，稱為 request methods。最常見的一種即是 GET method，例如在網頁輸入 URL 或是剛剛使用的 httr::GET()， 都是在向伺服器發出 GET request。GET request 的目的是向伺服器取得資料。另一種常見的 request method 是 POST。POST request 的目的是向伺服器提交資料，常見的例子是「帳號登入」與「填寫表單」。關於 HTTP request methods 可見 https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods。","code":""},{"path":"ch10.html","id":"json","chapter":"10 擷取網路資料：Web API","heading":"10.4 JSON","text":"JSON 是一種純文字格式，跟 .csv 一樣是用來記錄結構化資訊的一種格式。但 JSON 可以記錄結構複雜許多的資料，因為它可以具有階層 (巢狀) 結構。JSON 是一種純文字格式，跟 .csv 一樣是用來記錄結構化資訊的一種格式。但 JSON 可以記錄結構複雜許多的資料，因為它可以具有階層 (巢狀) 結構。JSON 所記錄的資料，結構上與 R 的 list 非常接近。下圖左邊的 R 程式碼所建立出的 list，其所表徵的資料結構等價於右方的 JSON:\n\n在 R 裡面，可以使用 jsonlite 套件協助處理 JSON。例如，jsonlite::fromJSON() 可將符合 JSON 格式的字串轉換成 R 的 list (反之，使用 jsonlite::toJSON()):\n\njson_str1 = '{\n  \"name\": \"美髮\",\n  \"subscriptionCount\": 1838,\n  \"subscribed\": false,\n  \"topics\": [\"剪髮\",\"染髮\",\"洗髮\"],\n  \"postThumbnail\": {\n    \"size\": null\n  }\n}'\n\njsonlite::fromJSON(json_str1, simplifyVector = F)\n#> $name\n#> [1] \"美髮\"\n#> \n#> $subscriptionCount\n#> [1] 1838\n#> \n#> $subscribed\n#> [1] FALSE\n#> \n#> $topics\n#> $topics[[1]]\n#> [1] \"剪髮\"\n#> \n#> $topics[[2]]\n#> [1] \"染髮\"\n#> \n#> $topics[[3]]\n#> [1] \"洗髮\"\n#> \n#> \n#> $postThumbnail\n#> $postThumbnail$size\n#> NULL\nJSON 所記錄的資料，結構上與 R 的 list 非常接近。下圖左邊的 R 程式碼所建立出的 list，其所表徵的資料結構等價於右方的 JSON:在 R 裡面，可以使用 jsonlite 套件協助處理 JSON。例如，jsonlite::fromJSON() 可將符合 JSON 格式的字串轉換成 R 的 list (反之，使用 jsonlite::toJSON()):\n\njson_str1 = '{\n  \"name\": \"美髮\",\n  \"subscriptionCount\": 1838,\n  \"subscribed\": false,\n  \"topics\": [\"剪髮\",\"染髮\",\"洗髮\"],\n  \"postThumbnail\": {\n    \"size\": null\n  }\n}'\n\njsonlite::fromJSON(json_str1, simplifyVector = F)\n#> $name\n#> [1] \"美髮\"\n#> \n#> $subscriptionCount\n#> [1] 1838\n#> \n#> $subscribed\n#> [1] FALSE\n#> \n#> $topics\n#> $topics[[1]]\n#> [1] \"剪髮\"\n#> \n#> $topics[[2]]\n#> [1] \"染髮\"\n#> \n#> $topics[[3]]\n#> [1] \"洗髮\"\n#> \n#> \n#> $postThumbnail\n#> $postThumbnail$size\n#> NULL在 R 裡面，可以使用 jsonlite 套件協助處理 JSON。例如，jsonlite::fromJSON() 可將符合 JSON 格式的字串轉換成 R 的 list (反之，使用 jsonlite::toJSON()):","code":"\njson_str1 = '{\n  \"name\": \"美髮\",\n  \"subscriptionCount\": 1838,\n  \"subscribed\": false,\n  \"topics\": [\"剪髮\",\"染髮\",\"洗髮\"],\n  \"postThumbnail\": {\n    \"size\": null\n  }\n}'\n\njsonlite::fromJSON(json_str1, simplifyVector = F)#> $name\n#> [1] \"美髮\"\n#> \n#> $subscriptionCount\n#> [1] 1838\n#> \n#> $subscribed\n#> [1] FALSE\n#> \n#> $topics\n#> $topics[[1]]\n#> [1] \"剪髮\"\n#> \n#> $topics[[2]]\n#> [1] \"染髮\"\n#> \n#> $topics[[3]]\n#> [1] \"洗髮\"\n#> \n#> \n#> $postThumbnail\n#> $postThumbnail$size\n#> NULL"},{"path":"ch10.html","id":"format","chapter":"10 擷取網路資料：Web API","heading":"10.4.1 Format","text":"通常，JSON 格式是以 { 開頭，以 } 結尾 (有時是 [ 與 ])。在 { 與 } 之間，是由一個個 key:value pair 所組成，每個 key-value pair 之間以 , 分隔。key 的形式一定是字串，而 value 可為：\n字串、數值、布林值、null\n或是一個以 {} 包裹的 key-value pairs (.e., 可具有巢狀結構)\n通常，JSON 格式是以 { 開頭，以 } 結尾 (有時是 [ 與 ])。在 { 與 } 之間，是由一個個 key:value pair 所組成，每個 key-value pair 之間以 , 分隔。key 的形式一定是字串，而 value 可為：字串、數值、布林值、null或是一個以 {} 包裹的 key-value pairs (.e., 可具有巢狀結構)在 JSON 格式裡，{} 之內的 key-value pair 並無次序關係。若需要表徵先後次序，需使用 array: []。在 [] 中，可以放入任意數量以及各個類別的資料 (彼此以 , 分隔)，例如：\n{\n  \"id\": \"rlads2019\",\n  \"array1\": [1.1, \"string\", false],\n  \"array2\": [2, {\"id\":1234}, null]\n}在 JSON 格式裡，{} 之內的 key-value pair 並無次序關係。若需要表徵先後次序，需使用 array: []。在 [] 中，可以放入任意數量以及各個類別的資料 (彼此以 , 分隔)，例如：","code":"{\n  \"id\": \"rlads2019\",\n  \"array1\": [1.1, \"a string\", false],\n  \"array2\": [2, {\"id\":1234}, null]\n}"}]
