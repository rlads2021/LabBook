[{"path":"index.html","id":"關於","chapter":"關於","heading":"關於","text":"程式設計與資料科學導論實習課講義GitHub課程影片","code":""},{"path":"ch01.html","id":"ch01","chapter":"1 掌握你的電腦","heading":"1 掌握你的電腦","text":"(投影片 /\n影片)","code":""},{"path":"ch01.html","id":"路徑-工作目錄","chapter":"1 掌握你的電腦","heading":"1.1 路徑 & 工作目錄","text":"電腦透過資料夾 (directory) 與檔案 (file) 將資訊組織起來，方便與使用者互動。資料夾裡面可以是另一個資料夾，也可以是檔案。換言之，資料夾是有階層結構的，可以一層層的包覆起來電腦透過資料夾 (directory) 與檔案 (file) 將資訊組織起來，方便與使用者互動。資料夾裡面可以是另一個資料夾，也可以是檔案。換言之，資料夾是有階層結構的，可以一層層的包覆起來在使用電腦時，我們通常是透過圖形使用者界面 (GUI) 與電腦互動。在操作檔案與資料夾時，我們通常會透過檔案管理員這類的程式 (Figure 1.1)在使用電腦時，我們通常是透過圖形使用者界面 (GUI) 與電腦互動。在操作檔案與資料夾時，我們通常會透過檔案管理員這類的程式 (Figure 1.1)\nFigure 1.1: Windows 與 Mac 的檔案管理界面1\n對於初次接觸程式的同學，需要逐步習慣使用 Text-based user interfaces (TUI) (下圖)。透過 TUI 與電腦互動意謂著使用者(幾乎)只能使用鍵盤，也意謂著使用者需了解更多的程式指令以及電腦組織檔案與資料夾的方式。但與此同時，使用者將能更好地掌握自己的電腦2\n對於初次接觸程式的同學，需要逐步習慣使用 Text-based user interfaces (TUI) (下圖)。透過 TUI 與電腦互動意謂著使用者(幾乎)只能使用鍵盤，也意謂著使用者需了解更多的程式指令以及電腦組織檔案與資料夾的方式。但與此同時，使用者將能更好地掌握自己的電腦2","code":""},{"path":"ch01.html","id":"目錄結構-directory-structure","chapter":"1 掌握你的電腦","heading":"1.1.1 目錄結構 (Directory structure)","text":"為方便理解電腦裡面的資料夾與檔案結構 (簡稱目錄結構)，我們通常會以樹狀結構去表示目錄結構。Figure 1.2 是 Windows 以及 Mac 上的目錄結構圖為方便理解電腦裡面的資料夾與檔案結構 (簡稱目錄結構)，我們通常會以樹狀結構去表示目錄結構。Figure 1.2 是 Windows 以及 Mac 上的目錄結構圖在樹狀圖中，越上方的資料夾階層越高。最上方的資料夾稱為根目錄 (root)，電腦中的所有其它資料夾與檔案皆位於根目錄之內3在樹狀圖中，越上方的資料夾階層越高。最上方的資料夾稱為根目錄 (root)，電腦中的所有其它資料夾與檔案皆位於根目錄之內3\nFigure 1.2: 目錄結構\n以 Figure 1.2 為例，\nWindows 的根目錄 C: 裡有 3 個資料夾 temp, Users, 以及 Windows，其中的 Users 之下又有 3 個資料夾 Tiger, Pooh 與 Piglet\nMac 的根目錄以 / 表示，裡面有 3 個資料夾 Library, Users 以及 System。Users 之下有 Tiger, Pooh 與 Piglet 3 個資料夾\nWindows 的根目錄 C: 裡有 3 個資料夾 temp, Users, 以及 Windows，其中的 Users 之下又有 3 個資料夾 Tiger, Pooh 與 PigletMac 的根目錄以 / 表示，裡面有 3 個資料夾 Library, Users 以及 System。Users 之下有 Tiger, Pooh 與 Piglet 3 個資料夾","code":""},{"path":"ch01.html","id":"路徑-path","chapter":"1 掌握你的電腦","heading":"1.1.2 路徑 (Path)","text":"使用 Text-based user interfaces (TUI) 與電腦互動時，需要一套用來描述路徑 (Path) (亦即, 某個資料夾或檔案位於電腦上的哪個位置) 的語法。這套語法基本上就是在告訴電腦「如何從 資料夾『走到』目標資料夾 (或檔案)」","code":""},{"path":"ch01.html","id":"絕對路徑","chapter":"1 掌握你的電腦","heading":"1.1.2.1 絕對路徑","text":"絕對路徑就是在告訴電腦「如何從根目錄 (root)走到目標資料夾 (或檔案)」/ 在描述路徑時具有 2 種語意：\n若 / 出現在路徑的起始 (e.g., /Users)，則其代表的是根目錄 (Windows 的 C: 以及 Mac 的 /)\n若 / 出現在 路徑的中間 (e.g., C:/Users/Pooh)，則是作為母 (Parent) 子 (Child) 資料夾之間的分隔符號\n若 / 出現在路徑的起始 (e.g., /Users)，則其代表的是根目錄 (Windows 的 C: 以及 Mac 的 /)若 / 出現在 路徑的中間 (e.g., C:/Users/Pooh)，則是作為母 (Parent) 子 (Child) 資料夾之間的分隔符號舉例來說，\n若要告訴電腦根目錄的位置，只須輸入根目錄的名稱：\nC: (Windows)/ (Mac)\n\n若要告訴電腦 Tiger 的位置，則可以在根目錄後面依序輸入 Users 與 Tiger，並使用 / 作為資料夾間的分隔線：\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\n\n若要告訴電腦根目錄的位置，只須輸入根目錄的名稱：\nC: (Windows)/ (Mac)\nC: (Windows)/ (Mac)若要告訴電腦 Tiger 的位置，則可以在根目錄後面依序輸入 Users 與 Tiger，並使用 / 作為資料夾間的分隔線：\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\nFigure 1.3: 絕對路徑\n現在是時候打開終端機 (Terminal) 玩玩看了 (解鎖你電腦的 1 號隱藏功能)。按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：\nC:\\Users\\{username}\n這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在 Finder 搜尋 Terminal 或 終端機在 Finder 搜尋 Terminal 或 終端機在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑\n/Users/{username}\n這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱這個出現在終端機上的絕對路徑即是目前終端機程式的工作目錄。所以到底什麼是工作目錄？由於程式 (e.g., 終端機, R, Python, Chrome, …) 運行時需要與電腦進行互動，換言之，它們經常需要讀取、修改、刪除與寫入檔案與資料夾，但同時又不需要知道電腦上完整的目錄結構，因此它們需要有一個參照用的資料夾，以此資料夾作為描述路徑的基準。這個參照的資料夾就如同執行中的程式工作的地方，因此稱為工作目錄；而用來描述相對於工作目錄的路徑則稱為相對路徑。而上面 C:\\Users\\{username} (Windows) 與 /Users/{username} (Mac) 這兩個路徑， 即是終端機開啟時預設的工作目錄。下方介紹完相對路徑後，接著會告訴大家如何更改工作目錄。","code":"C:\\Users\\{username}/Users/{username}"},{"path":"ch01.html","id":"windows","chapter":"1 掌握你的電腦","heading":"Windows","text":"按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：\nC:\\Users\\{username}\n這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱","code":"C:\\Users\\{username}"},{"path":"ch01.html","id":"mac","chapter":"1 掌握你的電腦","heading":"Mac","text":"在 Finder 搜尋 Terminal 或 終端機在 Finder 搜尋 Terminal 或 終端機在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑\n/Users/{username}\n這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱","code":"/Users/{username}"},{"path":"ch01.html","id":"工作目錄-working-directory","chapter":"1 掌握你的電腦","heading":"工作目錄 (Working Directory)","text":"這個出現在終端機上的絕對路徑即是目前終端機程式的工作目錄。所以到底什麼是工作目錄？由於程式 (e.g., 終端機, R, Python, Chrome, …) 運行時需要與電腦進行互動，換言之，它們經常需要讀取、修改、刪除與寫入檔案與資料夾，但同時又不需要知道電腦上完整的目錄結構，因此它們需要有一個參照用的資料夾，以此資料夾作為描述路徑的基準。這個參照的資料夾就如同執行中的程式工作的地方，因此稱為工作目錄；而用來描述相對於工作目錄的路徑則稱為相對路徑。而上面 C:\\Users\\{username} (Windows) 與 /Users/{username} (Mac) 這兩個路徑， 即是終端機開啟時預設的工作目錄。下方介紹完相對路徑後，接著會告訴大家如何更改工作目錄。","code":""},{"path":"ch01.html","id":"相對路徑","chapter":"1 掌握你的電腦","heading":"1.1.2.2 相對路徑","text":"相對路徑就是在告訴電腦「如何從工作目錄 (working directory) 走到目標資料夾 (或檔案)」。以下方的目錄結構為例 (工作目錄設在 /Users/Pooh)，\nFigure 1.4: 範例目錄結構。在此例中，工作目錄設置在 Pooh\n. 表示的是「當前」的目錄，所以若其出現在路徑的開頭，即是指工作目錄5。所以透過相對路徑表示工作目錄非常簡短：\n.. 表示的是「當前」的目錄，所以若其出現在路徑的開頭，即是指工作目錄5。所以透過相對路徑表示工作目錄非常簡短：若要表示工作目錄之下的檔案或資料夾，例如 Desktop，其相對路徑即為其名稱：\nDesktop\n或是，也可以在透過 . 表示當前目錄之後，再於後方加入檔案或資料夾的名稱：\n./Desktop若要表示工作目錄之下的檔案或資料夾，例如 Desktop，其相對路徑即為其名稱：或是，也可以在透過 . 表示當前目錄之後，再於後方加入檔案或資料夾的名稱：依此類推，工作目錄下面兩個階層的檔案或資料夾 (例如，.txt) 的相對路徑為：\nDesktop/.txt\n./Desktop/.txt依此類推，工作目錄下面兩個階層的檔案或資料夾 (例如，.txt) 的相對路徑為：.. 則讓我們可以往上走。例如，若想表示工作目錄的母資料夾 Users，可以使用 ..：\n..\n./.... 則讓我們可以往上走。例如，若想表示工作目錄的母資料夾 Users，可以使用 ..：這讓我們可以很方便地表示工作目錄的「姊妹」資料夾 Tiger (它們共同的母資料夾是 Users)：\n../Tiger\n./../Tiger\n\n\nFigure 1.5: 透過相對路徑表示「姊妹」的資料夾\n\n這讓我們可以很方便地表示工作目錄的「姊妹」資料夾 Tiger (它們共同的母資料夾是 Users)：\nFigure 1.5: 透過相對路徑表示「姊妹」的資料夾\n同理，若要表達 Tiger 之下的 .txt，只需在原本的路徑之後加入檔名：\n../Tiger/.txt\n./../Tiger/.txt同理，若要表達 Tiger 之下的 .txt，只需在原本的路徑之後加入檔名：透過終端機更改工作目錄的指令很簡單：cd (“change directory”) + 絕對/相對路徑6。所以假設想將 Figure 1.5 中的工作目錄 Pooh 更改成 Tiger，只要輸入：或Windows 系統上的路徑使用的是反斜線 \\ 作為分隔符號，與其它系統 (Mac, Linux 等) 以及各種程式語言 (R, Python 等) 使用的 / 不同。但近年的 Windows 系統已讓使用者能輸入 / 作為路徑中的分隔7。由於反斜線 \\ 在許多程式語言中常具有特殊的功能，這邊強烈建議大家路徑中不要使用反斜線 \\，請使用 /。這麼做的好處之一，是讓你撰寫的程式可以同時在 Windows 以及其它系統上運行8。","code":".Desktop./DesktopDesktop/i.txt\n./Desktop/i.txt..\n./..../Tiger\n./../Tiger../Tiger/he.txt\n./../Tiger/he.txtcd ../Tigercd /Users/Tiger"},{"path":"ch01.html","id":"windows-路徑中的反斜線","chapter":"1 掌握你的電腦","heading":"Windows 路徑中的反斜線 (\\)","text":"Windows 系統上的路徑使用的是反斜線 \\ 作為分隔符號，與其它系統 (Mac, Linux 等) 以及各種程式語言 (R, Python 等) 使用的 / 不同。但近年的 Windows 系統已讓使用者能輸入 / 作為路徑中的分隔7。由於反斜線 \\ 在許多程式語言中常具有特殊的功能，這邊強烈建議大家路徑中不要使用反斜線 \\，請使用 /。這麼做的好處之一，是讓你撰寫的程式可以同時在 Windows 以及其它系統上運行8。","code":""},{"path":"ch01.html","id":"r-101","chapter":"1 掌握你的電腦","heading":"1.2 R 101","text":"現在我們已經知道如何操作終端機了。接下來，我們就可以透過終端機執行我們的第一支 R 程式：透過文字編輯器9新增一份純文字檔，將檔案命名為 hello.R。hello.R 內請寫下：\n\nprint(\"Hello World!\")透過文字編輯器9新增一份純文字檔，將檔案命名為 hello.R。hello.R 內請寫下：打開終端機，cd 到 hello.R 所在的資料夾 (e.g., C:/Users/Tiger/Desktop)，再執行 Rscript hello.R:\ncd ./Desktop\nRscript hello.R打開終端機，cd 到 hello.R 所在的資料夾 (e.g., C:/Users/Tiger/Desktop)，再執行 Rscript hello.R:這時，你應該會看到終端機裡印出：\n[1] \"Hello World!\"這時，你應該會看到終端機裡印出：試著修改 hello.R 的內容，然後重複執行 Rscript hello.R，看看輸出指令如何改變。你可以嘗試以下的指令：print(\"Hi\")(2 + 7) / 102 ^ 31:4在 hello.R 裡面，你可以輸入不只一條指令，但注意，每一條指令需佔獨立的一行。例如，若要輸入三條指令，hello.R 的樣子會類似：","code":"\nprint(\"Hello World!\")cd ./Desktop\nRscript hello.R[1] \"Hello World!\"\nprint(\"Hello world\")\nprint(\"Hi\")\n(2 + 7) / 10"},{"path":"ch01.html","id":"r-script","chapter":"1 掌握你的電腦","heading":"1.2.1 R Script","text":"hello.R 這類用來撰寫程式的純文字檔稱為 R script (而執行 R Script 裡程式的指令為 Rscript)。在 R script 中，程式碼是由上至下執行，所以上面的例子執行後會依序印出這三行的執行結果：","code":"\nprint(\"Hello world\")\nprint(\"Hi\")\n(2 + 7) / 10[1] \"Hello World!\"\n[1] \"Hi\"\n[1] 0.9"},{"path":"ch01.html","id":"回傳值","chapter":"1 掌握你的電腦","heading":"1.2.2 回傳值","text":"在上方的例子中，印出的執行結果前面皆有一個 [1]。這個 [1] 的目的是為了方便使用者知道指令執行的結果 (回傳值) 的「位置」。事實上，R 印出回傳值的形式是：[<num>] <value(s)>：\n<value(s)> 是指令所傳回來的值 (可有一個以上)，e.g. 1 1 2 3 4 \"\" \"b\" \"c\" \"d\"\n而 [<num>] 則是一個指標 (位於每橫列的開頭)，用來指示其右邊第一個值在所有的值之中的排序，e.g. [1] 11 12 13 代表 11 是第 1 個數值、12 是第 2 個數值；若第一行不足以印出所有的值，則會接著印出第二行: 例如 [16] 26 27 28 代表 26 是第 16 個。\n在上方的例子中，印出的執行結果前面皆有一個 [1]。這個 [1] 的目的是為了方便使用者知道指令執行的結果 (回傳值) 的「位置」。事實上，R 印出回傳值的形式是：[<num>] <value(s)>：<value(s)> 是指令所傳回來的值 (可有一個以上)，e.g. 1 1 2 3 4 \"\" \"b\" \"c\" \"d\"而 [<num>] 則是一個指標 (位於每橫列的開頭)，用來指示其右邊第一個值在所有的值之中的排序，e.g. [1] 11 12 13 代表 11 是第 1 個數值、12 是第 2 個數值；若第一行不足以印出所有的值，則會接著印出第二行: 例如 [16] 26 27 28 代表 26 是第 16 個。例如，執行 1:50 會回傳 50 個值 (1~50)。因為終端機一行無法顯示全部的值，它便會將結果用多行 (行數每台電腦可能不同) 顯示，並透過 [<num>] 方便使用者知道目前印到哪一個值：\n\n1:50\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50例如，執行 1:50 會回傳 50 個值 (1~50)。因為終端機一行無法顯示全部的值，它便會將結果用多行 (行數每台電腦可能不同) 顯示，並透過 [<num>] 方便使用者知道目前印到哪一個值：","code":"\n1:50#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"},{"path":"ch01.html","id":"變數指派-assignment","chapter":"1 掌握你的電腦","heading":"1.2.3 變數指派 (Assignment)","text":"要將指令的回傳值儲存起來，需要使用 <- (assignment operator)，將 <- 右邊的程式碼執行後所回傳的數值儲存於 <- 左邊的變數例如，我可以先將 2 * 3 + 4 的運算結果儲存在 x 內：之後，我可以輸入 x 直接取用上次運算的結果：","code":"\nx <- 2 * 3 + 4\nx#> [1] 10\nx + 1  # 用 x 內的值進一步運算#> [1] 11"},{"path":"ch01.html","id":"r-內建函數","chapter":"1 掌握你的電腦","heading":"1.2.4 R 內建函數","text":"R 裡面的函數就像是我們國高中數學課學到的「函數」。\nR 的函數 (通常) 會有一個或多個「輸入值」，稱為「引數 (argument)」；並且在運算完成後，一定會丟出一個「回傳值」\nR 裡面的函數就像是我們國高中數學課學到的「函數」。R 的函數 (通常) 會有一個或多個「輸入值」，稱為「引數 (argument)」；並且在運算完成後，一定會丟出一個「回傳值」sqrt() 是一個函數，它會將輸入值 (在圓括號內) 開根號後回傳\n\nsqrt(16)\n#> [1] 4sqrt() 是一個函數，它會將輸入值 (在圓括號內) 開根號後回傳函數裡面可以放入另一個函數 (e.g. sqrt(sqrt(16)))，其運算的次序是由內而外，先執行最內部的函數，取得回傳值後，再將此回傳值作為外面的函數的輸入值\n\nsqrt(sqrt(16))\n#> [1] 2\n概念上等同於：\n\ninner <- sqrt(16)\nsqrt(inner)\n#> [1] 2函數裡面可以放入另一個函數 (e.g. sqrt(sqrt(16)))，其運算的次序是由內而外，先執行最內部的函數，取得回傳值後，再將此回傳值作為外面的函數的輸入值概念上等同於：","code":"\nsqrt(16)#> [1] 4\nsqrt(sqrt(16))#> [1] 2\ninner <- sqrt(16)\nsqrt(inner)#> [1] 2"},{"path":"ch01.html","id":"r-console","chapter":"1 掌握你的電腦","heading":"1.2.5 R Console","text":"寫程式時，每次修改都要透過 Rscript 指令檢視執行結果有點麻煩，特別是當你只是在測試或是只想看某一行指令的輸出結果時。因此在撰寫程式時，我們通常會\n先將指令寫在 R Console 測試\n確認執行結果沒問題後再將指令複製到 R Script\n寫完完整的一段程式碼再透過終端機執行整個 R Script\n先將指令寫在 R Console 測試確認執行結果沒問題後再將指令複製到 R Script寫完完整的一段程式碼再透過終端機執行整個 R Script在終端機裡面輸入 R 即可打開 R Console。R Console 是互動式的，意思是輸入一行指令後，可以馬上看到指令執行的結果，並且還可以繼續執行其它指令 (過程中若有指派變數，結果也會記錄下來)。\nFigure 1.6: 寫 R 必備的 3 樣工具\n","code":""},{"path":"ch01.html","id":"說明文件-r-help-page","chapter":"1 掌握你的電腦","heading":"1.2.6 說明文件 (R Help Page)","text":"不確定如何使用函數時，可以閱讀該函數的說明文件：\n\n# ?<function_name>\n?log\n\n# ?`<function_name>`: special functions (e.g. binary operators)\n?`+`不確定如何使用函數時，可以閱讀該函數的說明文件：\nFigure 1.7: 說明文件結構。建議閱讀步驟：Description > Usage > Arguments > Value > Examples > Details\n","code":"\n# ?<function_name>\n?log\n\n# ?`<function_name>`: for special functions (e.g. binary operators)\n?`+`"},{"path":"ch02.html","id":"ch02","chapter":"2 Base R (I) & 輔助工具","heading":"2 Base R (I) & 輔助工具","text":"(投影片 /\n影片)","code":""},{"path":"ch02.html","id":"r-studio","chapter":"2 Base R (I) & 輔助工具","heading":"2.1 R Studio","text":"","code":""},{"path":"ch02.html","id":"自訂樣式","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.1 自訂樣式","text":"RStudio 預設有 4 個區塊 (Pane)。你可以自行決定這 4 個區塊的位置\nTools –> Global Options... –> (在左欄選擇) Pane Layout\nSource, Console, 及 2 個自訂區塊\nTools –> Global Options... –> (在左欄選擇) Pane LayoutSource, Console, 及 2 個自訂區塊除了區塊的相對位置，也可以設定 RStudio 整體的風格以及程式碼 Syntax Highlighting 的樣式:\nTools –> Global Options... –> (在左欄選擇) Appearance\nTools –> Global Options... –> (在左欄選擇) Appearance","code":""},{"path":"ch02.html","id":"編輯器設定","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.2 編輯器設定","text":"Source Pane 是撰寫程式碼的地方 (文字編輯器)\n縮排間距：建議使用 space (而非 tab) 作為縮排字元\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab\n\n文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding\n\n縮排間距：建議使用 space (而非 tab) 作為縮排字元\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab\n縮排間距：建議使用 space (而非 tab) 作為縮排字元Tools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding\n文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8Tools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding","code":""},{"path":"ch02.html","id":"工作目錄","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.3 工作目錄","text":"使用 RStudio 時，最好養成要馬上設置「工作目錄」的習慣。使用 RStudio 時，最好養成要馬上設置「工作目錄」的習慣。RStudio 所在的「工作目錄」顯示於 Console Pane 的標籤下方 (e.g. ~/)RStudio 所在的「工作目錄」顯示於 Console Pane 的標籤下方 (e.g. ~/)工作目錄的設置方式\nRStudio 功能選單: Sessions > Set Working Directory...\nConsole\n\nsetwd('~/Desktop/week2')\n# setwd('<path//new_working_dir>')\ngetwd()  # show current directory\n工作目錄的設置方式RStudio 功能選單: Sessions > Set Working Directory...RStudio 功能選單: Sessions > Set Working Directory...Console\n\nsetwd('~/Desktop/week2')\n# setwd('<path//new_working_dir>')\ngetwd()  # show current directoryConsole","code":"\nsetwd('~/Desktop/week2')\n# setwd('<path/to/new_working_dir>')\ngetwd()  # show current directory"},{"path":"ch02.html","id":"函數","chapter":"2 Base R (I) & 輔助工具","heading":"2.2 函數","text":"","code":"\nget_area <- function() {\n    area <- 3.14 * 1 * 1\n    return(area)\n}\nget_area()#> [1] 3.14\n# Function with a argument\nget_area <- function(r) {\n    area <- 3.14 * r * r\n    return(area)\n}\nget_area(2)#> [1] 12.56\n# Function with a argument that has default value\nget_area <- function(r = 1) {\n    area <- 3.14 * r * r\n    return(area)\n}\nget_area()#> [1] 3.14\nget_area <- function(r) {\n    area <- 3.14 * r * r\n    return(area)\n}\narea <- 100\narea\nget_area(1)\narea#> [1] 100\n#> [1] 3.14\n#> [1] 100"},{"path":"ch02.html","id":"function-arguments","chapter":"2 Base R (I) & 輔助工具","heading":"2.3 Function Arguments","text":"","code":"\nvol <- function(r, height = 1) {\n    volumn <- 3.14 * r * r * height\n    return(volumn)\n}\nvol(1, 2)#> [1] 6.28\nvol(r = 1, height = 2)  # Be explicit#> [1] 6.28\n# If all args are named, order doesn't matter\nvol(height = 2, r = 1)#> [1] 6.28\n# Mix named and unnamed args:\n# named args will be assigned first, then\n# unnamed args will be assigned \n# based on their positions\nvol(height = 2, 1)#> [1] 6.28"},{"path":"ch02.html","id":"vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4 vector","text":"上週實習課使用 R 時，指令的回傳值多半只有「一個」。但 R 其實是一種以向量作為基本單位的程式語言，所以對於「一個回傳值」更精確的描述應該是「一個長度為 1 的向量」。\n\nx <- 2\nx\n#> [1] 2\n\n.vector(x)\n#> [1] TRUE\n\nlength(x)\n#> [1] 1上週實習課使用 R 時，指令的回傳值多半只有「一個」。但 R 其實是一種以向量作為基本單位的程式語言，所以對於「一個回傳值」更精確的描述應該是「一個長度為 1 的向量」。我們上週簡短提過以 : 製造數列的方式 (e.g. 1:10)。事實上，這個回傳的數列即是一個 vector。另外，由於這個 vector 的每個元素皆是整數，因此這個 vector 屬於 integer vector。我們可以使用 typeof() 確認 vector 的類別\n\ntypeof(1:10)\n#> [1] \"integer\"我們上週簡短提過以 : 製造數列的方式 (e.g. 1:10)。事實上，這個回傳的數列即是一個 vector。另外，由於這個 vector 的每個元素皆是整數，因此這個 vector 屬於 integer vector。我們可以使用 typeof() 確認 vector 的類別R 裡面的 vector 可以被分成 6 種類別，其中常見的 4 種分別為 integer, double, , character, logicalR 裡面的 vector 可以被分成 6 種類別，其中常見的 4 種分別為 integer, double, , character, logical","code":"\nx <- 2\nx#> [1] 2\nis.vector(x)#> [1] TRUE\nlength(x)#> [1] 1\ntypeof(1:10)#> [1] \"integer\""},{"path":"ch02.html","id":"integer-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.1 integer vector","text":"integer vector 的元素由整數組成，它可以是零、正或負的。除了使用 : 製造數列，也可以使用 c() (稱為 concatenate) 組出任意序列的 vector。\n使用 c() 製造 integer vector 時，每個整數數字後面必須接 L，若沒有加上 L， R 會將製造出來的 vector 視為 double vector。\n使用 c() 製造 integer vector 時，每個整數數字後面必須接 L，若沒有加上 L， R 會將製造出來的 vector 視為 double vector。","code":"\nint_vec <- c(-1L, 5L, 2L)\ndbl_vec <- c(-1, 5, 2)\nint_vec#> [1] -1  5  2\ndbl_vec#> [1] -1  5  2\ntypeof(int_vec)#> [1] \"integer\"\ntypeof(dbl_vec)#> [1] \"double\""},{"path":"ch02.html","id":"double-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.2 double vector","text":"double vector 儲存的是浮點數，亦即含有小數點的數字 (e.g 1.2, -0.75)double vector 儲存的是浮點數，亦即含有小數點的數字 (e.g 1.2, -0.75)在 R 裡面，integer vector 與 double vector 合稱為 numeric vector，兩者之間的區隔通常也不太重要，因為 R 在運算時，通常會將這兩種資料類型自動轉換成合適的類型\n\ntypeof(2L)\n#> [1] \"integer\"\n\ntypeof(2.0)\n#> [1] \"double\"\n\n.numeric(2L)\n#> [1] TRUE\n\n.numeric(2.0)\n#> [1] TRUE\n\ntypeof(1L + 1.0)\n#> [1] \"double\"\n\ntypeof(1L / 2L)\n#> [1] \"double\"在 R 裡面，integer vector 與 double vector 合稱為 numeric vector，兩者之間的區隔通常也不太重要，因為 R 在運算時，通常會將這兩種資料類型自動轉換成合適的類型Special values:\nInf: 代表無限大\nNaN: “Number”，常見於數字運算不符數學定義時，例如：\n\n0 / 0\n#> [1] NaN\n\nInf / Inf\n#> [1] NaN\n\nlog(-1)\n#> Warning log(-1): NaNs produced\n#> [1] NaN\nSpecial values:Inf: 代表無限大Inf: 代表無限大NaN: “Number”，常見於數字運算不符數學定義時，例如：\n\n0 / 0\n#> [1] NaN\n\nInf / Inf\n#> [1] NaN\n\nlog(-1)\n#> Warning log(-1): NaNs produced\n#> [1] NaNNaN: “Number”，常見於數字運算不符數學定義時，例如：","code":"\ntypeof(2L)#> [1] \"integer\"\ntypeof(2.0)#> [1] \"double\"\nis.numeric(2L)#> [1] TRUE\nis.numeric(2.0)#> [1] TRUE\ntypeof(1L + 1.0)#> [1] \"double\"\ntypeof(1L / 2L)#> [1] \"double\"\n0 / 0#> [1] NaN\nInf / Inf#> [1] NaN\nlog(-1)#> Warning in log(-1): NaNs produced#> [1] NaN"},{"path":"ch02.html","id":"character-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.3 character vector","text":"除了數字以外，R 也可以儲存字串 (string)。character vector 的每個元素皆由一個字串所組成。在 R 裡面，只要是被引號 (quote, ' 或 \" 皆可) 包裹的東西就是字串，放在引號內的可以是任何字元 (e.g. 空白、數字、中文字、英文字母)\n\n\"1.1\"  # string (character vector length 1), double\n#> [1] \"1.1\"\n\n\"你好！\"\n#> [1] \"你好！\"\n\nc(\"1.1\", \"你好！\")\n#> [1] \"1.1\"    \"你好！\"除了數字以外，R 也可以儲存字串 (string)。character vector 的每個元素皆由一個字串所組成。在 R 裡面，只要是被引號 (quote, ' 或 \" 皆可) 包裹的東西就是字串，放在引號內的可以是任何字元 (e.g. 空白、數字、中文字、英文字母)如果字串內含有引號 \"，需在字串內的引號前使用跳脫字元 \\，以表示此引號是字串的一部分而非字串的開頭或結尾\n或是，你可以使用「不同的」引號。例如以「單引號」表示字串的開頭與結尾時，字串內就可以直接使用「雙引號」，反之亦然\n\n\"\\\"\"  # escape double quote\n'\\''  # escape single quote\n'\"'   # double quote string without escaping\n\"'\"   # single quote string without escaping\n#> [1] \"\\\"\"\n#> [1] \"'\"\n#> [1] \"\\\"\"\n#> [1] \"'\"如果字串內含有引號 \"，需在字串內的引號前使用跳脫字元 \\，以表示此引號是字串的一部分而非字串的開頭或結尾或是，你可以使用「不同的」引號。例如以「單引號」表示字串的開頭與結尾時，字串內就可以直接使用「雙引號」，反之亦然","code":"\n\"1.1\"  # This is a string (character vector of length 1), not double#> [1] \"1.1\"\n\"你好！\"#> [1] \"你好！\"\nc(\"1.1\", \"你好！\")#> [1] \"1.1\"    \"你好！\"\n\"\\\"\"  # escape a double quote\n'\\''  # escape a single quote\n'\"'   # a double quote as string without escaping\n\"'\"   # a single quote as string without escaping#> [1] \"\\\"\"\n#> [1] \"'\"\n#> [1] \"\\\"\"\n#> [1] \"'\""},{"path":"ch02.html","id":"logical-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.4 logical vector","text":"logical vector 的每個元素由 TRUE 或 FALSE 組成。logical vector 的每個元素由 TRUE 或 FALSE 組成。可以使用 c() 一項項手動輸入製造 logical vector可以使用 c() 一項項手動輸入製造 logical vectorlogical vector 的另一個來源則是 logical test 的回傳值：\nlogical operators: ==, !=, >, <, %%\n\n\nvec1 <- c(1, 1, 1)\nvec2 <- c(2, 0, 2)\n\n# logical tests\nvec1 > vec2\n#> [1] FALSE  TRUE FALSE\n\nvec1 < vec2\n#> [1]  TRUE FALSE  TRUE\n\nvec1 == vec2\n#> [1] FALSE FALSE FALSElogical vector 的另一個來源則是 logical test 的回傳值：logical operators: ==, !=, >, <, %%boolean operators (&, |, !, (), ()) 可以整合多個 logical tests\n\n\nTRUE & TRUE\n#> [1] TRUE\n\nTRUE & FALSE\n#> [1] FALSE\n\nTRUE | FALSE\n#> [1] TRUE\n\n!TRUE\n#> [1] FALSE\n\n(1 == 1) & (2 == 2)\n#> [1] TRUEboolean operators (&, |, !, (), ()) 可以整合多個 logical tests","code":"\nvec1 <- c(1, 1, 1)\nvec2 <- c(2, 0, 2)\n# logical tests\nvec1 > vec2#> [1] FALSE  TRUE FALSE\nvec1 < vec2#> [1]  TRUE FALSE  TRUE\nvec1 == vec2#> [1] FALSE FALSE FALSE\nTRUE & TRUE#> [1] TRUE\nTRUE & FALSE#> [1] FALSE\nTRUE | FALSE#> [1] TRUE\n!TRUE#> [1] FALSE\n(1 == 1) & (2 == 2)#> [1] TRUE"},{"path":"ch02.html","id":"na","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.5 NA","text":"NA 代表的是「缺失值」，可以作為任何一種 vector 裡面的元素。當 NA 出現在 vector 中，函數對於 vector 的運算常會出現令人意外的結果:\n\n10 > NA\n#> [1] NA\n\nNA == NA\n#> [1] NA\n\nvec <- c(1, NA, 2, 3)\nmean(vec)\n#> [1] NA\n\nmean(vec, na.rm = TRUE)\n#> [1] 2NA 代表的是「缺失值」，可以作為任何一種 vector 裡面的元素。當 NA 出現在 vector 中，函數對於 vector 的運算常會出現令人意外的結果:","code":"\n10 > NA#> [1] NA\nNA == NA#> [1] NA\nvec <- c(1, NA, 2, 3)\nmean(vec)#> [1] NA\nmean(vec, na.rm = TRUE)#> [1] 2"},{"path":"ch02.html","id":"recycling","chapter":"2 Base R (I) & 輔助工具","heading":"2.5 Recycling","text":"兩個或兩個以上的 vector 進行運算時，通常是以 element-wise 的方式進行。此時，若進行運算的 vector 長度不相同，例如，c(1, 2, 3) + 2， R 會自動將長度較短 vector (2) 「回收 (recycle)」，亦即，重複此向量內的元素使其「拉長」到與另一個 vector 等長；接著再將兩個一樣長的 vector 進行 element-wise 的向量運算。","code":"\nx <- c(1, 1, 2, 2)\n\n# Arithmetic operation\nx + 2  # equivalent to...#> [1] 3 3 4 4\nx + c(2, 2, 2, 2)#> [1] 3 3 4 4\nx <- c(1, 1, 2, 2)\n\n# Logical operation\nx == 2  # equivalent to...#> [1] FALSE FALSE  TRUE  TRUE\nx == c(2, 2, 2, 2)#> [1] FALSE FALSE  TRUE  TRUE\n# String operation\nlong <- c(\"a\", \"b\", \"c\")\nshort <- \"1\"\npaste0(\"a\", \"1\")#> [1] \"a1\"\npaste0(long, short)#> [1] \"a1\" \"b1\" \"c1\""},{"path":"ch02.html","id":"coercion","chapter":"2 Base R (I) & 輔助工具","heading":"2.6 Coercion","text":"vector 內的每個元素，其資料類型 (data type) 必須相同。資料類型即是前面提到的 integer, double, character, logical。vector 內的每個元素，其資料類型 (data type) 必須相同。資料類型即是前面提到的 integer, double, character, logical。若發生資料類型不一致的情形 (e.g. 將不同資料類型的元素放入 c())，R 會根據某些規則，自動進行資料類型的轉換。這個過程在 R 裡面稱為 Coercion\n\nc(TRUE, FALSE, 3)      # logical & numeric\n#> [1] 1 0 3\n\nc(-1, \"aa\")            # numeric & character\n#> [1] \"-1\" \"aa\"\n\nc(FALSE, TRUE, \"hi!\")  # logical & character\n#> [1] \"FALSE\" \"TRUE\"  \"hi!\"\n\nc(TRUE, 0, \"hi!\")      # logical & numeric & character\n#> [1] \"TRUE\" \"0\"    \"hi!\"若發生資料類型不一致的情形 (e.g. 將不同資料類型的元素放入 c())，R 會根據某些規則，自動進行資料類型的轉換。這個過程在 R 裡面稱為 Coercion\nFigure 2.1: Rules Coercion\ncoercion failed, throw errorif coercion failed, throw errormanual coercion: .character(), .logical(), .numeric()manual coercion: .character(), .logical(), .numeric()","code":"\nc(TRUE, FALSE, 3)      # logical & numeric#> [1] 1 0 3\nc(-1, \"aa\")            # numeric & character#> [1] \"-1\" \"aa\"\nc(FALSE, TRUE, \"hi!\")  # logical & character#> [1] \"FALSE\" \"TRUE\"  \"hi!\"\nc(TRUE, 0, \"hi!\")      # logical & numeric & character#> [1] \"TRUE\" \"0\"    \"hi!\"\nsum(c(T, T, T, F))#> [1] 3\ngender <- c(\"male\", \"female\", \"male\", \"female\")\nsum(gender == \"male\")  # num of male#> [1] 2\nmean(gender == \"male\")  # proportion of male#> [1] 0.5"},{"path":"ch02.html","id":"subsetting-a-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.7 Subsetting a vector","text":"有 3 種方法可用於取出 vector 裡面的元素 (回傳一個新的 vector)\n透過提供 vector 中元素的位置次序 (index)\n透過一個與此 vector 等長的 logical vector。在 logical vector 中的相對應位置，以 TRUE 或 FALSE 表示是否保留該位置的元素\n透過提供元素的「名字」(.e. names 屬性)\n透過提供 vector 中元素的位置次序 (index)透過一個與此 vector 等長的 logical vector。在 logical vector 中的相對應位置，以 TRUE 或 FALSE 表示是否保留該位置的元素透過提供元素的「名字」(.e. names 屬性)","code":""},{"path":"ch02.html","id":"index-subsetting","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.1 index subsetting","text":"","code":"\n# z[<integer_vector>]\nLETTERS  # R 內建變數: 包含所有大寫英文字母的 character vector#>  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\nLETTERS[1]#> [1] \"A\"\nLETTERS[1:5]#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nLETTERS[c(1, 3, 5)]#> [1] \"A\" \"C\" \"E\"\nLETTERS[-(1:5)]  # Exclude the first 5 elements#>  [1] \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\"\n#> [20] \"Y\" \"Z\""},{"path":"ch02.html","id":"logical-subsetting","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.2 Logical subsetting","text":"","code":"\n# z[<logical_vector of length(z)>]\nage <- c(21, 20, 18, 19)\nage[c(FALSE, TRUE, FALSE, TRUE)]#> [1] 20 19\n## Creating logical vectors\nage[1] < 20  # returns a logical vector of length 1#> [1] FALSE\nage < 20     # returns a logical vector of length(x)#> [1] FALSE FALSE  TRUE  TRUE\n# Subset a vector using a logical test\nage[age < 20]#> [1] 18 19"},{"path":"ch02.html","id":"subsetting-with-names","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.3 Subsetting with names","text":"","code":"\nage <- c(40, 20, 18, 19)\nnames(age) <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\n# age <- c(kai = 40, pooh = 20, tiger = 18, piglet = 19)  # another way of setting names\n\nage#>    kai   pooh  tiger piglet \n#>     40     20     18     19\nage['kai'] + 9#> kai \n#>  49\nage[c('pooh', 'kai')]#> pooh  kai \n#>   20   40"},{"path":"ch02.html","id":"modifying-values-in-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.4 Modifying Values in vector","text":"","code":"\na2z <- LETTERS\na2z[1:3] <- c(\"a\", \"b\", \"c\")\na2z#>  [1] \"a\" \"b\" \"c\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\ngender <- c(\"m\", \"m\", \"f\", \"f\")\ngender[gender == \"m\"] <- \"male\"\ngender#> [1] \"male\" \"male\" \"f\"    \"f\"\ngender[gender == \"f\"] <- \"female\"\ngender#> [1] \"male\"   \"male\"   \"female\" \"female\"\nnames(gender) <- c(\"john\", \"jenny\", \"jane\", \"kate\")\ngender#>     john    jenny     jane     kate \n#>   \"male\"   \"male\" \"female\" \"female\"\ngender[\"john\"] <- \"male\"\ngender#>     john    jenny     jane     kate \n#>   \"male\"   \"male\" \"female\" \"female\"\ngender[c(\"jenny\", \"jane\", \"kate\")] <- \"female\"\ngender#>     john    jenny     jane     kate \n#>   \"male\" \"female\" \"female\" \"female\""},{"path":"ch02.html","id":"if-else","chapter":"2 Base R (I) & 輔助工具","heading":"2.8 if else","text":"一般而言，R 是由上至下一行一行地執行程式碼。有時候我們會希望能跳過某些程式碼或是依據不同的狀況執行不同的程式碼，這時候我們就需要使用條件式。在 -else -else 的結構中，只有其中一個區塊 (被大括弧 {} 包裹的程式碼) 會被執行。執行完該區塊後，就會忽略剩下的條件控制區塊，執行條件式之後的程式碼。在 -else -else 的結構中，只有其中一個區塊 (被大括弧 {} 包裹的程式碼) 會被執行。執行完該區塊後，就會忽略剩下的條件控制區塊，執行條件式之後的程式碼。可以在 之後使用多個 else .可以在 之後使用多個 else .條件式的結構：\n# 只有 \n(<條件>) {\n    <Code>  # 條件成立時執行\n}\n\n# , else\n(<條件>) {\n    <Code>  # <條件>成立時執行\n} else {\n    <Code>  # <條件>不成立時執行\n}\n\n# , else , else\n(<條件1>) {\n    <Code>          # <條件1>成立時執行\n} else ( <條件2> ) {\n    <Code>          # <條件1>不成立、<條件2>成立時執行\n} else {\n    <Code>          # <條件1>、<條件2>皆不成立時執行\n}條件式的結構：","code":"\nx <- 1\n\nif (x > 0) {\n    print('x is positive')\n} else {\n    print('x is not positive')\n}#> [1] \"x is positive\"\nx <- -1\n\nif (x > 0) {\n    print('x is positive')\n} else if (x < 0) {\n    print('x is negative')\n} else {\n    print('x is zero')\n}\n\nprint('This is always printed')#> [1] \"x is negative\"\n#> [1] \"This is always printed\"# 只有 if\nif (<條件>) {\n    <Some Code>  # 條件成立時執行\n}\n\n# if, else\nif (<條件>) {\n    <Some Code>  # <條件>成立時執行\n} else {\n    <Some Code>  # <條件>不成立時執行\n}\n\n# if, else if, else\nif (<條件1>) {\n    <Some Code>          # <條件1>成立時執行\n} else if ( <條件2> ) {\n    <Some Code>          # <條件1>不成立、<條件2>成立時執行\n} else {\n    <Some Code>          # <條件1>、<條件2>皆不成立時執行\n}"},{"path":"ch02.html","id":"wrap-up","chapter":"2 Base R (I) & 輔助工具","heading":"2.9 Wrap up: 句子產生器","text":"","code":"\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)\n\n# Randomly draw 2 subjects\nwho <- sample(1:4, size = 2)\n\n# Find out who is older\nage1 <- age[who[1]]\nage2 <- age[who[2]]\nif (age1 > age2) {\n    comparitive <- ' is older than '\n} else if (age1 < age2) {\n    comparitive <- ' is younger than '\n} else {\n    comparitive <- ' is as old as '\n}\n\n# Construct sentence\npaste0(name[who[1]], comparitive, name[who[2]])#> [1] \"piglet is younger than kai\""},{"path":"ch02.html","id":"r-markdown","chapter":"2 Base R (I) & 輔助工具","heading":"2.10 R Markdown","text":"使用前需先安裝 rmarkdown:\n\ninstall.packages('rmarkdown')使用前需先安裝 rmarkdown:R Markdown (.Rmd) 就像之前同學用來寫自我介紹的 Markdown 文件 (.md) 一樣是一種純文字格式。R Markdown 的語法其實只是 Markdown 的一種擴充：它新增了一些特殊的語法，讓使用者可以直接在 R Markdown 裡面撰寫程式碼，並透過 R 將這些程式碼的運算結果插入 R Markdown 的輸出文件當中。R Markdown (.Rmd) 就像之前同學用來寫自我介紹的 Markdown 文件 (.md) 一樣是一種純文字格式。R Markdown 的語法其實只是 Markdown 的一種擴充：它新增了一些特殊的語法，讓使用者可以直接在 R Markdown 裡面撰寫程式碼，並透過 R 將這些程式碼的運算結果插入 R Markdown 的輸出文件當中。knitr Code Chunk\n執行：由上至下執行\n後面的 chunk 可以讀取之前的 chunks 產生的變數\nknitr Code Chunk執行：由上至下執行後面的 chunk 可以讀取之前的 chunks 產生的變數(在 RStudio 使用 R Markdown)使用 RStudio 開啟 R Markdown (.Rmd) 時，Rmd 檔會出現在 Source Pane 讓使用者編輯使用 RStudio 開啟 R Markdown (.Rmd) 時，Rmd 檔會出現在 Source Pane 讓使用者編輯將 R Markdown (.Rmd) 輸出 (knit )成 HTML 檔 (.html):將 R Markdown (.Rmd) 輸出 (knit )成 HTML 檔 (.html):\nFigure 2.2: R Markdown document RStudio10.\n","code":"\ninstall.packages('rmarkdown')"},{"path":"ch02.html","id":"參考資源","chapter":"2 Base R (I) & 輔助工具","heading":"參考資源","text":"Grolemund, G. (2014). Hands-programming R\nR Objects (https://rstudio-education.github.io/hopr/r-objects)\nModifying Values (https://rstudio-education.github.io/hopr/modify)Grolemund, G. (2014). Hands-programming R\nR Objects (https://rstudio-education.github.io/hopr/r-objects)\nModifying Values (https://rstudio-education.github.io/hopr/modify)Xie, Y., Allaire, J., & Grolemund, G. (2019). R Markdown: Definitive GuideXie, Y., Allaire, J., & Grolemund, G. (2019). R Markdown: Definitive Guide","code":""},{"path":"ch03.html","id":"ch03","chapter":"3 Base R (II)","heading":"3 Base R (II)","text":"(投影片 /\n程式碼 /\n影片)","code":""},{"path":"ch03.html","id":"list","chapter":"3 Base R (II)","heading":"3.1 list","text":"vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存不同資料類型或是具有階層結構的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存不同資料類型或是具有階層結構的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。R 可以透過 list() 去製造出 list。list() 的使用方式很類似用來製造 vector 的 c()，但與 c() 不同的是，list()\n能使用不同的資料類型\n\nlist(TRUE, 1:3, \"Hello\")\n#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\n\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")\n#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"\n具有階層結構，亦即，list() 裡面可以放入另一個 list()\n\nlist(1.1, list(2.1, \"Hello\"))\n#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\"\nR 可以透過 list() 去製造出 list。list() 的使用方式很類似用來製造 vector 的 c()，但與 c() 不同的是，list()能使用不同的資料類型\n\nlist(TRUE, 1:3, \"Hello\")\n#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\n\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")\n#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"能使用不同的資料類型具有階層結構，亦即，list() 裡面可以放入另一個 list()\n\nlist(1.1, list(2.1, \"Hello\"))\n#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\"具有階層結構，亦即，list() 裡面可以放入另一個 list()","code":"\nlist(TRUE, 1:3, \"Hello\")#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"\nlist(1.1, list(2.1, \"Hello\"))#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\""},{"path":"ch03.html","id":"subsetting","chapter":"3 Base R (II)","heading":"3.1.1 Subsetting","text":"通常我們會習慣為 list 加上名字 (names)，幫助我們更容易處理這種比較複雜的資料結構通常我們會習慣為 list 加上名字 (names)，幫助我們更容易處理這種比較複雜的資料結構[]: 與 vector 一樣，我們可以透過 lst[<char vector names>]、lst[<integer vector>] 或 lst[<logical vector>] 去 subset list\n\npooh <- list(age = 20, single = FALSE, tags = c(\"ig\", \"selfie\"))\npooh['single']\n#> $single\n#> [1] FALSE\n\npooh[2:3]\n#> $single\n#> [1] FALSE\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n\npooh[c(TRUE, FALSE, TRUE)]\n#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"[]: 與 vector 一樣，我們可以透過 lst[<char vector names>]、lst[<integer vector>] 或 lst[<logical vector>] 去 subset list就像 vec[<vector>] 會回傳一部分的 vector (sub-vector)；lst[<vector>] 也會回傳一部分的 list (sub-list)。換言之，使用 [] 時，回傳值的資料結構不會改變。就像 vec[<vector>] 會回傳一部分的 vector (sub-vector)；lst[<vector>] 也會回傳一部分的 list (sub-list)。換言之，使用 [] 時，回傳值的資料結構不會改變。我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂裡面是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 []；欲取得 sub-list 裡面的值 (.e. 脫去外層的 list)，需使用 [[]]\n\n# 回傳 sub-list\ntypeof(pooh[\"tags\"])\npooh[\"tags\"]\n\n# 回傳 list 之內的「值」，在此為一個 char vector\ntypeof(pooh[[\"tags\"]])\npooh[[\"tags\"]]\n#> [1] \"list\"\n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"character\"\n#> [1] \"ig\"     \"selfie\"\nlst[[\"<name>\"]] 有另一種更簡便的寫法：lst$<name>, e.g. pooh[[\"tags\"]] 可改寫成 pooh$tags\n我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂裡面是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 []；欲取得 sub-list 裡面的值 (.e. 脫去外層的 list)，需使用 [[]]lst[[\"<name>\"]] 有另一種更簡便的寫法：lst$<name>, e.g. pooh[[\"tags\"]] 可改寫成 pooh$tags\nFigure 3.1: List train\n","code":"\npooh <- list(age = 20, single = FALSE, tags = c(\"ig\", \"selfie\"))\npooh['single']#> $single\n#> [1] FALSE\npooh[2:3]#> $single\n#> [1] FALSE\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\npooh[c(TRUE, FALSE, TRUE)]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n# 回傳 sub-list\ntypeof(pooh[\"tags\"])\npooh[\"tags\"]\n\n# 回傳 list 之內的「值」，在此為一個 char vector\ntypeof(pooh[[\"tags\"]])\npooh[[\"tags\"]]#> [1] \"list\"\n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"character\"\n#> [1] \"ig\"     \"selfie\""},{"path":"ch03.html","id":"nested-structure","chapter":"3 Base R (II)","heading":"3.1.2 Nested Structure","text":"","code":"\na_lst <- list(name = \"pooh\",\n              info = list(age = 20,\n                          tags = c(\"ig\", \"selfie\")))\n\n# Get \"selfie\"  \na_lst[['info']]\na_lst[['info']][['tags']]\na_lst[['info']][['tags']][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# Another way to get \"selfie\"\na_lst['info'][[1]]\na_lst['info'][[1]]['tags'][[1]]\na_lst['info'][[1]]['tags'][[1]][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# Yet another way to get \"selfie\"\na_lst[[2]]\na_lst[[2]][[2]]\na_lst[[2]][[2]][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# The most 'readable' way to get \"selfie\"\na_lst$info\na_lst$info$tags\na_lst$info$tags[2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\""},{"path":"ch03.html","id":"for-loop","chapter":"3 Base R (II)","heading":"3.2 for loop","text":"上週介紹的條件式 (-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。上週介紹的條件式 (-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。R 有 與 迴圈。一般而言，在資料分析時非常少會用到 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。R 有 與 迴圈。一般而言，在資料分析時非常少會用到 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。loop 的結構如下\n(<變數> <vector>) {\n    <code>\n}loop 的結構如下for loop 會使 {} 內的程式碼重複執行數次，其次數等於 <vector> 的長度；並且，在第 n 次開始執行 {} 內的程式碼前，會將 <vector> 裡的第 n 個元素指派給 <變數>。所以在第一次迴圈時，可透過 <變數> 取得 <vector> 中的第一個元素；在第二次迴圈時，可取得 <vector> 中的第二個元素；依此類推，最後一次迴圈則可以透過 <變數> 取得 <vector> 中的最後一個元素。loop 會使 {} 內的程式碼重複執行數次，其次數等於 <vector> 的長度；並且，在第 n 次開始執行 {} 內的程式碼前，會將 <vector> 裡的第 n 個元素指派給 <變數>。所以在第一次迴圈時，可透過 <變數> 取得 <vector> 中的第一個元素；在第二次迴圈時，可取得 <vector> 中的第二個元素；依此類推，最後一次迴圈則可以透過 <變數> 取得 <vector> 中的最後一個元素。","code":"for (<變數> in <vector>) {\n    <some code>\n}\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n  \nfor (word in vec) {\n    # Will execute 4 times, \n    # each time a new value from `vec` will be assigned to `word`\n    print(word)\n}#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\""},{"path":"ch03.html","id":"for-loop-的各種型態","chapter":"3 Base R (II)","heading":"3.2.1 for loop 的各種型態","text":"R 的 只有一種結構：每次疊代將 vector (或 list) 中的一個元素指派給變數 (<var> <vector>)。但因為 R 向量式程式語言的特性，R 的 迴圈很容易改寫成其它更方便的型態。有時候我們需要知道迴圈進行到 <vector> 的第幾個元素，這時候通常會使用 seq_along(<vector>) 去製造出與 <vector> 等長的整數序列 (e.g. seq_along(c('', 'b', 'c')) 會回傳 1 2 3)，如此我們便可知道進行到第幾次迴圈，也可透過 <vector>[] 取得與該次迴圈對應的元素。\n\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n(seq_along(vec)) {\n    print(paste(, vec[]))\n}\n#> [1] \"1 謝\"\n#> [1] \"2 老師\"\n#> [1] \"3 好\"\n#> [1] \"4 帥\"\n\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n(seq_along(vec)) {\n    print(vec[])\n\n    # Print `?` last loop\n    (== length(vec)) {\n        print('?')\n    }\n}\n#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\"\n#> [1] \"?\"有時候我們需要知道迴圈進行到 <vector> 的第幾個元素，這時候通常會使用 seq_along(<vector>) 去製造出與 <vector> 等長的整數序列 (e.g. seq_along(c('', 'b', 'c')) 會回傳 1 2 3)，如此我們便可知道進行到第幾次迴圈，也可透過 <vector>[] 取得與該次迴圈對應的元素。我們也可以透過 names() 在 loop 裡使用 <vector> 的 names 屬性：\n\nvec <- c(Monday = \"rainy\", Tuesday = \"cloudy\", Wednesday = \"sunny\")\n(name names(vec)) {\n    print(paste0(name, ' ', vec[name], '.'))\n}\n#> [1] \"Monday rainy.\"\n#> [1] \"Tuesday cloudy.\"\n#> [1] \"Wednesday sunny.\"我們也可以透過 names() 在 loop 裡使用 <vector> 的 names 屬性：常常我們會需要對 loop 有「更多的控制」。前面在 loop 中使用到條件式即是一個例子。但常常條件式本身的功能並不足夠：執行迴圈時，在符合特定條件下，有時候我們會希望能忽略一次迴圈中「所有尚未被執行的程式碼」，這時就會使用到 next:\n\n# 使用 next '忽略一次' 迴圈\n(1:10) {\n    (== 5) {\n        print(\"Skipping print() == 5\")\n        next\n    }\n    print()\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Skipping print() == 5\"\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10有時候我們會希望能忽略一次迴圈中「所有尚未被執行的程式碼」，這時就會使用到 next:有時我們需要跳出整個迴圈，亦即不再執行 loop 裡面的程式碼。這時就會使用到 break:\n\n# 使用 break 跳出整個迴圈\n(1:10) {\n    (== 5) {\n        print(\"Breaking loop\")\n        break\n    }\n    print()\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Breaking loop\"有時我們需要跳出整個迴圈，亦即不再執行 loop 裡面的程式碼。這時就會使用到 break:下方的程式碼能將多個檔案 (圖片) 重新命名 (並透過 next 忽略某些檔案)。有興趣者請下載原始碼，裡面有一個資料夾 dice/。執行此程式碼前，需將工作目錄設至 dice/ 資料夾。","code":"\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\nfor (i in seq_along(vec)) {\n    print(paste(i, vec[i]))\n}#> [1] \"1 謝\"\n#> [1] \"2 老師\"\n#> [1] \"3 好\"\n#> [1] \"4 帥\"\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\nfor (i in seq_along(vec)) {\n    print(vec[i])\n\n    # Print `?` in the last loop\n    if (i == length(vec)) {\n        print('?')\n    }\n}#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\"\n#> [1] \"?\"\nvec <- c(Monday = \"rainy\", Tuesday = \"cloudy\", Wednesday = \"sunny\")\nfor (name in names(vec)) {\n    print(paste0(name, ' was ', vec[name], '.'))\n}#> [1] \"Monday was rainy.\"\n#> [1] \"Tuesday was cloudy.\"\n#> [1] \"Wednesday was sunny.\"\n# 使用 next '忽略一次' 迴圈\nfor (i in 1:10) {\n    if (i == 5) {\n        print(\"Skipping print(i) if i == 5\")\n        next\n    }\n    print(i)\n}#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Skipping print(i) if i == 5\"\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10\n# 使用 break 跳出整個迴圈\nfor (i in 1:10) {\n    if (i == 5) {\n        print(\"Breaking out the for loop\")\n        break\n    }\n    print(i)\n}#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Breaking out the for loop\"\nfor (file in list.files()) {\n    # 忽略 `00_not_an_img.txt` 這個檔案\n    if (file == '00_not_an_img.txt') {\n        next\n    }\n    \n    file.rename(from = file, to = paste0('dice-', file))\n}"},{"path":"ch03.html","id":"實際應用修改檔案名稱","chapter":"3 Base R (II)","heading":"3.2.2 實際應用：修改檔案名稱","text":"下方的程式碼能將多個檔案 (圖片) 重新命名 (並透過 next 忽略某些檔案)。有興趣者請下載原始碼，裡面有一個資料夾 dice/。執行此程式碼前，需將工作目錄設至 dice/ 資料夾。","code":"\nfor (file in list.files()) {\n    # 忽略 `00_not_an_img.txt` 這個檔案\n    if (file == '00_not_an_img.txt') {\n        next\n    }\n    \n    file.rename(from = file, to = paste0('dice-', file))\n}"},{"path":"ch03.html","id":"wrap-upfor-loop-與-list","chapter":"3 Base R (II)","heading":"3.3 Wrap up：for loop 與 list","text":"上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人\n(“kai”, “pooh”, “tiger”, “piglet”)\n的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (name 與 age) 分開來儲存在獨立的 vector。\n\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人\n(“kai”, “pooh”, “tiger”, “piglet”)\n的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (name 與 age) 分開來儲存在獨立的 vector。對於這種彼此之間具有關聯的資料，一種更好的方式是將它們儲存在一起，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 list 去改寫上週的資料：\n\nmember <- list(\n    list(name = \"kai\", age = 40),\n    list(name = \"pooh\", age = 20),\n    list(name = \"tiger\", age = 18),\n    list(name = \"piglet\", age = 19)\n)\n\nmember\n#> [[1]]\n#> [[1]]$name\n#> [1] \"kai\"\n#> \n#> [[1]]$age\n#> [1] 40\n#> \n#> \n#> [[2]]\n#> [[2]]$name\n#> [1] \"pooh\"\n#> \n#> [[2]]$age\n#> [1] 20\n#> \n#> \n#> [[3]]\n#> [[3]]$name\n#> [1] \"tiger\"\n#> \n#> [[3]]$age\n#> [1] 18\n#> \n#> \n#> [[4]]\n#> [[4]]$name\n#> [1] \"piglet\"\n#> \n#> [[4]]$age\n#> [1] 19\n\n(person member) {\n    name <- person$name\n    age <- person$age\n\n    # 將組成句子的片語儲存於 char vector `phrases`\n    phrases <- c(name, \" \", age)\n    (age < 35) {\n        phrases[4] <- \", quite young\"\n    }\n\n    # 將各片語連接起來成為一個句子\n    sentence <- paste0(phrases,  collapse = '')\n\n    print(sentence)\n}\n#> [1] \"kai 40\"\n#> [1] \"pooh 20, quite young\"\n#> [1] \"tiger 18, quite young\"\n#> [1] \"piglet 19, quite young\"對於這種彼此之間具有關聯的資料，一種更好的方式是將它們儲存在一起，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 list 去改寫上週的資料：","code":"\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)\nmember <- list(\n    list(name = \"kai\", age = 40),\n    list(name = \"pooh\", age = 20),\n    list(name = \"tiger\", age = 18),\n    list(name = \"piglet\", age = 19)\n)\n\nmember#> [[1]]\n#> [[1]]$name\n#> [1] \"kai\"\n#> \n#> [[1]]$age\n#> [1] 40\n#> \n#> \n#> [[2]]\n#> [[2]]$name\n#> [1] \"pooh\"\n#> \n#> [[2]]$age\n#> [1] 20\n#> \n#> \n#> [[3]]\n#> [[3]]$name\n#> [1] \"tiger\"\n#> \n#> [[3]]$age\n#> [1] 18\n#> \n#> \n#> [[4]]\n#> [[4]]$name\n#> [1] \"piglet\"\n#> \n#> [[4]]$age\n#> [1] 19\nfor (person in member) {\n    name <- person$name\n    age <- person$age\n\n    # 將組成句子的片語儲存於 char vector `phrases`\n    phrases <- c(name, \" is \", age)\n    if (age < 35) {\n        phrases[4] <- \", which is quite young\"\n    }\n\n    # 將各片語連接起來成為一個句子\n    sentence <- paste0(phrases,  collapse = '')\n\n    print(sentence)\n}#> [1] \"kai is 40\"\n#> [1] \"pooh is 20, which is quite young\"\n#> [1] \"tiger is 18, which is quite young\"\n#> [1] \"piglet is 19, which is quite young\""},{"path":"ch03.html","id":"data-frame","chapter":"3 Base R (II)","heading":"3.4 data frame","text":"data frame 是 R 語言非常重要的資料結構，它造就了 R 強大的表格式資料處理能力data frame 是 R 語言非常重要的資料結構，它造就了 R 強大的表格式資料處理能力data frame 是一種二維的資料結構。這種資料結構基本上與我們熟悉的 Excel (或 google 試算表) 非常類似：\n\n\nFigure 3.2: data frame looks like Excel Spreadsheet\n\n\ndata frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)\ndata frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)\ndata frame 是一種二維的資料結構。這種資料結構基本上與我們熟悉的 Excel (或 google 試算表) 非常類似：\nFigure 3.2: data frame looks like Excel Spreadsheet\ndata frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)data frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)data frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)data frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)\nFigure 3.3: Data Frame\n我們可以使用 tibble 套件的 tibble()11 建立 data frame。上圖中的 data frame 例子即可由下方的程式碼所建立:\n\nlibrary(tibble)\n\ndf <- tibble(name = c(\"kai\", \"pooh\", \"tiger\", \"piglet\"),\n             age  = c(40, 20, 18, 19), \n             grad = c(FALSE, TRUE, FALSE, TRUE))\ndf\n#> # tibble: 4 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 kai       40 FALSE\n#> 2 pooh      20 TRUE \n#> 3 tiger     18 FALSE\n#> 4 piglet    19 TRUE\ntibble() 裡的每個 vector 對映到 data frame 中的一欄 (column)。因此 data frame 中不同欄的資料類型可能不同，但每一欄 (變項) 內的資料類型必須相同 (因為 vector 只能儲存相同的資料類型)。\n我們可以使用 tibble 套件的 tibble()11 建立 data frame。上圖中的 data frame 例子即可由下方的程式碼所建立:tibble() 裡的每個 vector 對映到 data frame 中的一欄 (column)。因此 data frame 中不同欄的資料類型可能不同，但每一欄 (變項) 內的資料類型必須相同 (因為 vector 只能儲存相同的資料類型)。下方的指令可用於檢視 data frame 的資訊\n\nnrow(df)   # number rows\nncol(df)   # number columns\ndim(df)    # 形狀 (num rows, num columns)\nnames(df)  # name column\n#> [1] 4\n#> [1] 3\n#> [1] 4 3\n#> [1] \"name\" \"age\"  \"grad\"\n\ntibble::glimpse(df)  # 關於 df 的各種資訊\n#> Rows: 4\n#> Columns: 3\n#> $ name <chr> \"kai\", \"pooh\", \"tiger\", \"piglet\"\n#> $ age  <dbl> 40, 20, 18, 19\n#> $ grad <lgl> FALSE, TRUE, FALSE, TRUE\n\nstr(df)              # 也可用 Base R 內建函數: str()\n#> tibble [4 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ name: chr [1:4] \"kai\" \"pooh\" \"tiger\" \"piglet\"\n#>  $ age : num [1:4] 40 20 18 19\n#>  $ grad: logi [1:4] FALSE TRUE FALSE TRUE\n\nView(df)   # View data frame RStudio source pane下方的指令可用於檢視 data frame 的資訊","code":"\nlibrary(tibble)\n\ndf <- tibble(name = c(\"kai\", \"pooh\", \"tiger\", \"piglet\"),\n             age  = c(40, 20, 18, 19), \n             grad = c(FALSE, TRUE, FALSE, TRUE))\ndf#> # A tibble: 4 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 kai       40 FALSE\n#> 2 pooh      20 TRUE \n#> 3 tiger     18 FALSE\n#> 4 piglet    19 TRUE\nnrow(df)   # number of rows\nncol(df)   # number of columns\ndim(df)    # 形狀 (num of rows, num of columns)\nnames(df)  # name of each column#> [1] 4\n#> [1] 3\n#> [1] 4 3\n#> [1] \"name\" \"age\"  \"grad\"\ntibble::glimpse(df)  # 關於 df 的各種資訊#> Rows: 4\n#> Columns: 3\n#> $ name <chr> \"kai\", \"pooh\", \"tiger\", \"piglet\"\n#> $ age  <dbl> 40, 20, 18, 19\n#> $ grad <lgl> FALSE, TRUE, FALSE, TRUE\nstr(df)              # 也可用 Base R 內建函數: str()#> tibble [4 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ name: chr [1:4] \"kai\" \"pooh\" \"tiger\" \"piglet\"\n#>  $ age : num [1:4] 40 20 18 19\n#>  $ grad: logi [1:4] FALSE TRUE FALSE TRUE\nView(df)   # View data frame in RStudio source pane"},{"path":"ch03.html","id":"subsetting-returning-a-data-frame","chapter":"3 Base R (II)","heading":"3.4.1 Subsetting: returning a data frame","text":"data frame 的篩選 (subsetting) 與 vector 和 list 類似，差別只在於 data frame 屬於二維的資料結構，因此需要提供 2 個 vector 進行資料的篩選：\ndf[<vector 1>, <vector 2>]\n在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。\n以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])\ndata frame 的篩選 (subsetting) 與 vector 和 list 類似，差別只在於 data frame 屬於二維的資料結構，因此需要提供 2 個 vector 進行資料的篩選：在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])","code":"df[<vector 1>, <vector 2>]\ndf[2, 1]#> # A tibble: 1 x 1\n#>   name \n#>   <chr>\n#> 1 pooh\ndf[2, 1:2]  # df[2, c(\"name\", \"age\")]#> # A tibble: 1 x 2\n#>   name    age\n#>   <chr> <dbl>\n#> 1 pooh     20\ndf[2, ]#> # A tibble: 1 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 pooh     20 TRUE"},{"path":"ch03.html","id":"subsetting-returning-a-vector","chapter":"3 Base R (II)","heading":"3.4.2 Subsetting: returning a vector","text":"若想要從 data frame 裡面篩選出 vector (取得「火車車廂」內的值)，則要使用之前提過的 $ 或 [[]]:\n\ndf[[2]]      # df[[<column_index>]]\ndf[[\"age\"]]  # df[[\"<column_name>\"]]\ndf$age       # df$<column_name>, 最常見\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19若想要從 data frame 裡面篩選出 vector (取得「火車車廂」內的值)，則要使用之前提過的 $ 或 [[]]:篩選 data frame 而回傳 vector 是個很實用的技巧，因為我們可以使用這個回傳的 vector 當作我們進一步篩選 data frame 的依據，例如：\n\nover19 <- df$age > 19  \nover19\n#> [1]  TRUE  TRUE FALSE FALSE\n\n# subset df obs. 19\ndf[over19, ]\n#> # tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\n\n# subset df obs. equal 19\ndf[!over19, ]\n#> # tibble: 2 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 tiger     18 FALSE\n#> 2 piglet    19 TRUE\n\n# 合併起來寫 (最常見的寫法，但比較難讀懂)\ndf[df$age > 19, ]\n#> # tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE篩選 data frame 而回傳 vector 是個很實用的技巧，因為我們可以使用這個回傳的 vector 當作我們進一步篩選 data frame 的依據，例如：透過這個技巧，R 能幫助我們快速篩選出需要的資料，例如，我們可以結合 age 與 grad 兩個變項，篩選出「小於 20 歲且為研究所學生」的 data frame:\n\ndf[(df$age < 20) & (df$grad), ]\n#> # tibble: 1 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 piglet    19 TRUE透過這個技巧，R 能幫助我們快速篩選出需要的資料，例如，我們可以結合 age 與 grad 兩個變項，篩選出「小於 20 歲且為研究所學生」的 data frame:","code":"\ndf[[2]]      # df[[<column_index>]]\ndf[[\"age\"]]  # df[[\"<column_name>\"]]\ndf$age       # df$<column_name>, 最常見#> [1] 40 20 18 19\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19\nover19 <- df$age > 19  \nover19#> [1]  TRUE  TRUE FALSE FALSE\n# subset df with obs. over 19\ndf[over19, ]#> # A tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\n# subset df with obs. below or equal 19\ndf[!over19, ]#> # A tibble: 2 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 tiger     18 FALSE\n#> 2 piglet    19 TRUE\n# 合併起來寫 (最常見的寫法，但比較難讀懂)\ndf[df$age > 19, ]#> # A tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\ndf[(df$age < 20) & (df$grad), ]#> # A tibble: 1 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 piglet    19 TRUE"},{"path":"ch04.html","id":"ch04","chapter":"4 Data Frame 處理：dplyr","heading":"4 Data Frame 處理：dplyr","text":"(投影片 /\n程式碼 /\n影片)material largely based Garrett Grolemund’s introduction dplyr","code":""},{"path":"ch04.html","id":"why-dplyr","chapter":"4 Data Frame 處理：dplyr","heading":"4.1 Why dplyr?","text":"上週介紹過篩選 data frame 的方法：df[<vector 1>, <vector 2>]。但這種方法有一個缺點：隨著篩選條件越來越多，篩選 data frame 的指令會越來越複雜，變得難以閱讀，例如:\n\nlibrary(tibble)\ndf <- as_tibble(iris)\n\n# long take understand command ?\ndf[(df$Species == \"setosa\") & (df$Sepal.Length < 5.8), c(\"Species\", \"Sepal.Width\")]\n#> # tibble: 49 x 2\n#>    Species Sepal.Width\n#>    <fct>         <dbl>\n#>  1 setosa          3.5\n#>  2 setosa          3  \n#>  3 setosa          3.2\n#>  4 setosa          3.1\n#>  5 setosa          3.6\n#>  6 setosa          3.9\n#>  7 setosa          3.4\n#>  8 setosa          3.4\n#>  9 setosa          2.9\n#> 10 setosa          3.1\n#> # … 39 rows上週介紹過篩選 data frame 的方法：df[<vector 1>, <vector 2>]。但這種方法有一個缺點：隨著篩選條件越來越多，篩選 data frame 的指令會越來越複雜，變得難以閱讀，例如:套件 dplyr 目的就是為了使這個過程變得更加容易：讓處理 data frame 的指令變得直覺易懂。套件 dplyr 目的就是為了使這個過程變得更加容易：讓處理 data frame 的指令變得直覺易懂。","code":"\nlibrary(tibble)\ndf <- as_tibble(iris)\n\n# How long does it take to understand the command below?\ndf[(df$Species == \"setosa\") & (df$Sepal.Length < 5.8), c(\"Species\", \"Sepal.Width\")]#> # A tibble: 49 x 2\n#>    Species Sepal.Width\n#>    <fct>         <dbl>\n#>  1 setosa          3.5\n#>  2 setosa          3  \n#>  3 setosa          3.2\n#>  4 setosa          3.1\n#>  5 setosa          3.6\n#>  6 setosa          3.9\n#>  7 setosa          3.4\n#>  8 setosa          3.4\n#>  9 setosa          2.9\n#> 10 setosa          3.1\n#> # … with 39 more rows"},{"path":"ch04.html","id":"讀取表格式資料-.csv","chapter":"4 Data Frame 處理：dplyr","heading":"4.2 讀取表格式資料 (.csv)","text":"可使用 RStudio Environment Pane  >  Import Dataset  >  Text (readr)...，或直接使用指令：\n\nbabynames <- readr::read_csv('babynames.csv')\nbabynames\n#> # tibble: 177,780 x 5\n#>     year sex   name        n   prop\n#>    <dbl> <chr> <chr>   <dbl>  <dbl>\n#>  1  1880 M     John     9655 0.0815\n#>  2  1880 M     William  9532 0.0805\n#>  3  1880 M     James    5927 0.0501\n#>  4  1880 M     Charles  5348 0.0452\n#>  5  1880 M     George   5126 0.0433\n#>  6  1880 M     Frank    3242 0.0274\n#>  7  1880 M     Joseph   2632 0.0222\n#>  8  1880 M     Thomas   2534 0.0214\n#>  9  1880 M     Henry    2444 0.0206\n#> 10  1880 M     Robert   2415 0.0204\n#> # … 177,770 rows\n如此便會將外部檔案讀入成 tibble (data frame)可使用 RStudio Environment Pane  >  Import Dataset  >  Text (readr)...，或直接使用指令：如此便會將外部檔案讀入成 tibble (data frame)","code":"\nbabynames <- readr::read_csv('babynames.csv')\nbabynames#> # A tibble: 177,780 x 5\n#>     year sex   name        n   prop\n#>    <dbl> <chr> <chr>   <dbl>  <dbl>\n#>  1  1880 M     John     9655 0.0815\n#>  2  1880 M     William  9532 0.0805\n#>  3  1880 M     James    5927 0.0501\n#>  4  1880 M     Charles  5348 0.0452\n#>  5  1880 M     George   5126 0.0433\n#>  6  1880 M     Frank    3242 0.0274\n#>  7  1880 M     Joseph   2632 0.0222\n#>  8  1880 M     Thomas   2534 0.0214\n#>  9  1880 M     Henry    2444 0.0206\n#> 10  1880 M     Robert   2415 0.0204\n#> # … with 177,770 more rows"},{"path":"ch04.html","id":"functions-for-isolating-data-in-dplyr","chapter":"4 Data Frame 處理：dplyr","heading":"4.3 Functions for “isolating data” in dplyr","text":"dplyr 有 2 個重要的函數可以用來取代上週講過得 [<vector 1> , <vector 2>]\nselect(): 篩選出 data frame 中的變項 (variables) (.e. columns data frame)\nfilter(): 篩選出 data frame 中特定的觀察值 (observations) (.e. rows data frame)\nselect() 與 filter() 分別取代了 [<vector 1> , <vector 2>] 之中的 vector 2 與 vector 1 的功能。除此之外，dplyr 還有 arrange() 可以用來將觀察值依據某些變項進行排序。\nselect(): 篩選出 data frame 中的變項 (variables) (.e. columns data frame)filter(): 篩選出 data frame 中特定的觀察值 (observations) (.e. rows data frame)select() 與 filter() 分別取代了 [<vector 1> , <vector 2>] 之中的 vector 2 與 vector 1 的功能。除此之外，dplyr 還有 arrange() 可以用來將觀察值依據某些變項進行排序。","code":""},{"path":"ch04.html","id":"select-篩選出特定變項","chapter":"4 Data Frame 處理：dplyr","heading":"4.4 select(): 篩選出特定變項","text":"\nFigure 4.1: 篩選出 babynames 中的 name 與 prop 變項。\n","code":"\nlibrary(dplyr)\n\n# select(<data frame>, <variable name in df>, <variable name in df>, ...)\nselect(babynames, name, prop)  # eqivalent to babynames[, c(\"name\", \"prop\")]#> # A tibble: 177,780 x 2\n#>    name      prop\n#>    <chr>    <dbl>\n#>  1 John    0.0815\n#>  2 William 0.0805\n#>  3 James   0.0501\n#>  4 Charles 0.0452\n#>  5 George  0.0433\n#>  6 Frank   0.0274\n#>  7 Joseph  0.0222\n#>  8 Thomas  0.0214\n#>  9 Henry   0.0206\n#> 10 Robert  0.0204\n#> # … with 177,770 more rows"},{"path":"ch04.html","id":"helpers","chapter":"4 Data Frame 處理：dplyr","heading":"4.4.1 helpers","text":"dplyr 額外提供了一些函數，方便使用者依據變項名稱的特性去篩選變項：\n\niris_ <- as_tibble(iris)\nselect(iris_, starts_with('Sepal'))\n#> # tibble: 150 x 2\n#>    Sepal.Length Sepal.Width\n#>           <dbl>       <dbl>\n#>  1          5.1         3.5\n#>  2          4.9         3  \n#>  3          4.7         3.2\n#>  4          4.6         3.1\n#>  5          5           3.6\n#>  6          5.4         3.9\n#>  7          4.6         3.4\n#>  8          5           3.4\n#>  9          4.4         2.9\n#> 10          4.9         3.1\n#> # … 140 rows\n\nselect(iris_, ends_with('Width'))\n#> # tibble: 150 x 2\n#>    Sepal.Width Petal.Width\n#>          <dbl>       <dbl>\n#>  1         3.5         0.2\n#>  2         3           0.2\n#>  3         3.2         0.2\n#>  4         3.1         0.2\n#>  5         3.6         0.2\n#>  6         3.9         0.4\n#>  7         3.4         0.3\n#>  8         3.4         0.2\n#>  9         2.9         0.2\n#> 10         3.1         0.1\n#> # … 140 rows\n\nselect(iris_, contains('.'))\n#> # tibble: 150 x 4\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width\n#>           <dbl>       <dbl>        <dbl>       <dbl>\n#>  1          5.1         3.5          1.4         0.2\n#>  2          4.9         3            1.4         0.2\n#>  3          4.7         3.2          1.3         0.2\n#>  4          4.6         3.1          1.5         0.2\n#>  5          5           3.6          1.4         0.2\n#>  6          5.4         3.9          1.7         0.4\n#>  7          4.6         3.4          1.4         0.3\n#>  8          5           3.4          1.5         0.2\n#>  9          4.4         2.9          1.4         0.2\n#> 10          4.9         3.1          1.5         0.1\n#> # … 140 rows\n\ndf <- tibble(x_1 = 1:10, x_2 = 11:20, x_3 = 21:30, x_4 = 31:40, x_5 = 41:50)\nselect(df, num_range(\"x_\", 2:4))\n#> # tibble: 10 x 3\n#>      x_2   x_3   x_4\n#>    <int> <int> <int>\n#>  1    11    21    31\n#>  2    12    22    32\n#>  3    13    23    33\n#>  4    14    24    34\n#>  5    15    25    35\n#>  6    16    26    36\n#>  7    17    27    37\n#>  8    18    28    38\n#>  9    19    29    39\n#> 10    20    30    40\n\n# can still quote variable names\nselect(df, \"x_1\", \"x_2\", \"x_3\")\n#> # tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30\n\n# `select()` can mixed base R's `paste0()`\nselect(df, paste0(\"x_\", 1:3))\n#> # tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30dplyr 額外提供了一些函數，方便使用者依據變項名稱的特性去篩選變項：","code":"\niris_ <- as_tibble(iris)\nselect(iris_, starts_with('Sepal'))#> # A tibble: 150 x 2\n#>    Sepal.Length Sepal.Width\n#>           <dbl>       <dbl>\n#>  1          5.1         3.5\n#>  2          4.9         3  \n#>  3          4.7         3.2\n#>  4          4.6         3.1\n#>  5          5           3.6\n#>  6          5.4         3.9\n#>  7          4.6         3.4\n#>  8          5           3.4\n#>  9          4.4         2.9\n#> 10          4.9         3.1\n#> # … with 140 more rows\nselect(iris_, ends_with('Width'))#> # A tibble: 150 x 2\n#>    Sepal.Width Petal.Width\n#>          <dbl>       <dbl>\n#>  1         3.5         0.2\n#>  2         3           0.2\n#>  3         3.2         0.2\n#>  4         3.1         0.2\n#>  5         3.6         0.2\n#>  6         3.9         0.4\n#>  7         3.4         0.3\n#>  8         3.4         0.2\n#>  9         2.9         0.2\n#> 10         3.1         0.1\n#> # … with 140 more rows\nselect(iris_, contains('.'))#> # A tibble: 150 x 4\n#>    Sepal.Length Sepal.Width Petal.Length Petal.Width\n#>           <dbl>       <dbl>        <dbl>       <dbl>\n#>  1          5.1         3.5          1.4         0.2\n#>  2          4.9         3            1.4         0.2\n#>  3          4.7         3.2          1.3         0.2\n#>  4          4.6         3.1          1.5         0.2\n#>  5          5           3.6          1.4         0.2\n#>  6          5.4         3.9          1.7         0.4\n#>  7          4.6         3.4          1.4         0.3\n#>  8          5           3.4          1.5         0.2\n#>  9          4.4         2.9          1.4         0.2\n#> 10          4.9         3.1          1.5         0.1\n#> # … with 140 more rows\ndf <- tibble(x_1 = 1:10, x_2 = 11:20, x_3 = 21:30, x_4 = 31:40, x_5 = 41:50)\nselect(df, num_range(\"x_\", 2:4))#> # A tibble: 10 x 3\n#>      x_2   x_3   x_4\n#>    <int> <int> <int>\n#>  1    11    21    31\n#>  2    12    22    32\n#>  3    13    23    33\n#>  4    14    24    34\n#>  5    15    25    35\n#>  6    16    26    36\n#>  7    17    27    37\n#>  8    18    28    38\n#>  9    19    29    39\n#> 10    20    30    40\n# You can still quote the variable names\nselect(df, \"x_1\", \"x_2\", \"x_3\")#> # A tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30\n# So `select()` can be mixed with base R's `paste0()`\nselect(df, paste0(\"x_\", 1:3))#> # A tibble: 10 x 3\n#>      x_1   x_2   x_3\n#>    <int> <int> <int>\n#>  1     1    11    21\n#>  2     2    12    22\n#>  3     3    13    23\n#>  4     4    14    24\n#>  5     5    15    25\n#>  6     6    16    26\n#>  7     7    17    27\n#>  8     8    18    28\n#>  9     9    19    29\n#> 10    10    20    30"},{"path":"ch04.html","id":"filter-篩選出特定觀察值","chapter":"4 Data Frame 處理：dplyr","heading":"4.5 filter(): 篩選出特定觀察值","text":"\nFigure 4.2: 篩選出 babynames 中的 name 為 “Garrett” 的觀察值。\n","code":"\n# filter(<data frame>, <logical test on variable>, <logical test on variable>, ...)\nfilter(babynames, name == \"Garrett\")#> # A tibble: 13 x 5\n#>     year sex   name        n       prop\n#>    <dbl> <chr> <chr>   <dbl>      <dbl>\n#>  1  1880 M     Garrett    13 0.000110  \n#>  2  1881 M     Garrett     7 0.0000646 \n#>  3  1882 M     Garrett    15 0.000123  \n#>  4  1883 M     Garrett    13 0.000116  \n#>  5  1884 M     Garrett    15 0.000122  \n#>  6  1885 M     Garrett     9 0.0000776 \n#>  7  2013 M     Garrett  1613 0.000800  \n#>  8  2013 F     Garrett     5 0.0000026 \n#>  9  2014 M     Garrett  1562 0.000764  \n#> 10  2014 F     Garrett     6 0.00000307\n#> 11  2015 M     Garrett  1349 0.000662  \n#> 12  2016 M     Garrett  1146 0.000568  \n#> 13  2017 M     Garrett  1056 0.000538\nfilter(babynames, (name == \"Garrett\") & (year < 1885))#> # A tibble: 5 x 5\n#>    year sex   name        n      prop\n#>   <dbl> <chr> <chr>   <dbl>     <dbl>\n#> 1  1880 M     Garrett    13 0.000110 \n#> 2  1881 M     Garrett     7 0.0000646\n#> 3  1882 M     Garrett    15 0.000123 \n#> 4  1883 M     Garrett    13 0.000116 \n#> 5  1884 M     Garrett    15 0.000122\nfilter(babynames, name == \"Garrett\", year < 1885)  # equivalent to the previous command#> # A tibble: 5 x 5\n#>    year sex   name        n      prop\n#>   <dbl> <chr> <chr>   <dbl>     <dbl>\n#> 1  1880 M     Garrett    13 0.000110 \n#> 2  1881 M     Garrett     7 0.0000646\n#> 3  1882 M     Garrett    15 0.000123 \n#> 4  1883 M     Garrett    13 0.000116 \n#> 5  1884 M     Garrett    15 0.000122"},{"path":"ch04.html","id":"arrange-重新排序觀察值","chapter":"4 Data Frame 處理：dplyr","heading":"4.6 arrange(): 重新排序觀察值","text":"\nFigure 4.3: 依據變項 n 的大小由小至大排序 babynames 中的觀察值。\nPop quiz 3: answer","code":"\n#arrange(<data frame>, <variable name in df>, <variable name in df>, ...)\narrange(babynames, n)#> # A tibble: 177,780 x 5\n#>     year sex   name         n      prop\n#>    <dbl> <chr> <chr>    <dbl>     <dbl>\n#>  1  1880 M     Ab           5 0.0000422\n#>  2  1880 M     Abbott       5 0.0000422\n#>  3  1880 M     Agustus      5 0.0000422\n#>  4  1880 M     Albertus     5 0.0000422\n#>  5  1880 M     Almer        5 0.0000422\n#>  6  1880 M     Alphonso     5 0.0000422\n#>  7  1880 M     Alvia        5 0.0000422\n#>  8  1880 M     Artie        5 0.0000422\n#>  9  1880 M     Arvid        5 0.0000422\n#> 10  1880 M     Ashby        5 0.0000422\n#> # … with 177,770 more rows\n# 由大至小排序 (降冪)\narrange(babynames, desc(n))#> # A tibble: 177,780 x 5\n#>     year sex   name       n    prop\n#>    <dbl> <chr> <chr>  <dbl>   <dbl>\n#>  1  2013 F     Sophia 21213 0.0110 \n#>  2  2013 F     Emma   20936 0.0109 \n#>  3  2014 F     Emma   20924 0.0107 \n#>  4  2015 F     Emma   20435 0.0105 \n#>  5  2014 F     Olivia 19791 0.0101 \n#>  6  2017 F     Emma   19738 0.0105 \n#>  7  2015 F     Olivia 19669 0.0101 \n#>  8  2015 M     Noah   19613 0.00962\n#>  9  2016 F     Emma   19471 0.0101 \n#> 10  2016 F     Olivia 19327 0.0100 \n#> # … with 177,770 more rows\n# Order first by `year` then by `name`\narrange(babynames, year, name)#> # A tibble: 177,780 x 5\n#>     year sex   name        n      prop\n#>    <dbl> <chr> <chr>   <dbl>     <dbl>\n#>  1  1880 M     Aaron     102 0.000861 \n#>  2  1880 M     Ab          5 0.0000422\n#>  3  1880 F     Abbie      71 0.000727 \n#>  4  1880 M     Abbott      5 0.0000422\n#>  5  1880 F     Abby        6 0.0000615\n#>  6  1880 M     Abe        50 0.000422 \n#>  7  1880 M     Abel        9 0.0000760\n#>  8  1880 F     Abigail    12 0.000123 \n#>  9  1880 M     Abner      27 0.000228 \n#> 10  1880 M     Abraham    81 0.000684 \n#> # … with 177,770 more rows\n# Order first by `name` then by `year`\narrange(babynames, name, year)#> # A tibble: 177,780 x 5\n#>     year sex   name      n       prop\n#>    <dbl> <chr> <chr> <dbl>      <dbl>\n#>  1  2013 M     Aaban    14 0.00000694\n#>  2  2014 M     Aaban    16 0.00000783\n#>  3  2015 M     Aaban    15 0.00000736\n#>  4  2016 M     Aaban     9 0.00000446\n#>  5  2017 M     Aaban    11 0.0000056 \n#>  6  2014 F     Aabha     9 0.00000461\n#>  7  2015 F     Aabha     7 0.0000036 \n#>  8  2016 F     Aabha     7 0.00000363\n#>  9  2016 M     Aabid     5 0.00000248\n#> 10  2016 M     Aabir     5 0.00000248\n#> # … with 177,770 more rows\ngirls2017 <- filter(babynames, year == 2017, sex == \"F\")\ngirls2017 <- select(girls2017, name, n)\ngirls2017 <- arrange(girls2017, desc(n))\ngirls2017"},{"path":"ch04.html","id":"connecting-multiple-dplyr-functions-together","chapter":"4 Data Frame 處理：dplyr","heading":"4.7 %>%: Connecting multiple dplyr functions together","text":"dplyr 的函數一次只能做一件事情:select() 只能用來篩選變項、filter() 只能用來篩選觀察值、arrange() 只能用來排序資料。但資料整理的過程中往往需要一次做很多事情，例如，可能需要在篩選完觀察值之後再進行排序。如果每次呼叫完一個函數就必須將結果儲存在一個變項，會讓整理資料的過程變得很麻煩，例如：\n\ngirls2017 <- filter(babynames, year == 2017, sex == \"F\")\ngirls2017 <- select(girls2017, name, n)\ngirls2017 <- arrange(girls2017, desc(n))\ngirls2017\n#> # tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … 18,299 rowsdplyr 的函數一次只能做一件事情:select() 只能用來篩選變項、filter() 只能用來篩選觀察值、arrange() 只能用來排序資料。但資料整理的過程中往往需要一次做很多事情，例如，可能需要在篩選完觀察值之後再進行排序。如果每次呼叫完一個函數就必須將結果儲存在一個變項，會讓整理資料的過程變得很麻煩，例如：dplyr (精確地說是 magrittr) 因此提供了一種特殊的 binary operator %>%，讓使用者可以將位在 %>% 左側之表達式的執行結果 (回傳值) 做為位在 %>% 右側之函數的第一個輸入值 (引數, argument)：\n\n# Two equivalent expressions\nfilter(babynames, year == 2017, sex == \"F\")\n\ncat('\\n\\n')  # 讓印出結果比較好看\n\nbabynames %>% filter(year == 2017, sex == \"F\")\n#> # tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … 18,299 rows\n#> \n#> \n#> # tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … 18,299 rows\n如此便可將整理資料的過程改寫成一條「由一個個函數串成的」指令，如下\n\nbabynames %>% \n    filter(year == 2017, sex == \"F\") %>% \n    select(name, n) %>%\n    arrange(desc(n))\n#> # tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … 18,299 rowsdplyr (精確地說是 magrittr) 因此提供了一種特殊的 binary operator %>%，讓使用者可以將位在 %>% 左側之表達式的執行結果 (回傳值) 做為位在 %>% 右側之函數的第一個輸入值 (引數, argument)：如此便可將整理資料的過程改寫成一條「由一個個函數串成的」指令，如下","code":"\ngirls2017 <- filter(babynames, year == 2017, sex == \"F\")\ngirls2017 <- select(girls2017, name, n)\ngirls2017 <- arrange(girls2017, desc(n))\ngirls2017#> # A tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … with 18,299 more rows\n# Two equivalent expressions\nfilter(babynames, year == 2017, sex == \"F\")\n\ncat('\\n\\n')  # 讓印出結果比較好看\n\nbabynames %>% filter(year == 2017, sex == \"F\")#> # A tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … with 18,299 more rows\n#> \n#> \n#> # A tibble: 18,309 x 5\n#>     year sex   name          n    prop\n#>    <dbl> <chr> <chr>     <dbl>   <dbl>\n#>  1  2017 F     Emma      19738 0.0105 \n#>  2  2017 F     Olivia    18632 0.00994\n#>  3  2017 F     Ava       15902 0.00848\n#>  4  2017 F     Isabella  15100 0.00805\n#>  5  2017 F     Sophia    14831 0.00791\n#>  6  2017 F     Mia       13437 0.00717\n#>  7  2017 F     Charlotte 12893 0.00688\n#>  8  2017 F     Amelia    11800 0.00629\n#>  9  2017 F     Evelyn    10675 0.00569\n#> 10  2017 F     Abigail   10551 0.00563\n#> # … with 18,299 more rows\nbabynames %>% \n    filter(year == 2017, sex == \"F\") %>% \n    select(name, n) %>%\n    arrange(desc(n))#> # A tibble: 18,309 x 2\n#>    name          n\n#>    <chr>     <dbl>\n#>  1 Emma      19738\n#>  2 Olivia    18632\n#>  3 Ava       15902\n#>  4 Isabella  15100\n#>  5 Sophia    14831\n#>  6 Mia       13437\n#>  7 Charlotte 12893\n#>  8 Amelia    11800\n#>  9 Evelyn    10675\n#> 10 Abigail   10551\n#> # … with 18,299 more rows"},{"path":"ch04.html","id":"functions-for-deriving-information-in-dplyr","chapter":"4 Data Frame 處理：dplyr","heading":"4.8 Functions for “deriving information” in dplyr","text":"上文介紹的內容是關於「如何篩選或排序既有的資料」。但有時候，我們需要從既有的資料去產出新的資料，例如根據既有資料的某些變項計算出新的變項，或是對既有資料做出一些摘要統計。面對這些需求，dplyr 提供了 2 個重要的函數：\nmutate(): 在 data frame 裡建立一個新的變項\nsummarise(): 對 data frame 裡的變項進行摘要，例如，計算某個變項的算術平均數、最大(小)值、變異數等\ngroup_by() 是 dplyr 中常與 summarise() 搭配使用的函數，其功能是將觀察值依據某些「類別變項」進行分類，如此 summarise() 就可依據分組後的結果去計算出各個組別內變項的摘要。例如，我們可以先使用 group_by() 將 babynames 的觀察值依據性別 (sex) 進行分類，再使用 summarise() 計算出這兩個性別的姓名 (name) 的數量。\n\nmutate(): 在 data frame 裡建立一個新的變項summarise(): 對 data frame 裡的變項進行摘要，例如，計算某個變項的算術平均數、最大(小)值、變異數等\ngroup_by() 是 dplyr 中常與 summarise() 搭配使用的函數，其功能是將觀察值依據某些「類別變項」進行分類，如此 summarise() 就可依據分組後的結果去計算出各個組別內變項的摘要。例如，我們可以先使用 group_by() 將 babynames 的觀察值依據性別 (sex) 進行分類，再使用 summarise() 計算出這兩個性別的姓名 (name) 的數量。\ngroup_by() 是 dplyr 中常與 summarise() 搭配使用的函數，其功能是將觀察值依據某些「類別變項」進行分類，如此 summarise() 就可依據分組後的結果去計算出各個組別內變項的摘要。例如，我們可以先使用 group_by() 將 babynames 的觀察值依據性別 (sex) 進行分類，再使用 summarise() 計算出這兩個性別的姓名 (name) 的數量。","code":""},{"path":"ch04.html","id":"mutate-建立新變項","chapter":"4 Data Frame 處理：dplyr","heading":"4.9 mutate(): 建立新變項","text":"\nFigure 4.4: 依據變項 prop 製造新變項 percent。\nmutate() 背後運作的原理是 R 的向量式運算，亦即，它是以一個變項 (.e. 向量) 當作操作的單元。因此，用於 mutate() 內的函數必須是所謂的 “vectorized function”：vectorized function 是指可接受一個或多個 vector 當作輸入值，並且會回傳長度相等的 vector的函數。","code":"\nbabynames %>% mutate(percent = prop*100)#> # A tibble: 177,780 x 6\n#>     year sex   name        n   prop percent\n#>    <dbl> <chr> <chr>   <dbl>  <dbl>   <dbl>\n#>  1  1880 M     John     9655 0.0815    8.15\n#>  2  1880 M     William  9532 0.0805    8.05\n#>  3  1880 M     James    5927 0.0501    5.01\n#>  4  1880 M     Charles  5348 0.0452    4.52\n#>  5  1880 M     George   5126 0.0433    4.33\n#>  6  1880 M     Frank    3242 0.0274    2.74\n#>  7  1880 M     Joseph   2632 0.0222    2.22\n#>  8  1880 M     Thomas   2534 0.0214    2.14\n#>  9  1880 M     Henry    2444 0.0206    2.06\n#> 10  1880 M     Robert   2415 0.0204    2.04\n#> # … with 177,770 more rows\nbabynames %>% mutate(sex2 = if_else(sex == \"F\", \"female\", \"male\"))#> # A tibble: 177,780 x 6\n#>     year sex   name        n   prop sex2 \n#>    <dbl> <chr> <chr>   <dbl>  <dbl> <chr>\n#>  1  1880 M     John     9655 0.0815 male \n#>  2  1880 M     William  9532 0.0805 male \n#>  3  1880 M     James    5927 0.0501 male \n#>  4  1880 M     Charles  5348 0.0452 male \n#>  5  1880 M     George   5126 0.0433 male \n#>  6  1880 M     Frank    3242 0.0274 male \n#>  7  1880 M     Joseph   2632 0.0222 male \n#>  8  1880 M     Thomas   2534 0.0214 male \n#>  9  1880 M     Henry    2444 0.0206 male \n#> 10  1880 M     Robert   2415 0.0204 male \n#> # … with 177,770 more rows"},{"path":"ch04.html","id":"summarise-對變項進行摘要","chapter":"4 Data Frame 處理：dplyr","heading":"4.10 summarise(): 對變項進行摘要","text":"\nFigure 4.5: 對變項 n 進行摘要 (計算總和與最大值)，並將摘要的結果儲存於兩個新變項 total 與 max。\n","code":"\nbabynames %>% summarise(total = sum(n), max = max(n))#> # A tibble: 1 x 2\n#>      total   max\n#>      <dbl> <dbl>\n#> 1 19538552 21213\nbabynames %>% summarise(num_of_rows = n(), num_of_names = n_distinct(name))#> # A tibble: 1 x 2\n#>   num_of_rows num_of_names\n#>         <int>        <int>\n#> 1      177780        45953"},{"path":"ch04.html","id":"group_by-先分類再摘要","chapter":"4 Data Frame 處理：dplyr","heading":"4.10.1 group_by(): 先分類再摘要","text":"\nFigure 4.6: 先將 pollution 的觀察值依據變項 city 分成 3 組，再各自對 3 組進行摘要 (計算污染量平均與總和) 求得之摘要表。\n","code":"\npollution <- tibble::tribble(\n     ~city,   ~size,   ~amount, \n  \"New York\", \"large\",      23,\n  \"New York\", \"small\",      14,\n  \"London\",   \"large\",      22,\n  \"London\",   \"small\",      16,\n  \"Beijing\",  \"large\",      121,\n  \"Beijing\",  \"small\",      56\n)\npollution#> # A tibble: 6 x 3\n#>   city     size  amount\n#>   <chr>    <chr>  <dbl>\n#> 1 New York large     23\n#> 2 New York small     14\n#> 3 London   large     22\n#> 4 London   small     16\n#> 5 Beijing  large    121\n#> 6 Beijing  small     56\npollution %>% \n  group_by(city) %>% \n    summarise(mean = mean(amount), \n              sum = sum(amount),\n              count = n())#> # A tibble: 3 x 4\n#>   city      mean   sum count\n#>   <chr>    <dbl> <dbl> <int>\n#> 1 Beijing   88.5   177     2\n#> 2 London    19      38     2\n#> 3 New York  18.5    37     2\npollution %>% \n  group_by(city, size) %>% \n  summarise(mean = mean(amount),\n            sum = sum(amount),\n            count = n())#> # A tibble: 6 x 5\n#> # Groups:   city [3]\n#>   city     size   mean   sum count\n#>   <chr>    <chr> <dbl> <dbl> <int>\n#> 1 Beijing  large   121   121     1\n#> 2 Beijing  small    56    56     1\n#> 3 London   large    22    22     1\n#> 4 London   small    16    16     1\n#> 5 New York large    23    23     1\n#> 6 New York small    14    14     1"},{"path":"ch04.html","id":"參考資源-1","chapter":"4 Data Frame 處理：dplyr","heading":"4.11 參考資源","text":"Wickham, H., & Grolemund, G. (2017). R Data Science: Data transformationGrolemund, G. (2019). Transform Data dplyr","code":""},{"path":"ch05.html","id":"ch05","chapter":"5 視覺化：ggplot2","heading":"5 視覺化：ggplot2","text":"(投影片 /\n影片)material based Garrett Grolemund’s introduction ggplot2","code":""},{"path":"ch05.html","id":"r-的繪圖系統","chapter":"5 視覺化：ggplot2","heading":"5.1 R 的繪圖系統","text":"眾所皆知，R 語言的繪圖能力非常強大。相較其它統計套裝軟體，R 讓使用者能對圖的細部做許多調整，甚至去創造出獨特的圖片 (.e. 不屬於傳統統計圖範疇內的圖)。但隨著強大繪圖功能伴隨而來的便是異常複雜的繪圖函數。傳統的 R 即擁有很厲害的繪圖系統：base R graphics 與 lattice 套件皆是功能非常強大的繪圖系統，但其學習曲線也相當陡峭，因此，實習課僅會介紹 ggplot2 這個較易上手 (但功能仍相當強大) 的繪圖系統 (套件)。","code":""},{"path":"ch05.html","id":"今天用到的資料-diamonds","chapter":"5 視覺化：ggplot2","heading":"5.2 今天用到的資料: diamonds","text":"diamonds 是 ggplot2 套件的內建資料。這筆資料記錄著 5 萬多筆鑽石的售價以及各種資訊。可使用 ?diamonds 閱讀此資料各變項的說明。因為 diamonds 相當龐大，為減少運算時間，這裡從 diamonds 抽出 1500 筆資料儲存於 diam","code":"\nlibrary(dplyr)\nlibrary(ggplot2)\n\ndiam <- diamonds %>% sample_n(size = 1500)"},{"path":"ch05.html","id":"template-1","chapter":"5 視覺化：ggplot2","heading":"5.3 Template 1","text":"最基本的 ggplot 模板：\nggplot(data = <DATA>) +\n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))最基本的 ggplot 模板：使用模板繪製散布圖：\n\n\nFigure 5.1: ggplot() 的結構\n\n使用模板繪製散布圖：\nFigure 5.1: ggplot() 的結構\n","code":"ggplot(data = <DATA>) +\n  <GEOM_FUNCTION>(mapping = aes(<MAPPINGS>))"},{"path":"ch05.html","id":"散布圖-scatter-plot","chapter":"5 視覺化：ggplot2","heading":"5.3.1 散布圖 (Scatter plot)","text":"使用下方程式碼，可繪製出鑽石的重量 (克拉) 與價錢 (美元) 的關係 (散布圖)\n\nlibrary(ggplot2)\n\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price))\n使用下方程式碼，可繪製出鑽石的重量 (克拉) 與價錢 (美元) 的關係 (散布圖)","code":"\nlibrary(ggplot2)\n\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price))"},{"path":"ch05.html","id":"圖層","chapter":"5 視覺化：ggplot2","heading":"5.4 圖層","text":"在 ggplot 的概念中，圖片是由一層層的圖層堆疊起來的：\n第一層 (ggplot()) 是底圖 (初始化繪圖函數)。在這層定義的內容 (e.g. data) 可被之後的圖層使用。\n\nggplot(data = diam)   # 底層\n\n第二層 (geom_point()) 畫在底圖之上。圖層之間以 + 連結起來,要將第一與第二層連起來，得在繪製第一層圖層的程式碼之後加上一個 +：\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price))    # 第二層\n\n如果想增加其它圖層，只要再繼續使用 +:\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price)) +  # 第二層\n  geom_smooth(mapping = aes(x = carat, y = price))   # 第三層\n\n第一層 (ggplot()) 是底圖 (初始化繪圖函數)。在這層定義的內容 (e.g. data) 可被之後的圖層使用。\n\nggplot(data = diam)   # 底層\n第一層 (ggplot()) 是底圖 (初始化繪圖函數)。在這層定義的內容 (e.g. data) 可被之後的圖層使用。第二層 (geom_point()) 畫在底圖之上。圖層之間以 + 連結起來,要將第一與第二層連起來，得在繪製第一層圖層的程式碼之後加上一個 +：\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price))    # 第二層\n第二層 (geom_point()) 畫在底圖之上。圖層之間以 + 連結起來,要將第一與第二層連起來，得在繪製第一層圖層的程式碼之後加上一個 +：如果想增加其它圖層，只要再繼續使用 +:\n\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price)) +  # 第二層\n  geom_smooth(mapping = aes(x = carat, y = price))   # 第三層\n如果想增加其它圖層，只要再繼續使用 +:","code":"\nggplot(data = diam)   # 底層\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price))    # 第二層\nggplot(data = diam) +                                # 底層\n  geom_point(mapping = aes(x = carat, y = price)) +  # 第二層\n  geom_smooth(mapping = aes(x = carat, y = price))   # 第三層"},{"path":"ch05.html","id":"mapping-將資料對應至視覺屬性","chapter":"5 視覺化：ggplot2","heading":"5.5 Mapping: 將資料對應至視覺屬性","text":"要能繪製統計圖，必須先將抽象的資料 (.e. data frame) 對應至實際可見的視覺屬性上 (e.g. 位置、形狀、大小、顏色、透明度等) 。不同的統計圖，所需的「資料與視覺屬性間的對應關係」就不同。要能繪製統計圖，必須先將抽象的資料 (.e. data frame) 對應至實際可見的視覺屬性上 (e.g. 位置、形狀、大小、顏色、透明度等) 。不同的統計圖，所需的「資料與視覺屬性間的對應關係」就不同。要繪製一個散布圖，我們必須將 data frame 中的一個變項對應至 x 軸、另一個變項對應至 y 軸，以將 data frame 中的每筆觀察值 (抽象資料) 轉換成圖上的一個個點 (視覺屬性)要繪製一個散布圖，我們必須將 data frame 中的一個變項對應至 x 軸、另一個變項對應至 y 軸，以將 data frame 中的每筆觀察值 (抽象資料) 轉換成圖上的一個個點 (視覺屬性)geom_*() 中的參數 mapping，即在定義「data frame 中的資料與統計圖上之視覺屬性的關係」：\n\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price, color = clarity))\n\n在 aes() 裡面定義資料與視覺屬性間的關係\nx = carat: 將 diam 中的變項 carat 對應至散布圖的 x 軸\ny = price: 將 diam 中的變項 price 對應至散布圖的 y 軸\nx 與 y 會共同決定一個點的位置\ncolor = clarity: 將 diam 中的變項 clarity 對應至散布圖上點的顏色\n\ngeom_*() 中的參數 mapping，即在定義「data frame 中的資料與統計圖上之視覺屬性的關係」：在 aes() 裡面定義資料與視覺屬性間的關係\nx = carat: 將 diam 中的變項 carat 對應至散布圖的 x 軸\ny = price: 將 diam 中的變項 price 對應至散布圖的 y 軸\nx 與 y 會共同決定一個點的位置\ncolor = clarity: 將 diam 中的變項 clarity 對應至散布圖上點的顏色\nx = carat: 將 diam 中的變項 carat 對應至散布圖的 x 軸y = price: 將 diam 中的變項 price 對應至散布圖的 y 軸x 與 y 會共同決定一個點的位置color = clarity: 將 diam 中的變項 clarity 對應至散布圖上點的顏色\nFigure 5.2: Aesthetic Mappings\n","code":"\nggplot(data = diam) +\n  geom_point(mapping = aes(x = carat, y = price, color = clarity))"},{"path":"ch05.html","id":"長條圖-bar-chart","chapter":"5 視覺化：ggplot2","heading":"5.6 長條圖 (Bar chart)","text":"概念上，繪製長條圖與繪製散布圖是很不一樣的：\n散布圖上的視覺屬性可以直接對應到 data frame 裡的資料\n長條圖的視覺屬性 (bar 的長度) 無法直接對應到 data frame 裡的資料。它對應到的是由 data frame 裡的資料經過彙整的結果:\nx 軸上是某變項裡的各個類別組成的\ny 軸代表各個類別出現的次數\n\n概念上，繪製長條圖與繪製散布圖是很不一樣的：散布圖上的視覺屬性可以直接對應到 data frame 裡的資料長條圖的視覺屬性 (bar 的長度) 無法直接對應到 data frame 裡的資料。它對應到的是由 data frame 裡的資料經過彙整的結果:\nx 軸上是某變項裡的各個類別組成的\ny 軸代表各個類別出現的次數\nx 軸上是某變項裡的各個類別組成的y 軸代表各個類別出現的次數geom_bar() 是用來繪製長條圖的函數。在定義 mapping 時，只需將 data frame 的某個變項 (通常為類別變項) 對應至 x，geom_bar() 即會自動依據此變項計算出各類別的次數。換言之，在生成的長條圖中，y 軸 (count) 並非 data frame 的變項，而是 geom_bar() 幫你計算出來的東西，因此在定義 mapping 時，不需定義變項與 y 軸間的 mapping。\n\nggplot(data = diam) + \n  geom_bar(mapping = aes(x = cut))\ngeom_bar() 是用來繪製長條圖的函數。在定義 mapping 時，只需將 data frame 的某個變項 (通常為類別變項) 對應至 x，geom_bar() 即會自動依據此變項計算出各類別的次數。換言之，在生成的長條圖中，y 軸 (count) 並非 data frame 的變項，而是 geom_bar() 幫你計算出來的東西，因此在定義 mapping 時，不需定義變項與 y 軸間的 mapping。geom_bar() 在繪製長條圖之前，為符合繪圖需求而將傳入的 data frame 進行的運算，稱為 Statistical Transformation:\n\n\nFigure 5.3: geom_bar()’s default statistical transformation13\n\ngeom_bar() 在繪製長條圖之前，為符合繪圖需求而將傳入的 data frame 進行的運算，稱為 Statistical Transformation:\nFigure 5.3: geom_bar()’s default statistical transformation13\n","code":"\nggplot(data = diam) + \n  geom_bar(mapping = aes(x = cut))"},{"path":"ch05.html","id":"statistical-transformations","chapter":"5 視覺化：ggplot2","heading":"5.7 Statistical Transformations","text":"有時候，我們只能拿到已整理好的資料，換言之，我們無法從 x 裡面去計算出裡面各類別的次數 (count)，例如 sum_data 已儲存著 cut 當中各類別的次數 (count)：\n\nsum_data <- diam %>% \n  group_by(cut) %>%\n  summarise(count = n())\n\nsum_data\n#> # tibble: 5 x 2\n#>   cut       count\n#>   <ord>     <int>\n#> 1 Fair         52\n#> 2 Good        136\n#> 3 Good   320\n#> 4 Premium     382\n#> 5 Ideal       610有時候，我們只能拿到已整理好的資料，換言之，我們無法從 x 裡面去計算出裡面各類別的次數 (count)，例如 sum_data 已儲存著 cut 當中各類別的次數 (count)：如果想使用 sum_data 之中的變項直接去畫出長條圖，就需要覆寫 「geom_bar() 自動從 x 計算出次數」的預設行為。這個行為可由 geom_bar() 的 stat 參數進行設定。如果想使用 sum_data 之中的變項直接去畫出長條圖，就需要覆寫 「geom_bar() 自動從 x 計算出次數」的預設行為。這個行為可由 geom_bar() 的 stat 參數進行設定。geom_bar() 的 stat 預設值是 \"count\"，讓 geom_bar() 可以從「對應至 x 的變項」計算出此變項裡各類別的次數。geom_bar() 的 stat 預設值是 \"count\"，讓 geom_bar() 可以從「對應至 x 的變項」計算出此變項裡各類別的次數。若不想自動進行這種計算，而想直接使用 data frame 本身的變項，則可以將 stat 設為 \"identity\"，此時便可以在 mapping 中直接將 data frame 的變項對應至長條圖的 x 軸 與 y 軸：\n\n# stat = \"identity\"\nggplot(data = sum_data) +\n  geom_bar(mapping = aes(x = cut, y = count),\n           stat = \"identity\") +\n  labs(title = 'stat = \"identity\"')\n\n# stat = \"count\" (geom_bar 預設)\nggplot(data = diam) +\n  geom_bar(mapping = aes(x = cut),\n           stat = \"count\") +\n  labs(title = 'stat = \"count\" (default)')\n若不想自動進行這種計算，而想直接使用 data frame 本身的變項，則可以將 stat 設為 \"identity\"，此時便可以在 mapping 中直接將 data frame 的變項對應至長條圖的 x 軸 與 y 軸：","code":"\nsum_data <- diam %>% \n  group_by(cut) %>%\n  summarise(count = n())\n\nsum_data#> # A tibble: 5 x 2\n#>   cut       count\n#>   <ord>     <int>\n#> 1 Fair         52\n#> 2 Good        136\n#> 3 Very Good   320\n#> 4 Premium     382\n#> 5 Ideal       610\n# stat = \"identity\"\nggplot(data = sum_data) +\n  geom_bar(mapping = aes(x = cut, y = count),\n           stat = \"identity\") +\n  labs(title = 'stat = \"identity\"')\n\n# stat = \"count\" (geom_bar 預設)\nggplot(data = diam) +\n  geom_bar(mapping = aes(x = cut),\n           stat = \"count\") +\n  labs(title = 'stat = \"count\" (default)')"},{"path":"ch05.html","id":"geom_-與-stat-預設","chapter":"5 視覺化：ggplot2","heading":"5.7.1 geom_*() 與 stat 預設","text":"所有的 geom_*() 函數都會有一個 stat 的預設值：\ngeom_point() 預設 stat = \"identity\"，所以給定 x 與 y 兩個 mapping，便會將 data frame 中的變項對應至圖上的 x 軸與 y 軸。\ngeom_bar() 預設 stat = \"count\"，會從對應至 x 的變項中計算出該變項各個類別的次數，並將此次數繪於圖上的 y 軸\ngeom_point() 預設 stat = \"identity\"，所以給定 x 與 y 兩個 mapping，便會將 data frame 中的變項對應至圖上的 x 軸與 y 軸。geom_bar() 預設 stat = \"count\"，會從對應至 x 的變項中計算出該變項各個類別的次數，並將此次數繪於圖上的 y 軸","code":""},{"path":"ch05.html","id":"position-adjustments","chapter":"5 視覺化：ggplot2","heading":"5.8 Position Adjustments","text":"透過提供第二個 mapping, fill, geom_bar 能夠將每個長條再依據第二個類別變項進行細分。","code":"\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity))\n# position: stack (default)\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity),\n           position = \"stack\")\n\n# position: fill\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity),\n           position = \"fill\")\n\n# postion: dodge\nggplot(data = diam) +\n  geom_bar(aes(x = cut, fill = clarity),\n           position = \"dodge\")"},{"path":"ch05.html","id":"template-2","chapter":"5 視覺化：ggplot2","heading":"5.9 Template 2","text":"","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  )"},{"path":"ch05.html","id":"facet","chapter":"5 視覺化：ggplot2","heading":"5.10 Facet","text":"1 個類別變項\n\nggplot(data = diam) +\n  geom_point(aes(x = carat, y = price)) +\n  facet_wrap(vars(cut))\n1 個類別變項2 個類別變項\n\nggplot(data = diam) +\n      geom_point(mapping = aes(x = carat, \n                               y = price)) +\n      facet_grid(rows = vars(cut),\n                 cols = vars(clarity))\n2 個類別變項","code":"\nggplot(data = diam) +\n  geom_point(aes(x = carat, y = price)) +\n  facet_wrap(vars(cut))\nggplot(data = diam) +\n      geom_point(mapping = aes(x = carat, \n                               y = price)) +\n      facet_grid(rows = vars(cut),\n                 cols = vars(clarity))"},{"path":"ch05.html","id":"template-3","chapter":"5 視覺化：ggplot2","heading":"5.11 Template 3","text":"","code":"ggplot(data = <DATA>) + \n  <GEOM_FUNCTION>(\n     mapping = aes(<MAPPINGS>),\n     stat = <STAT>, \n     position = <POSITION>\n  ) +\n  <FACET_FUNCTION>"},{"path":"ch05.html","id":"geoms","chapter":"5 視覺化：ggplot2","heading":"5.12 Geoms","text":"","code":"\nggplot(mpg) +\n  geom_point(aes(class, hwy))\nggsave('mpg_class_hwy_point.png', width = 14, height = 12, units = 'cm')\n\nggplot(mpg) +\n  geom_boxplot(aes(class, hwy))\n#ggsave('mpg_class_hwy_boxplot.png', width = 14, height = 12, units = 'cm')\n\nggplot(mpg) +\n  geom_point(aes(class, hwy, color = drv))\n#ggsave('mpg_class_hwy_color.png', width = 16, height = 12, units = 'cm')"},{"path":"ch05.html","id":"務必閱讀","chapter":"5 視覺化：ggplot2","heading":"5.13 務必閱讀","text":"R Data Science: Data visualisation","code":""}]
