[{"path":"index.html","id":"關於","chapter":"關於","heading":"關於","text":"程式設計與資料科學導論實習課講義","code":""},{"path":"ch01.html","id":"ch01","chapter":"1 掌握你的電腦","heading":"1 掌握你的電腦","text":"(投影片 /\n影片)","code":""},{"path":"ch01.html","id":"路徑-工作目錄","chapter":"1 掌握你的電腦","heading":"1.1 路徑 & 工作目錄","text":"電腦透過資料夾 (directory) 與檔案 (file) 將資訊組織起來，方便與使用者互動。資料夾裡面可以是另一個資料夾，也可以是檔案。換言之，資料夾是有階層結構的，可以一層層的包覆起來電腦透過資料夾 (directory) 與檔案 (file) 將資訊組織起來，方便與使用者互動。資料夾裡面可以是另一個資料夾，也可以是檔案。換言之，資料夾是有階層結構的，可以一層層的包覆起來在使用電腦時，我們通常是透過圖形使用者界面 (GUI) 與電腦互動。在操作檔案與資料夾時，我們通常會透過檔案管理員這類的程式 (Figure 1.1)在使用電腦時，我們通常是透過圖形使用者界面 (GUI) 與電腦互動。在操作檔案與資料夾時，我們通常會透過檔案管理員這類的程式 (Figure 1.1)\nFigure 1.1: Windows 與 Mac 的檔案管理界面1\n對於初次接觸程式的同學，需要逐步習慣使用 Text-based user interfaces (TUI) (下圖)。透過 TUI 與電腦互動意謂著使用者(幾乎)只能使用鍵盤，也意謂著使用者需了解更多的程式指令以及電腦組織檔案與資料夾的方式。但與此同時，使用者將能更好地掌握自己的電腦2\n對於初次接觸程式的同學，需要逐步習慣使用 Text-based user interfaces (TUI) (下圖)。透過 TUI 與電腦互動意謂著使用者(幾乎)只能使用鍵盤，也意謂著使用者需了解更多的程式指令以及電腦組織檔案與資料夾的方式。但與此同時，使用者將能更好地掌握自己的電腦2","code":""},{"path":"ch01.html","id":"目錄結構-directory-structure","chapter":"1 掌握你的電腦","heading":"1.1.1 目錄結構 (Directory structure)","text":"為方便理解電腦裡面的資料夾與檔案結構 (簡稱目錄結構)，我們通常會以樹狀結構去表示目錄結構。Figure 1.2 是 Windows 以及 Mac 上的目錄結構圖為方便理解電腦裡面的資料夾與檔案結構 (簡稱目錄結構)，我們通常會以樹狀結構去表示目錄結構。Figure 1.2 是 Windows 以及 Mac 上的目錄結構圖在樹狀圖中，越上方的資料夾階層越高。最上方的資料夾稱為根目錄 (root)，電腦中的所有其它資料夾與檔案皆位於根目錄之內3在樹狀圖中，越上方的資料夾階層越高。最上方的資料夾稱為根目錄 (root)，電腦中的所有其它資料夾與檔案皆位於根目錄之內3\nFigure 1.2: 目錄結構\n以 Figure 1.2 為例，\nWindows 的根目錄 C: 裡有 3 個資料夾 temp, Users, 以及 Windows，其中的 Users 之下又有 3 個資料夾 Tiger, Pooh 與 Piglet\nMac 的根目錄以 / 表示，裡面有 3 個資料夾 Library, Users 以及 System。Users 之下有 Tiger, Pooh 與 Piglet 3 個資料夾\nWindows 的根目錄 C: 裡有 3 個資料夾 temp, Users, 以及 Windows，其中的 Users 之下又有 3 個資料夾 Tiger, Pooh 與 PigletMac 的根目錄以 / 表示，裡面有 3 個資料夾 Library, Users 以及 System。Users 之下有 Tiger, Pooh 與 Piglet 3 個資料夾","code":""},{"path":"ch01.html","id":"路徑-path","chapter":"1 掌握你的電腦","heading":"1.1.2 路徑 (Path)","text":"使用 Text-based user interfaces (TUI) 與電腦互動時，需要一套用來描述路徑 (Path) (亦即, 某個資料夾或檔案位於電腦上的哪個位置) 的語法。這套語法基本上就是在告訴電腦「如何從 資料夾『走到』目標資料夾 (或檔案)」","code":""},{"path":"ch01.html","id":"絕對路徑","chapter":"1 掌握你的電腦","heading":"1.1.2.1 絕對路徑","text":"絕對路徑就是在告訴電腦「如何從根目錄 (root)走到目標資料夾 (或檔案)」/ 在描述路徑時具有 2 種語意：\n若 / 出現在路徑的起始 (e.g., /Users)，則其代表的是根目錄 (Windows 的 C: 以及 Mac 的 /)\n若 / 出現在 路徑的中間 (e.g., C:/Users/Pooh)，則是作為母 (Parent) 子 (Child) 資料夾之間的分隔符號\n若 / 出現在路徑的起始 (e.g., /Users)，則其代表的是根目錄 (Windows 的 C: 以及 Mac 的 /)若 / 出現在 路徑的中間 (e.g., C:/Users/Pooh)，則是作為母 (Parent) 子 (Child) 資料夾之間的分隔符號舉例來說，\n若要告訴電腦根目錄的位置，只須輸入根目錄的名稱：\nC: (Windows)/ (Mac)\n\n若要告訴電腦 Tiger 的位置，則可以在根目錄後面依序輸入 Users 與 Tiger，並使用 / 作為資料夾間的分隔線：\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\n\n若要告訴電腦根目錄的位置，只須輸入根目錄的名稱：\nC: (Windows)/ (Mac)\nC: (Windows)/ (Mac)若要告訴電腦 Tiger 的位置，則可以在根目錄後面依序輸入 Users 與 Tiger，並使用 / 作為資料夾間的分隔線：\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)\nC:/Users/Tiger (Windows)/Users/Tiger (Mac)現在是時候打開終端機 (Terminal) 玩玩看了 (解鎖你電腦的 1 號隱藏功能)。按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：\nC:\\Users\\{username}\n這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在 Finder 搜尋 Terminal 或 終端機在 Finder 搜尋 Terminal 或 終端機在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑\n/Users/{username}\n這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱這個出現在終端機上的絕對路徑即是目前終端機程式的工作目錄。所以到底什麼是工作目錄？由於程式 (e.g., 終端機, R, Python, Chrome, …) 運行時需要與電腦進行互動，換言之，它們經常需要讀取、修改、刪除與寫入檔案與資料夾，但同時又不需要知道電腦上完整的目錄結構，因此它們需要有一個參照用的資料夾，以此資料夾作為描述路徑的基準。這個參照的資料夾就如同執行中的程式工作的地方，因此稱為工作目錄；而用來描述相對於工作目錄的路徑則稱為相對路徑。而上面 C:\\Users\\{username} (Windows) 與 /Users/{username} (Mac) 這兩個路徑， 即是終端機開啟時預設的工作目錄。下方介紹完相對路徑後，接著會告訴大家如何更改工作目錄。","code":"C:\\Users\\{username}/Users/{username}"},{"path":"ch01.html","id":"windows","chapter":"1 掌握你的電腦","heading":"Windows","text":"按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」按下 Windows 鍵 ⊞ 搜尋：cmd 打開「命令提示字元」在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：\nC:\\Users\\{username}\n這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 cd，此時應會印出一個絕對路徑4：這個路徑包含 3 個資料夾 C:, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱","code":"C:\\Users\\{username}"},{"path":"ch01.html","id":"mac","chapter":"1 掌握你的電腦","heading":"Mac","text":"在 Finder 搜尋 Terminal 或 終端機在 Finder 搜尋 Terminal 或 終端機在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑\n/Users/{username}\n這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱在跳出來的黑黑的視窗輸入 pwd，此時應會印出一個絕對路徑這個路徑包含 3 個資料夾 /, Users 以及 {username}，其中 {username} 是你登入電腦的使用者名稱","code":"/Users/{username}"},{"path":"ch01.html","id":"工作目錄-working-directory","chapter":"1 掌握你的電腦","heading":"工作目錄 (Working Directory)","text":"這個出現在終端機上的絕對路徑即是目前終端機程式的工作目錄。所以到底什麼是工作目錄？由於程式 (e.g., 終端機, R, Python, Chrome, …) 運行時需要與電腦進行互動，換言之，它們經常需要讀取、修改、刪除與寫入檔案與資料夾，但同時又不需要知道電腦上完整的目錄結構，因此它們需要有一個參照用的資料夾，以此資料夾作為描述路徑的基準。這個參照的資料夾就如同執行中的程式工作的地方，因此稱為工作目錄；而用來描述相對於工作目錄的路徑則稱為相對路徑。而上面 C:\\Users\\{username} (Windows) 與 /Users/{username} (Mac) 這兩個路徑， 即是終端機開啟時預設的工作目錄。下方介紹完相對路徑後，接著會告訴大家如何更改工作目錄。","code":""},{"path":"ch01.html","id":"相對路徑","chapter":"1 掌握你的電腦","heading":"1.1.2.2 相對路徑","text":"相對路徑就是在告訴電腦「如何從工作目錄 (working directory) 走到目標資料夾 (或檔案)」。以下方的目錄結構為例 (工作目錄設在 /Users/Pooh)，\nFigure 1.3: 範例目錄結構。在此例中，工作目錄設置在 Pooh\n. 表示的是「當前」的目錄，所以若其出現在路徑的開頭，即是指工作目錄5。所以透過相對路徑表示工作目錄非常簡短：\n.. 表示的是「當前」的目錄，所以若其出現在路徑的開頭，即是指工作目錄5。所以透過相對路徑表示工作目錄非常簡短：若要表示工作目錄之下的檔案或資料夾，例如 Desktop，其相對路徑即為其名稱：\nDesktop\n或是，也可以在透過 . 表示當前目錄之後，再於後方加入檔案或資料夾的名稱：\n./Desktop若要表示工作目錄之下的檔案或資料夾，例如 Desktop，其相對路徑即為其名稱：或是，也可以在透過 . 表示當前目錄之後，再於後方加入檔案或資料夾的名稱：依此類推，工作目錄下面兩個階層的檔案或資料夾 (例如，.txt) 的相對路徑為：\nDesktop/.txt\n./Desktop/.txt依此類推，工作目錄下面兩個階層的檔案或資料夾 (例如，.txt) 的相對路徑為：.. 則讓我們可以往上走。例如，若想表示工作目錄的母資料夾 Users，可以使用 ..：\n..\n./.... 則讓我們可以往上走。例如，若想表示工作目錄的母資料夾 Users，可以使用 ..：這讓我們可以很方便地表示工作目錄的「姊妹」資料夾 Tiger (它們共同的母資料夾是 Users)：\n../Tiger\n./../Tiger\n\n\nFigure 1.4: 透過相對路徑表示「姊妹」的資料夾\n\n這讓我們可以很方便地表示工作目錄的「姊妹」資料夾 Tiger (它們共同的母資料夾是 Users)：\nFigure 1.4: 透過相對路徑表示「姊妹」的資料夾\n同理，若要表達 Tiger 之下的 .txt，只需在原本的路徑之後加入檔名：\n../Tiger/.txt\n./../Tiger/.txt同理，若要表達 Tiger 之下的 .txt，只需在原本的路徑之後加入檔名：透過終端機更改工作目錄的指令很簡單：cd (“change directory”) + 絕對/相對路徑6。所以假設想將 Figure 1.4 中的工作目錄 Pooh 更改成 Tiger，只要輸入：或Windows 系統上的路徑使用的是反斜線 \\ 作為分隔符號，與其它系統 (Mac, Linux 等) 以及各種程式語言 (R, Python 等) 使用的 / 不同。但近年的 Windows 系統已讓使用者能輸入 / 作為路徑中的分隔7。由於反斜線 \\ 在許多程式語言中常具有特殊的功能，這邊強烈建議大家路徑中不要使用反斜線 \\，請使用 /。這麼做的好處之一，是讓你撰寫的程式可以同時在 Windows 以及其它系統上運行8。","code":".Desktop./DesktopDesktop/i.txt\n./Desktop/i.txt..\n./..../Tiger\n./../Tiger../Tiger/he.txt\n./../Tiger/he.txtcd ../Tigercd /Users/Tiger"},{"path":"ch01.html","id":"windows-路徑中的反斜線","chapter":"1 掌握你的電腦","heading":"Windows 路徑中的反斜線 (\\)","text":"Windows 系統上的路徑使用的是反斜線 \\ 作為分隔符號，與其它系統 (Mac, Linux 等) 以及各種程式語言 (R, Python 等) 使用的 / 不同。但近年的 Windows 系統已讓使用者能輸入 / 作為路徑中的分隔7。由於反斜線 \\ 在許多程式語言中常具有特殊的功能，這邊強烈建議大家路徑中不要使用反斜線 \\，請使用 /。這麼做的好處之一，是讓你撰寫的程式可以同時在 Windows 以及其它系統上運行8。","code":""},{"path":"ch01.html","id":"r-101","chapter":"1 掌握你的電腦","heading":"1.2 R 101","text":"現在我們已經知道如何操作終端機了。接下來，我們就可以透過終端機執行我們的第一支 R 程式：透過文字編輯器9新增一份純文字檔，將檔案命名為 hello.R。hello.R 內請寫下：\n\nprint(\"Hello World!\")透過文字編輯器9新增一份純文字檔，將檔案命名為 hello.R。hello.R 內請寫下：打開終端機，cd 到 hello.R 所在的資料夾 (e.g., C:/Users/Tiger/Desktop)，再執行 Rscript hello.R:\ncd ./Desktop\nRscript hello.R打開終端機，cd 到 hello.R 所在的資料夾 (e.g., C:/Users/Tiger/Desktop)，再執行 Rscript hello.R:這時，你應該會看到終端機裡印出：\n[1] \"Hello World!\"這時，你應該會看到終端機裡印出：試著修改 hello.R 的內容，然後重複執行 Rscript hello.R，看看輸出指令如何改變。你可以嘗試以下的指令：print(\"Hi\")(2 + 7) / 102 ^ 31:4在 hello.R 裡面，你可以輸入不只一條指令，但注意，每一條指令需佔獨立的一行。例如，若要輸入三條指令，hello.R 的樣子會類似：","code":"\nprint(\"Hello World!\")cd ./Desktop\nRscript hello.R[1] \"Hello World!\"\nprint(\"Hello world\")\nprint(\"Hi\")\n(2 + 7) / 10"},{"path":"ch01.html","id":"r-script","chapter":"1 掌握你的電腦","heading":"1.2.1 R Script","text":"hello.R 這類用來撰寫程式的純文字檔稱為 R script (而執行 R Script 裡程式的指令為 Rscript)。在 R script 中，程式碼是由上至下執行，所以上面的例子執行後會依序印出這三行的執行結果：","code":"\nprint(\"Hello world\")\nprint(\"Hi\")\n(2 + 7) / 10[1] \"Hello World!\"\n[1] \"Hi\"\n[1] 0.9"},{"path":"ch01.html","id":"回傳值","chapter":"1 掌握你的電腦","heading":"1.2.2 回傳值","text":"在上方的例子中，印出的執行結果前面皆有一個 [1]。這個 [1] 的目的是為了方便使用者知道指令執行的結果 (回傳值) 的「位置」。事實上，R 印出回傳值的形式是：[<num>] <value(s)>：\n<value(s)> 是指令所傳回來的值 (可有一個以上)，e.g. 1 1 2 3 4 \"\" \"b\" \"c\" \"d\"\n而 [<num>] 則是一個指標 (位於每橫列的開頭)，用來指示其右邊第一個值在所有的值之中的排序，e.g. [1] 11 12 13 代表 11 是第 1 個數值、12 是第 2 個數值；若第一行不足以印出所有的值，則會接著印出第二行: 例如 [16] 26 27 28 代表 26 是第 16 個。\n在上方的例子中，印出的執行結果前面皆有一個 [1]。這個 [1] 的目的是為了方便使用者知道指令執行的結果 (回傳值) 的「位置」。事實上，R 印出回傳值的形式是：[<num>] <value(s)>：<value(s)> 是指令所傳回來的值 (可有一個以上)，e.g. 1 1 2 3 4 \"\" \"b\" \"c\" \"d\"而 [<num>] 則是一個指標 (位於每橫列的開頭)，用來指示其右邊第一個值在所有的值之中的排序，e.g. [1] 11 12 13 代表 11 是第 1 個數值、12 是第 2 個數值；若第一行不足以印出所有的值，則會接著印出第二行: 例如 [16] 26 27 28 代表 26 是第 16 個。例如，執行 1:50 會回傳 50 個值 (1~50)。因為終端機一行無法顯示全部的值，它便會將結果用多行 (行數每台電腦可能不同) 顯示，並透過 [<num>] 方便使用者知道目前印到哪一個值：\n\n1:50\n#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50例如，執行 1:50 會回傳 50 個值 (1~50)。因為終端機一行無法顯示全部的值，它便會將結果用多行 (行數每台電腦可能不同) 顯示，並透過 [<num>] 方便使用者知道目前印到哪一個值：","code":"\n1:50#>  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n#> [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50"},{"path":"ch01.html","id":"變數指派-assignment","chapter":"1 掌握你的電腦","heading":"1.2.3 變數指派 (Assignment)","text":"要將指令的回傳值儲存起來，需要使用 <- (assignment operator)，將 <- 右邊的程式碼執行後所回傳的數值儲存於 <- 左邊的變數例如，我可以先將 2 * 3 + 4 的運算結果儲存在 x 內：之後，我可以輸入 x 直接取用上次運算的結果：","code":"\nx <- 2 * 3 + 4\nx#> [1] 10\nx + 1  # 用 x 內的值進一步運算#> [1] 11"},{"path":"ch01.html","id":"r-內建函數","chapter":"1 掌握你的電腦","heading":"1.2.4 R 內建函數","text":"R 裡面的函數就像是我們國高中數學課學到的「函數」。\nR 的函數 (通常) 會有一個或多個「輸入值」，稱為「引數 (argument)」；並且在運算完成後，一定會丟出一個「回傳值」\nR 裡面的函數就像是我們國高中數學課學到的「函數」。R 的函數 (通常) 會有一個或多個「輸入值」，稱為「引數 (argument)」；並且在運算完成後，一定會丟出一個「回傳值」sqrt() 是一個函數，它會將輸入值 (在圓括號內) 開根號後回傳\n\nsqrt(16)\n#> [1] 4sqrt() 是一個函數，它會將輸入值 (在圓括號內) 開根號後回傳函數裡面可以放入另一個函數 (e.g. sqrt(sqrt(16)))，其運算的次序是由內而外，先執行最內部的函數，取得回傳值後，再將此回傳值作為外面的函數的輸入值\n\nsqrt(sqrt(16))\n#> [1] 2\n概念上等同於：\n\ninner <- sqrt(16)\nsqrt(inner)\n#> [1] 2函數裡面可以放入另一個函數 (e.g. sqrt(sqrt(16)))，其運算的次序是由內而外，先執行最內部的函數，取得回傳值後，再將此回傳值作為外面的函數的輸入值概念上等同於：","code":"\nsqrt(16)#> [1] 4\nsqrt(sqrt(16))#> [1] 2\ninner <- sqrt(16)\nsqrt(inner)#> [1] 2"},{"path":"ch01.html","id":"r-console","chapter":"1 掌握你的電腦","heading":"1.2.5 R Console","text":"寫程式時，每次修改都要透過 Rscript 指令檢視執行結果有點麻煩，特別是當你只是在測試或是只想看某一行指令的輸出結果時。因此在撰寫程式時，我們通常會\n先將指令寫在 R Console 測試\n確認執行結果沒問題後再將指令複製到 R Script\n寫完完整的一段程式碼再透過終端機執行整個 R Script\n先將指令寫在 R Console 測試確認執行結果沒問題後再將指令複製到 R Script寫完完整的一段程式碼再透過終端機執行整個 R Script在終端機裡面輸入 R 即可打開 R Console。R Console 是互動式的，意思是輸入一行指令後，可以馬上看到指令執行的結果，並且還可以繼續執行其它指令 (過程中若有指派變數，結果也會記錄下來)。\nFigure 1.5: 寫 R 必備的 3 樣工具\n","code":""},{"path":"ch01.html","id":"說明文件-r-help-page","chapter":"1 掌握你的電腦","heading":"1.2.6 說明文件 (R Help Page)","text":"不確定如何使用函數時，可以閱讀該函數的說明文件：\n\n# ?<function_name>\n?log\n\n# ?`<function_name>`: special functions (e.g. binary operators)\n?`+`不確定如何使用函數時，可以閱讀該函數的說明文件：\nFigure 1.6: 說明文件結構。建議閱讀步驟：Description > Usage > Arguments > Value > Examples > Details\n","code":"\n# ?<function_name>\n?log\n\n# ?`<function_name>`: for special functions (e.g. binary operators)\n?`+`"},{"path":"ch02.html","id":"ch02","chapter":"2 Base R (I) & 輔助工具","heading":"2 Base R (I) & 輔助工具","text":"(投影片 /\n影片)","code":""},{"path":"ch02.html","id":"r-studio","chapter":"2 Base R (I) & 輔助工具","heading":"2.1 R Studio","text":"","code":""},{"path":"ch02.html","id":"自訂樣式","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.1 自訂樣式","text":"RStudio 預設有 4 個區塊 (Pane)。你可以自行決定這 4 個區塊的位置\nTools –> Global Options... –> (在左欄選擇) Pane Layout\nSource, Console, 及 2 個自訂區塊\nTools –> Global Options... –> (在左欄選擇) Pane LayoutSource, Console, 及 2 個自訂區塊除了區塊的相對位置，也可以設定 RStudio 整體的風格以及程式碼 Syntax Highlighting 的樣式:\nTools –> Global Options... –> (在左欄選擇) Appearance\nTools –> Global Options... –> (在左欄選擇) Appearance","code":""},{"path":"ch02.html","id":"編輯器設定","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.2 編輯器設定","text":"Source Pane 是撰寫程式碼的地方 (文字編輯器)\n縮排間距：建議使用 space (而非 tab) 作為縮排字元\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab\n\n文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding\n\n縮排間距：建議使用 space (而非 tab) 作為縮排字元\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab\n縮排間距：建議使用 space (而非 tab) 作為縮排字元Tools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Editing –> 勾選 Insert spaces tab文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8\nTools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding\n文字編碼：由於中文字在各作業系統上會有編碼不一致的問題，請務必將編碼設定為 UTF-8Tools –> Global Options... –> (在左欄選擇) Code –> (在上方選擇) Saving –> Default text encoding","code":""},{"path":"ch02.html","id":"工作目錄","chapter":"2 Base R (I) & 輔助工具","heading":"2.1.3 工作目錄","text":"使用 RStudio 時，最好養成要馬上設置「工作目錄」的習慣。使用 RStudio 時，最好養成要馬上設置「工作目錄」的習慣。RStudio 所在的「工作目錄」顯示於 Console Pane 的標籤下方 (e.g. ~/)RStudio 所在的「工作目錄」顯示於 Console Pane 的標籤下方 (e.g. ~/)工作目錄的設置方式\nRStudio 功能選單: Sessions > Set Working Directory...\nConsole\n\nsetwd('~/Desktop/week2')\n# setwd('<path//new_working_dir>')\ngetwd()  # show current directory\n工作目錄的設置方式RStudio 功能選單: Sessions > Set Working Directory...RStudio 功能選單: Sessions > Set Working Directory...Console\n\nsetwd('~/Desktop/week2')\n# setwd('<path//new_working_dir>')\ngetwd()  # show current directoryConsole","code":"\nsetwd('~/Desktop/week2')\n# setwd('<path/to/new_working_dir>')\ngetwd()  # show current directory"},{"path":"ch02.html","id":"函數","chapter":"2 Base R (I) & 輔助工具","heading":"2.2 函數","text":"","code":"\nget_area <- function() {\n    area <- 3.14 * 1 * 1\n    return(area)\n}\nget_area()#> [1] 3.14\n# Function with a argument\nget_area <- function(r) {\n    area <- 3.14 * r * r\n    return(area)\n}\nget_area(2)#> [1] 12.56\n# Function with a argument that has default value\nget_area <- function(r = 1) {\n    area <- 3.14 * r * r\n    return(area)\n}\nget_area()#> [1] 3.14\nget_area <- function(r) {\n    area <- 3.14 * r * r\n    return(area)\n}\narea <- 100\narea\nget_area(1)\narea#> [1] 100\n#> [1] 3.14\n#> [1] 100"},{"path":"ch02.html","id":"function-arguments","chapter":"2 Base R (I) & 輔助工具","heading":"2.3 Function Arguments","text":"","code":"\nvol <- function(r, height = 1) {\n    volumn <- 3.14 * r * r * height\n    return(volumn)\n}\nvol(1, 2)#> [1] 6.28\nvol(r = 1, height = 2)  # Be explicit#> [1] 6.28\n# If all args are named, order doesn't matter\nvol(height = 2, r = 1)#> [1] 6.28\n# Mix named and unnamed args:\n# named args will be assigned first, then\n# unnamed args will be assigned \n# based on their positions\nvol(height = 2, 1)#> [1] 6.28"},{"path":"ch02.html","id":"vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4 vector","text":"上週實習課使用 R 時，指令的回傳值多半只有「一個」。但 R 其實是一種以向量作為基本單位的程式語言，所以對於「一個回傳值」更精確的描述應該是「一個長度為 1 的向量」。\n\nx <- 2\nx\n#> [1] 2\n\n.vector(x)\n#> [1] TRUE\n\nlength(x)\n#> [1] 1上週實習課使用 R 時，指令的回傳值多半只有「一個」。但 R 其實是一種以向量作為基本單位的程式語言，所以對於「一個回傳值」更精確的描述應該是「一個長度為 1 的向量」。我們上週簡短提過以 : 製造數列的方式 (e.g. 1:10)。事實上，這個回傳的數列即是一個 vector。另外，由於這個 vector 的每個元素皆是整數，因此這個 vector 屬於 integer vector。我們可以使用 typeof() 確認 vector 的類別\n\ntypeof(1:10)\n#> [1] \"integer\"我們上週簡短提過以 : 製造數列的方式 (e.g. 1:10)。事實上，這個回傳的數列即是一個 vector。另外，由於這個 vector 的每個元素皆是整數，因此這個 vector 屬於 integer vector。我們可以使用 typeof() 確認 vector 的類別R 裡面的 vector 可以被分成 6 種類別，其中常見的 4 種分別為 integer, double, , character, logicalR 裡面的 vector 可以被分成 6 種類別，其中常見的 4 種分別為 integer, double, , character, logical","code":"\nx <- 2\nx#> [1] 2\nis.vector(x)#> [1] TRUE\nlength(x)#> [1] 1\ntypeof(1:10)#> [1] \"integer\""},{"path":"ch02.html","id":"integer-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.1 integer vector","text":"integer vector 的元素由整數組成，它可以是零、正或負的。除了使用 : 製造數列，也可以使用 c() (稱為 concatenate) 組出任意序列的 vector。\n使用 c() 製造 integer vector 時，每個整數數字後面必須接 L，若沒有加上 L， R 會將製造出來的 vector 視為 double vector。\n使用 c() 製造 integer vector 時，每個整數數字後面必須接 L，若沒有加上 L， R 會將製造出來的 vector 視為 double vector。","code":"\nint_vec <- c(-1L, 5L, 2L)\ndbl_vec <- c(-1, 5, 2)\nint_vec#> [1] -1  5  2\ndbl_vec#> [1] -1  5  2\ntypeof(int_vec)#> [1] \"integer\"\ntypeof(dbl_vec)#> [1] \"double\""},{"path":"ch02.html","id":"double-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.2 double vector","text":"double vector 儲存的是浮點數，亦即含有小數點的數字 (e.g 1.2, -0.75)double vector 儲存的是浮點數，亦即含有小數點的數字 (e.g 1.2, -0.75)在 R 裡面，integer vector 與 double vector 合稱為 numeric vector，兩者之間的區隔通常也不太重要，因為 R 在運算時，通常會將這兩種資料類型自動轉換成合適的類型\n\ntypeof(2L)\n#> [1] \"integer\"\n\ntypeof(2.0)\n#> [1] \"double\"\n\n.numeric(2L)\n#> [1] TRUE\n\n.numeric(2.0)\n#> [1] TRUE\n\ntypeof(1L + 1.0)\n#> [1] \"double\"\n\ntypeof(1L / 2L)\n#> [1] \"double\"在 R 裡面，integer vector 與 double vector 合稱為 numeric vector，兩者之間的區隔通常也不太重要，因為 R 在運算時，通常會將這兩種資料類型自動轉換成合適的類型Special values:\nInf: 代表無限大\nNaN: “Number”，常見於數字運算不符數學定義時，例如：\n\n0 / 0\n#> [1] NaN\n\nInf / Inf\n#> [1] NaN\n\nlog(-1)\n#> Warning log(-1): NaNs produced\n#> [1] NaN\nSpecial values:Inf: 代表無限大Inf: 代表無限大NaN: “Number”，常見於數字運算不符數學定義時，例如：\n\n0 / 0\n#> [1] NaN\n\nInf / Inf\n#> [1] NaN\n\nlog(-1)\n#> Warning log(-1): NaNs produced\n#> [1] NaNNaN: “Number”，常見於數字運算不符數學定義時，例如：","code":"\ntypeof(2L)#> [1] \"integer\"\ntypeof(2.0)#> [1] \"double\"\nis.numeric(2L)#> [1] TRUE\nis.numeric(2.0)#> [1] TRUE\ntypeof(1L + 1.0)#> [1] \"double\"\ntypeof(1L / 2L)#> [1] \"double\"\n0 / 0#> [1] NaN\nInf / Inf#> [1] NaN\nlog(-1)#> Warning in log(-1): NaNs produced#> [1] NaN"},{"path":"ch02.html","id":"character-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.3 character vector","text":"除了數字以外，R 也可以儲存字串 (string)。character vector 的每個元素皆由一個字串所組成。在 R 裡面，只要是被引號 (quote, ' 或 \" 皆可) 包裹的東西就是字串，放在引號內的可以是任何字元 (e.g. 空白、數字、中文字、英文字母)\n\n\"1.1\"  # string (character vector length 1), double\n#> [1] \"1.1\"\n\n\"你好！\"\n#> [1] \"你好！\"\n\nc(\"1.1\", \"你好！\")\n#> [1] \"1.1\"    \"你好！\"除了數字以外，R 也可以儲存字串 (string)。character vector 的每個元素皆由一個字串所組成。在 R 裡面，只要是被引號 (quote, ' 或 \" 皆可) 包裹的東西就是字串，放在引號內的可以是任何字元 (e.g. 空白、數字、中文字、英文字母)如果字串內含有引號 \"，需在字串內的引號前使用跳脫字元 \\，以表示此引號是字串的一部分而非字串的開頭或結尾\n或是，你可以使用「不同的」引號。例如以「單引號」表示字串的開頭與結尾時，字串內就可以直接使用「雙引號」，反之亦然\n\n\"\\\"\"  # escape double quote\n'\\''  # escape single quote\n'\"'   # double quote string without escaping\n\"'\"   # single quote string without escaping\n#> [1] \"\\\"\"\n#> [1] \"'\"\n#> [1] \"\\\"\"\n#> [1] \"'\"如果字串內含有引號 \"，需在字串內的引號前使用跳脫字元 \\，以表示此引號是字串的一部分而非字串的開頭或結尾或是，你可以使用「不同的」引號。例如以「單引號」表示字串的開頭與結尾時，字串內就可以直接使用「雙引號」，反之亦然","code":"\n\"1.1\"  # This is a string (character vector of length 1), not double#> [1] \"1.1\"\n\"你好！\"#> [1] \"你好！\"\nc(\"1.1\", \"你好！\")#> [1] \"1.1\"    \"你好！\"\n\"\\\"\"  # escape a double quote\n'\\''  # escape a single quote\n'\"'   # a double quote as string without escaping\n\"'\"   # a single quote as string without escaping#> [1] \"\\\"\"\n#> [1] \"'\"\n#> [1] \"\\\"\"\n#> [1] \"'\""},{"path":"ch02.html","id":"logical-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.4 logical vector","text":"logical vector 的每個元素由 TRUE 或 FALSE 組成。logical vector 的每個元素由 TRUE 或 FALSE 組成。可以使用 c() 一項項手動輸入製造 logical vector可以使用 c() 一項項手動輸入製造 logical vectorlogical vector 的另一個來源則是 logical test 的回傳值：\nlogical operators: ==, !=, >, <, %%\n\n\nvec1 <- c(1, 1, 1)\nvec2 <- c(2, 0, 2)\n\n# logical tests\nvec1 > vec2\n#> [1] FALSE  TRUE FALSE\n\nvec1 < vec2\n#> [1]  TRUE FALSE  TRUE\n\nvec1 == vec2\n#> [1] FALSE FALSE FALSElogical vector 的另一個來源則是 logical test 的回傳值：logical operators: ==, !=, >, <, %%boolean operators (&, |, !, (), ()) 可以整合多個 logical tests\n\n\nTRUE & TRUE\n#> [1] TRUE\n\nTRUE & FALSE\n#> [1] FALSE\n\nTRUE | FALSE\n#> [1] TRUE\n\n!TRUE\n#> [1] FALSE\n\n(1 == 1) & (2 == 2)\n#> [1] TRUEboolean operators (&, |, !, (), ()) 可以整合多個 logical tests","code":"\nvec1 <- c(1, 1, 1)\nvec2 <- c(2, 0, 2)\n# logical tests\nvec1 > vec2#> [1] FALSE  TRUE FALSE\nvec1 < vec2#> [1]  TRUE FALSE  TRUE\nvec1 == vec2#> [1] FALSE FALSE FALSE\nTRUE & TRUE#> [1] TRUE\nTRUE & FALSE#> [1] FALSE\nTRUE | FALSE#> [1] TRUE\n!TRUE#> [1] FALSE\n(1 == 1) & (2 == 2)#> [1] TRUE"},{"path":"ch02.html","id":"na","chapter":"2 Base R (I) & 輔助工具","heading":"2.4.5 NA","text":"NA 代表的是「缺失值」，可以作為任何一種 vector 裡面的元素。當 NA 出現在 vector 中，函數對於 vector 的運算常會出現令人意外的結果:\n\n10 > NA\n#> [1] NA\n\nNA == NA\n#> [1] NA\n\nvec <- c(1, NA, 2, 3)\nmean(vec)\n#> [1] NA\n\nmean(vec, na.rm = TRUE)\n#> [1] 2NA 代表的是「缺失值」，可以作為任何一種 vector 裡面的元素。當 NA 出現在 vector 中，函數對於 vector 的運算常會出現令人意外的結果:","code":"\n10 > NA#> [1] NA\nNA == NA#> [1] NA\nvec <- c(1, NA, 2, 3)\nmean(vec)#> [1] NA\nmean(vec, na.rm = TRUE)#> [1] 2"},{"path":"ch02.html","id":"recycling","chapter":"2 Base R (I) & 輔助工具","heading":"2.5 Recycling","text":"兩個或兩個以上的 vector 進行運算時，通常是以 element-wise 的方式進行。此時，若進行運算的 vector 長度不相同，例如，c(1, 2, 3) + 2， R 會自動將長度較短 vector (2) 「回收 (recycle)」，亦即，重複此向量內的元素使其「拉長」到與另一個 vector 等長；接著再將兩個一樣長的 vector 進行 element-wise 的向量運算。","code":"\nx <- c(1, 1, 2, 2)\n\n# Arithmetic operation\nx + 2  # equivalent to...#> [1] 3 3 4 4\nx + c(2, 2, 2, 2)#> [1] 3 3 4 4\nx <- c(1, 1, 2, 2)\n\n# Logical operation\nx == 2  # equivalent to...#> [1] FALSE FALSE  TRUE  TRUE\nx == c(2, 2, 2, 2)#> [1] FALSE FALSE  TRUE  TRUE\n# String operation\nlong <- c(\"a\", \"b\", \"c\")\nshort <- \"1\"\npaste0(\"a\", \"1\")#> [1] \"a1\"\npaste0(long, short)#> [1] \"a1\" \"b1\" \"c1\""},{"path":"ch02.html","id":"coercion","chapter":"2 Base R (I) & 輔助工具","heading":"2.6 Coercion","text":"vector 內的每個元素，其資料類型 (data type) 必須相同。資料類型即是前面提到的 integer, double, character, logical。vector 內的每個元素，其資料類型 (data type) 必須相同。資料類型即是前面提到的 integer, double, character, logical。若發生資料類型不一致的情形 (e.g. 將不同資料類型的元素放入 c())，R 會根據某些規則，自動進行資料類型的轉換。這個過程在 R 裡面稱為 Coercion\n\nc(TRUE, FALSE, 3)      # logical & numeric\n#> [1] 1 0 3\n\nc(-1, \"aa\")            # numeric & character\n#> [1] \"-1\" \"aa\"\n\nc(FALSE, TRUE, \"hi!\")  # logical & character\n#> [1] \"FALSE\" \"TRUE\"  \"hi!\"\n\nc(TRUE, 0, \"hi!\")      # logical & numeric & character\n#> [1] \"TRUE\" \"0\"    \"hi!\"若發生資料類型不一致的情形 (e.g. 將不同資料類型的元素放入 c())，R 會根據某些規則，自動進行資料類型的轉換。這個過程在 R 裡面稱為 Coercion\nFigure 2.1: Rules Coercion\ncoercion failed, throw errorif coercion failed, throw errormanual coercion: .character(), .logical(), .numeric()manual coercion: .character(), .logical(), .numeric()","code":"\nc(TRUE, FALSE, 3)      # logical & numeric#> [1] 1 0 3\nc(-1, \"aa\")            # numeric & character#> [1] \"-1\" \"aa\"\nc(FALSE, TRUE, \"hi!\")  # logical & character#> [1] \"FALSE\" \"TRUE\"  \"hi!\"\nc(TRUE, 0, \"hi!\")      # logical & numeric & character#> [1] \"TRUE\" \"0\"    \"hi!\"\nsum(c(T, T, T, F))#> [1] 3\ngender <- c(\"male\", \"female\", \"male\", \"female\")\nsum(gender == \"male\")  # num of male#> [1] 2\nmean(gender == \"male\")  # proportion of male#> [1] 0.5"},{"path":"ch02.html","id":"subsetting-a-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.7 Subsetting a vector","text":"有 3 種方法可用於取出 vector 裡面的元素 (回傳一個新的 vector)\n透過提供 vector 中元素的位置次序 (index)\n透過一個與此 vector 等長的 logical vector。在 logical vector 中的相對應位置，以 TRUE 或 FALSE 表示是否保留該位置的元素\n透過提供元素的「名字」(.e. names 屬性)\n透過提供 vector 中元素的位置次序 (index)透過一個與此 vector 等長的 logical vector。在 logical vector 中的相對應位置，以 TRUE 或 FALSE 表示是否保留該位置的元素透過提供元素的「名字」(.e. names 屬性)","code":""},{"path":"ch02.html","id":"index-subsetting","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.1 index subsetting","text":"","code":"\n# z[<integer_vector>]\nLETTERS  # R 內建變數: 包含所有大寫英文字母的 character vector#>  [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\nLETTERS[1]#> [1] \"A\"\nLETTERS[1:5]#> [1] \"A\" \"B\" \"C\" \"D\" \"E\"\nLETTERS[c(1, 3, 5)]#> [1] \"A\" \"C\" \"E\"\nLETTERS[-(1:5)]  # Exclude the first 5 elements#>  [1] \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\" \"T\" \"U\" \"V\" \"W\" \"X\"\n#> [20] \"Y\" \"Z\""},{"path":"ch02.html","id":"logical-subsetting","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.2 Logical subsetting","text":"","code":"\n# z[<logical_vector of length(z)>]\nage <- c(21, 20, 18, 19)\nage[c(FALSE, TRUE, FALSE, TRUE)]#> [1] 20 19\n## Creating logical vectors\nage[1] < 20  # returns a logical vector of length 1#> [1] FALSE\nage < 20     # returns a logical vector of length(x)#> [1] FALSE FALSE  TRUE  TRUE\n# Subset a vector using a logical test\nage[age < 20]#> [1] 18 19"},{"path":"ch02.html","id":"subsetting-with-names","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.3 Subsetting with names","text":"","code":"\nage <- c(40, 20, 18, 19)\nnames(age) <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\n# age <- c(kai = 40, pooh = 20, tiger = 18, piglet = 19)  # another way of setting names\n\nage#>    kai   pooh  tiger piglet \n#>     40     20     18     19\nage['kai'] + 9#> kai \n#>  49\nage[c('pooh', 'kai')]#> pooh  kai \n#>   20   40"},{"path":"ch02.html","id":"modifying-values-in-vector","chapter":"2 Base R (I) & 輔助工具","heading":"2.7.4 Modifying Values in vector","text":"","code":"\na2z <- LETTERS\na2z[1:3] <- c(\"a\", \"b\", \"c\")\na2z#>  [1] \"a\" \"b\" \"c\" \"D\" \"E\" \"F\" \"G\" \"H\" \"I\" \"J\" \"K\" \"L\" \"M\" \"N\" \"O\" \"P\" \"Q\" \"R\" \"S\"\n#> [20] \"T\" \"U\" \"V\" \"W\" \"X\" \"Y\" \"Z\"\ngender <- c(\"m\", \"m\", \"f\", \"f\")\ngender[gender == \"m\"] <- \"male\"\ngender#> [1] \"male\" \"male\" \"f\"    \"f\"\ngender[gender == \"f\"] <- \"female\"\ngender#> [1] \"male\"   \"male\"   \"female\" \"female\"\nnames(gender) <- c(\"john\", \"jenny\", \"jane\", \"kate\")\ngender#>     john    jenny     jane     kate \n#>   \"male\"   \"male\" \"female\" \"female\"\ngender[\"john\"] <- \"male\"\ngender#>     john    jenny     jane     kate \n#>   \"male\"   \"male\" \"female\" \"female\"\ngender[c(\"jenny\", \"jane\", \"kate\")] <- \"female\"\ngender#>     john    jenny     jane     kate \n#>   \"male\" \"female\" \"female\" \"female\""},{"path":"ch02.html","id":"if-else","chapter":"2 Base R (I) & 輔助工具","heading":"2.8 if else","text":"一般而言，R 是由上至下一行一行地執行程式碼。有時候我們會希望能跳過某些程式碼或是依據不同的狀況執行不同的程式碼，這時候我們就需要使用條件式。在 -else -else 的結構中，只有其中一個區塊 (被大括弧 {} 包裹的程式碼) 會被執行。執行完該區塊後，就會忽略剩下的條件控制區塊，執行條件式之後的程式碼。在 -else -else 的結構中，只有其中一個區塊 (被大括弧 {} 包裹的程式碼) 會被執行。執行完該區塊後，就會忽略剩下的條件控制區塊，執行條件式之後的程式碼。可以在 之後使用多個 else .可以在 之後使用多個 else .條件式的結構：\n# 只有 \n(<條件>) {\n    <Code>  # 條件成立時執行\n}\n\n# , else\n(<條件>) {\n    <Code>  # <條件>成立時執行\n} else {\n    <Code>  # <條件>不成立時執行\n}\n\n# , else , else\n(<條件1>) {\n    <Code>          # <條件1>成立時執行\n} else ( <條件2> ) {\n    <Code>          # <條件1>不成立、<條件2>成立時執行\n} else {\n    <Code>          # <條件1>、<條件2>皆不成立時執行\n}條件式的結構：","code":"\nx <- 1\n\nif (x > 0) {\n    print('x is positive')\n} else {\n    print('x is not positive')\n}#> [1] \"x is positive\"\nx <- -1\n\nif (x > 0) {\n    print('x is positive')\n} else if (x < 0) {\n    print('x is negative')\n} else {\n    print('x is zero')\n}\n\nprint('This is always printed')#> [1] \"x is negative\"\n#> [1] \"This is always printed\"# 只有 if\nif (<條件>) {\n    <Some Code>  # 條件成立時執行\n}\n\n# if, else\nif (<條件>) {\n    <Some Code>  # <條件>成立時執行\n} else {\n    <Some Code>  # <條件>不成立時執行\n}\n\n# if, else if, else\nif (<條件1>) {\n    <Some Code>          # <條件1>成立時執行\n} else if ( <條件2> ) {\n    <Some Code>          # <條件1>不成立、<條件2>成立時執行\n} else {\n    <Some Code>          # <條件1>、<條件2>皆不成立時執行\n}"},{"path":"ch02.html","id":"wrap-up","chapter":"2 Base R (I) & 輔助工具","heading":"2.9 Wrap up: 句子產生器","text":"","code":"\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)\n\n# Randomly draw 2 subjects\nwho <- sample(1:4, size = 2)\n\n# Find out who is older\nage1 <- age[who[1]]\nage2 <- age[who[2]]\nif (age1 > age2) {\n    comparitive <- ' is older than '\n} else if (age1 < age2) {\n    comparitive <- ' is younger than '\n} else {\n    comparitive <- ' is as old as '\n}\n\n# Construct sentence\npaste0(name[who[1]], comparitive, name[who[2]])#> [1] \"pooh is younger than kai\""},{"path":"ch02.html","id":"r-markdown","chapter":"2 Base R (I) & 輔助工具","heading":"2.10 R Markdown","text":"使用前需先安裝 rmarkdown:\n\ninstall.packages('rmarkdown')使用前需先安裝 rmarkdown:R Markdown (.Rmd) 就像之前同學用來寫自我介紹的 Markdown 文件 (.md) 一樣是一種純文字格式。R Markdown 的語法其實只是 Markdown 的一種擴充：它新增了一些特殊的語法，讓使用者可以直接在 R Markdown 裡面撰寫程式碼，並透過 R 將這些程式碼的運算結果插入 R Markdown 的輸出文件當中。R Markdown (.Rmd) 就像之前同學用來寫自我介紹的 Markdown 文件 (.md) 一樣是一種純文字格式。R Markdown 的語法其實只是 Markdown 的一種擴充：它新增了一些特殊的語法，讓使用者可以直接在 R Markdown 裡面撰寫程式碼，並透過 R 將這些程式碼的運算結果插入 R Markdown 的輸出文件當中。knitr Code Chunk\n執行：由上至下執行\n後面的 chunk 可以讀取之前的 chunks 產生的變數\nknitr Code Chunk執行：由上至下執行後面的 chunk 可以讀取之前的 chunks 產生的變數(在 RStudio 使用 R Markdown)使用 RStudio 開啟 R Markdown (.Rmd) 時，Rmd 檔會出現在 Source Pane 讓使用者編輯使用 RStudio 開啟 R Markdown (.Rmd) 時，Rmd 檔會出現在 Source Pane 讓使用者編輯將 R Markdown (.Rmd) 輸出 (knit )成 HTML 檔 (.html):將 R Markdown (.Rmd) 輸出 (knit )成 HTML 檔 (.html):\nFigure 2.2: R Markdown document RStudio10.\n","code":"\ninstall.packages('rmarkdown')"},{"path":"ch02.html","id":"參考資源","chapter":"2 Base R (I) & 輔助工具","heading":"參考資源","text":"Grolemund, G. (2014). Hands-programming R\nR Objects (https://rstudio-education.github.io/hopr/r-objects)\nModifying Values (https://rstudio-education.github.io/hopr/modify)Grolemund, G. (2014). Hands-programming R\nR Objects (https://rstudio-education.github.io/hopr/r-objects)\nModifying Values (https://rstudio-education.github.io/hopr/modify)Xie, Y., Allaire, J., & Grolemund, G. (2019). R Markdown: Definitive GuideXie, Y., Allaire, J., & Grolemund, G. (2019). R Markdown: Definitive Guide","code":""},{"path":"ch03.html","id":"ch03","chapter":"3 Base R (II)","heading":"3 Base R (II)","text":"(投影片 /\n程式碼 /\n影片)","code":""},{"path":"ch03.html","id":"list","chapter":"3 Base R (II)","heading":"3.1 list","text":"vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存不同資料類型或是具有階層結構的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。vector 是 R 裡面最「簡單」的資料結構。有時候我們需要比較更複雜的資料結構處理我們遇到的資料，例如，我們或許需要儲存不同資料類型或是具有階層結構的資料。面對這兩種需求，vector 無能為力，因此需要用到 R 的 list。R 可以透過 list() 去製造出 list。list() 的使用方式很類似用來製造 vector 的 c()，但與 c() 不同的是，list()\n能使用不同的資料類型\n\nlist(TRUE, 1:3, \"Hello\")\n#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\n\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")\n#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"\n具有階層結構，亦即，list() 裡面可以放入另一個 list()\n\nlist(1.1, list(2.1, \"Hello\"))\n#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\"\nR 可以透過 list() 去製造出 list。list() 的使用方式很類似用來製造 vector 的 c()，但與 c() 不同的是，list()能使用不同的資料類型\n\nlist(TRUE, 1:3, \"Hello\")\n#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\n\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")\n#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"能使用不同的資料類型具有階層結構，亦即，list() 裡面可以放入另一個 list()\n\nlist(1.1, list(2.1, \"Hello\"))\n#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\"具有階層結構，亦即，list() 裡面可以放入另一個 list()","code":"\nlist(TRUE, 1:3, \"Hello\")#> [[1]]\n#> [1] TRUE\n#> \n#> [[2]]\n#> [1] 1 2 3\n#> \n#> [[3]]\n#> [1] \"Hello\"\nlist('kai' = TRUE, 'pooh' = 1:3, 'tiger' = \"Hello\")#> $kai\n#> [1] TRUE\n#> \n#> $pooh\n#> [1] 1 2 3\n#> \n#> $tiger\n#> [1] \"Hello\"\nlist(1.1, list(2.1, \"Hello\"))#> [[1]]\n#> [1] 1.1\n#> \n#> [[2]]\n#> [[2]][[1]]\n#> [1] 2.1\n#> \n#> [[2]][[2]]\n#> [1] \"Hello\""},{"path":"ch03.html","id":"subsetting","chapter":"3 Base R (II)","heading":"3.1.1 Subsetting","text":"通常我們會習慣為 list 加上名字 (names)，幫助我們更容易處理這種比較複雜的資料結構通常我們會習慣為 list 加上名字 (names)，幫助我們更容易處理這種比較複雜的資料結構[]: 與 vector 一樣，我們可以透過 lst[<char vector names>]、lst[<integer vector>] 或 lst[<logical vector>] 去 subset list\n\npooh <- list(age = 20, single = FALSE, tags = c(\"ig\", \"selfie\"))\npooh['single']\n#> $single\n#> [1] FALSE\n\npooh[2:3]\n#> $single\n#> [1] FALSE\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n\npooh[c(TRUE, FALSE, TRUE)]\n#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"[]: 與 vector 一樣，我們可以透過 lst[<char vector names>]、lst[<integer vector>] 或 lst[<logical vector>] 去 subset list就像 vec[<vector>] 會回傳一部分的 vector (sub-vector)；lst[<vector>] 也會回傳一部分的 list (sub-list)。換言之，使用 [] 時，回傳值的資料結構不會改變。就像 vec[<vector>] 會回傳一部分的 vector (sub-vector)；lst[<vector>] 也會回傳一部分的 list (sub-list)。換言之，使用 [] 時，回傳值的資料結構不會改變。我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂裡面是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 []；欲取得 sub-list 裡面的值 (.e. 脫去外層的 list)，需使用 [[]]\n\n# 回傳 sub-list\ntypeof(pooh[\"tags\"])\npooh[\"tags\"]\n\n# 回傳 list 之內的「值」，在此為一個 char vector\ntypeof(pooh[[\"tags\"]])\npooh[[\"tags\"]]\n#> [1] \"list\"\n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"character\"\n#> [1] \"ig\"     \"selfie\"\nlst[[\"<name>\"]] 有另一種更簡便的寫法：lst$<name>, e.g. pooh[[\"tags\"]] 可改寫成 pooh$tags\n我們可以將 list 想像成一列火車，每節車廂是一個長度為 1 的 sub-list，車廂裡面是這個 sub-list 儲存的值。欲取得 sub-list，使用的是 []；欲取得 sub-list 裡面的值 (.e. 脫去外層的 list)，需使用 [[]]lst[[\"<name>\"]] 有另一種更簡便的寫法：lst$<name>, e.g. pooh[[\"tags\"]] 可改寫成 pooh$tags\nFigure 3.1: List train\n","code":"\npooh <- list(age = 20, single = FALSE, tags = c(\"ig\", \"selfie\"))\npooh['single']#> $single\n#> [1] FALSE\npooh[2:3]#> $single\n#> [1] FALSE\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\npooh[c(TRUE, FALSE, TRUE)]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n# 回傳 sub-list\ntypeof(pooh[\"tags\"])\npooh[\"tags\"]\n\n# 回傳 list 之內的「值」，在此為一個 char vector\ntypeof(pooh[[\"tags\"]])\npooh[[\"tags\"]]#> [1] \"list\"\n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"character\"\n#> [1] \"ig\"     \"selfie\""},{"path":"ch03.html","id":"nested-structure","chapter":"3 Base R (II)","heading":"3.1.2 Nested Structure","text":"","code":"\na_lst <- list(name = \"pooh\",\n              info = list(age = 20,\n                          tags = c(\"ig\", \"selfie\")))\n\n# Get \"selfie\"  \na_lst[['info']]\na_lst[['info']][['tags']]\na_lst[['info']][['tags']][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# Another way to get \"selfie\"\na_lst['info'][[1]]\na_lst['info'][[1]]['tags'][[1]]\na_lst['info'][[1]]['tags'][[1]][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# Yet another way to get \"selfie\"\na_lst[[2]]\na_lst[[2]][[2]]\na_lst[[2]][[2]][2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\"\n# The most 'readable' way to get \"selfie\"\na_lst$info\na_lst$info$tags\na_lst$info$tags[2]#> $age\n#> [1] 20\n#> \n#> $tags\n#> [1] \"ig\"     \"selfie\"\n#> \n#> [1] \"ig\"     \"selfie\"\n#> [1] \"selfie\""},{"path":"ch03.html","id":"for-loop","chapter":"3 Base R (II)","heading":"3.2 for loop","text":"上週介紹的條件式 (-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。上週介紹的條件式 (-else) 讓我們可以依據不同狀況執行不同的程式碼，藉此能幫助我們寫出更有彈性的程式。迴圈讓我們能重複執行某一區塊的程式碼，如此就不需要重複寫出相同的程式碼。R 有 與 迴圈。一般而言，在資料分析時非常少會用到 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。R 有 與 迴圈。一般而言，在資料分析時非常少會用到 迴圈，因此實習課不作介紹，有興趣的同學可自行參考線上教材或教科書。loop 的結構如下\n(<變數> <vector>) {\n    <code>\n}loop 的結構如下for loop 會使 {} 內的程式碼重複執行數次，其次數等於 <vector> 的長度；並且，在第 n 次開始執行 {} 內的程式碼前，會將 <vector> 裡的第 n 個元素指派給 <變數>。所以在第一次迴圈時，可透過 <變數> 取得 <vector> 中的第一個元素；在第二次迴圈時，可取得 <vector> 中的第二個元素；依此類推，最後一次迴圈則可以透過 <變數> 取得 <vector> 中的最後一個元素。loop 會使 {} 內的程式碼重複執行數次，其次數等於 <vector> 的長度；並且，在第 n 次開始執行 {} 內的程式碼前，會將 <vector> 裡的第 n 個元素指派給 <變數>。所以在第一次迴圈時，可透過 <變數> 取得 <vector> 中的第一個元素；在第二次迴圈時，可取得 <vector> 中的第二個元素；依此類推，最後一次迴圈則可以透過 <變數> 取得 <vector> 中的最後一個元素。","code":"for (<變數> in <vector>) {\n    <some code>\n}\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n  \nfor (word in vec) {\n    # Will execute 4 times, \n    # each time a new value from `vec` will be assigned to `word`\n    print(word)\n}#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\""},{"path":"ch03.html","id":"for-loop-的各種型態","chapter":"3 Base R (II)","heading":"3.2.1 for loop 的各種型態","text":"R 的 只有一種結構：每次疊代將 vector (或 list) 中的一個元素指派給變數 (<var> <vector>)。但因為 R 向量式程式語言的特性，R 的 迴圈很容易改寫成其它更方便的型態。有時候我們需要知道迴圈進行到 <vector> 的第幾個元素，這時候通常會使用 seq_along(<vector>) 去製造出與 <vector> 等長的整數序列 (e.g. seq_along(c('', 'b', 'c')) 會回傳 1 2 3)，如此我們便可知道進行到第幾次迴圈，也可透過 <vector>[] 取得與該次迴圈對應的元素。\n\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n(seq_along(vec)) {\n    print(paste(, vec[]))\n}\n#> [1] \"1 謝\"\n#> [1] \"2 老師\"\n#> [1] \"3 好\"\n#> [1] \"4 帥\"\n\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\n(seq_along(vec)) {\n    print(vec[])\n\n    # Print `?` last loop\n    (== length(vec)) {\n        print('?')\n    }\n}\n#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\"\n#> [1] \"?\"有時候我們需要知道迴圈進行到 <vector> 的第幾個元素，這時候通常會使用 seq_along(<vector>) 去製造出與 <vector> 等長的整數序列 (e.g. seq_along(c('', 'b', 'c')) 會回傳 1 2 3)，如此我們便可知道進行到第幾次迴圈，也可透過 <vector>[] 取得與該次迴圈對應的元素。我們也可以透過 names() 在 loop 裡使用 <vector> 的 names 屬性：\n\nvec <- c(Monday = \"rainy\", Tuesday = \"cloudy\", Wednesday = \"sunny\")\n(name names(vec)) {\n    print(paste0(name, ' ', vec[name], '.'))\n}\n#> [1] \"Monday rainy.\"\n#> [1] \"Tuesday cloudy.\"\n#> [1] \"Wednesday sunny.\"我們也可以透過 names() 在 loop 裡使用 <vector> 的 names 屬性：常常我們會需要對 loop 有「更多的控制」。前面在 loop 中使用到條件式即是一個例子。但常常條件式本身的功能並不足夠：執行迴圈時，在符合特定條件下，有時候我們會希望能忽略一次迴圈中「所有尚未被執行的程式碼」，這時就會使用到 next:\n\n# 使用 next '忽略一次' 迴圈\n(1:10) {\n    (== 5) {\n        print(\"Skipping print() == 5\")\n        next\n    }\n    print()\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Skipping print() == 5\"\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10有時候我們會希望能忽略一次迴圈中「所有尚未被執行的程式碼」，這時就會使用到 next:有時我們需要跳出整個迴圈，亦即不再執行 loop 裡面的程式碼。這時就會使用到 break:\n\n# 使用 break 跳出整個迴圈\n(1:10) {\n    (== 5) {\n        print(\"Breaking loop\")\n        break\n    }\n    print()\n}\n#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Breaking loop\"有時我們需要跳出整個迴圈，亦即不再執行 loop 裡面的程式碼。這時就會使用到 break:下方的程式碼能將多個檔案 (圖片) 重新命名 (並透過 next 忽略某些檔案)。有興趣者請下載原始碼，裡面有一個資料夾 dice/。執行此程式碼前，需將工作目錄設至 dice/ 資料夾。","code":"\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\nfor (i in seq_along(vec)) {\n    print(paste(i, vec[i]))\n}#> [1] \"1 謝\"\n#> [1] \"2 老師\"\n#> [1] \"3 好\"\n#> [1] \"4 帥\"\nvec <- c(\"謝\", \"老師\", \"好\", \"帥\")\nfor (i in seq_along(vec)) {\n    print(vec[i])\n\n    # Print `?` in the last loop\n    if (i == length(vec)) {\n        print('?')\n    }\n}#> [1] \"謝\"\n#> [1] \"老師\"\n#> [1] \"好\"\n#> [1] \"帥\"\n#> [1] \"?\"\nvec <- c(Monday = \"rainy\", Tuesday = \"cloudy\", Wednesday = \"sunny\")\nfor (name in names(vec)) {\n    print(paste0(name, ' was ', vec[name], '.'))\n}#> [1] \"Monday was rainy.\"\n#> [1] \"Tuesday was cloudy.\"\n#> [1] \"Wednesday was sunny.\"\n# 使用 next '忽略一次' 迴圈\nfor (i in 1:10) {\n    if (i == 5) {\n        print(\"Skipping print(i) if i == 5\")\n        next\n    }\n    print(i)\n}#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Skipping print(i) if i == 5\"\n#> [1] 6\n#> [1] 7\n#> [1] 8\n#> [1] 9\n#> [1] 10\n# 使用 break 跳出整個迴圈\nfor (i in 1:10) {\n    if (i == 5) {\n        print(\"Breaking out the for loop\")\n        break\n    }\n    print(i)\n}#> [1] 1\n#> [1] 2\n#> [1] 3\n#> [1] 4\n#> [1] \"Breaking out the for loop\"\nfor (file in list.files()) {\n    # 忽略 `00_not_an_img.txt` 這個檔案\n    if (file == '00_not_an_img.txt') {\n        next\n    }\n    \n    file.rename(from = file, to = paste0('dice-', file))\n}"},{"path":"ch03.html","id":"實際應用修改檔案名稱","chapter":"3 Base R (II)","heading":"3.2.2 實際應用：修改檔案名稱","text":"下方的程式碼能將多個檔案 (圖片) 重新命名 (並透過 next 忽略某些檔案)。有興趣者請下載原始碼，裡面有一個資料夾 dice/。執行此程式碼前，需將工作目錄設至 dice/ 資料夾。","code":"\nfor (file in list.files()) {\n    # 忽略 `00_not_an_img.txt` 這個檔案\n    if (file == '00_not_an_img.txt') {\n        next\n    }\n    \n    file.rename(from = file, to = paste0('dice-', file))\n}"},{"path":"ch03.html","id":"wrap-upfor-loop-與-list","chapter":"3 Base R (II)","heading":"3.3 Wrap up：for loop 與 list","text":"上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人\n(“kai”, “pooh”, “tiger”, “piglet”)\n的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (name 與 age) 分開來儲存在獨立的 vector。\n\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)上週我們使用過 3 個長度為 4 的 vector 來儲存關於 4 個人\n(“kai”, “pooh”, “tiger”, “piglet”)\n的資料。但使用這種方式儲存資料似乎有些違反直覺，因為它將關於一個人的資訊 (name 與 age) 分開來儲存在獨立的 vector。對於這種彼此之間具有關聯的資料，一種更好的方式是將它們儲存在一起，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 list 去改寫上週的資料：\n\nmember <- list(\n    list(name = \"kai\", age = 40),\n    list(name = \"pooh\", age = 20),\n    list(name = \"tiger\", age = 18),\n    list(name = \"piglet\", age = 19)\n)\n\nmember\n#> [[1]]\n#> [[1]]$name\n#> [1] \"kai\"\n#> \n#> [[1]]$age\n#> [1] 40\n#> \n#> \n#> [[2]]\n#> [[2]]$name\n#> [1] \"pooh\"\n#> \n#> [[2]]$age\n#> [1] 20\n#> \n#> \n#> [[3]]\n#> [[3]]$name\n#> [1] \"tiger\"\n#> \n#> [[3]]$age\n#> [1] 18\n#> \n#> \n#> [[4]]\n#> [[4]]$name\n#> [1] \"piglet\"\n#> \n#> [[4]]$age\n#> [1] 19\n\n(person member) {\n    name <- person$name\n    age <- person$age\n\n    # 將組成句子的片語儲存於 char vector `phrases`\n    phrases <- c(name, \" \", age)\n    (age < 35) {\n        phrases[4] <- \", quite young\"\n    }\n\n    # 將各片語連接起來成為一個句子\n    sentence <- paste0(phrases,  collapse = '')\n\n    print(sentence)\n}\n#> [1] \"kai 40\"\n#> [1] \"pooh 20, quite young\"\n#> [1] \"tiger 18, quite young\"\n#> [1] \"piglet 19, quite young\"對於這種彼此之間具有關聯的資料，一種更好的方式是將它們儲存在一起，因為這不只幫助我們在「程式上」更容易去操弄這筆資料，更讓我們能以「階層組織」去「想像」我們的資料。這裡我們使用 list 去改寫上週的資料：","code":"\n# Data\nname <- c(\"kai\", \"pooh\", \"tiger\", \"piglet\")\nage <- c(40, 20, 18, 19)\nmember <- list(\n    list(name = \"kai\", age = 40),\n    list(name = \"pooh\", age = 20),\n    list(name = \"tiger\", age = 18),\n    list(name = \"piglet\", age = 19)\n)\n\nmember#> [[1]]\n#> [[1]]$name\n#> [1] \"kai\"\n#> \n#> [[1]]$age\n#> [1] 40\n#> \n#> \n#> [[2]]\n#> [[2]]$name\n#> [1] \"pooh\"\n#> \n#> [[2]]$age\n#> [1] 20\n#> \n#> \n#> [[3]]\n#> [[3]]$name\n#> [1] \"tiger\"\n#> \n#> [[3]]$age\n#> [1] 18\n#> \n#> \n#> [[4]]\n#> [[4]]$name\n#> [1] \"piglet\"\n#> \n#> [[4]]$age\n#> [1] 19\nfor (person in member) {\n    name <- person$name\n    age <- person$age\n\n    # 將組成句子的片語儲存於 char vector `phrases`\n    phrases <- c(name, \" is \", age)\n    if (age < 35) {\n        phrases[4] <- \", which is quite young\"\n    }\n\n    # 將各片語連接起來成為一個句子\n    sentence <- paste0(phrases,  collapse = '')\n\n    print(sentence)\n}#> [1] \"kai is 40\"\n#> [1] \"pooh is 20, which is quite young\"\n#> [1] \"tiger is 18, which is quite young\"\n#> [1] \"piglet is 19, which is quite young\""},{"path":"ch03.html","id":"data-frame","chapter":"3 Base R (II)","heading":"3.4 data frame","text":"data frame 是 R 語言非常重要的資料結構，它造就了 R 強大的表格式資料處理能力data frame 是 R 語言非常重要的資料結構，它造就了 R 強大的表格式資料處理能力data frame 是一種二維的資料結構。這種資料結構基本上與我們熟悉的 Excel (或 google 試算表) 非常類似：\n\n\nFigure 3.2: data frame looks like Excel Spreadsheet\n\n\ndata frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)\ndata frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)\ndata frame 是一種二維的資料結構。這種資料結構基本上與我們熟悉的 Excel (或 google 試算表) 非常類似：\nFigure 3.2: data frame looks like Excel Spreadsheet\ndata frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)data frame 的每一橫列 (row) 皆是一筆資料 (e.g. 一位受訪者所填的問卷)data frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)data frame 的每一 (直) 欄 (column) 代表一個變項 (e.g. 問卷上的某個題目)\nFigure 3.3: Data Frame\n我們可以使用 tibble 套件的 tibble()11 建立 data frame。上圖中的 data frame 例子即可由下方的程式碼所建立:\n\nlibrary(tibble)\n\ndf <- tibble(name = c(\"kai\", \"pooh\", \"tiger\", \"piglet\"),\n             age  = c(40, 20, 18, 19), \n             grad = c(FALSE, TRUE, FALSE, TRUE))\ndf\n#> # tibble: 4 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 kai       40 FALSE\n#> 2 pooh      20 TRUE \n#> 3 tiger     18 FALSE\n#> 4 piglet    19 TRUE\ntibble() 裡的每個 vector 對映到 data frame 中的一欄 (column)。因此 data frame 中不同欄的資料類型可能不同，但每一欄 (變項) 內的資料類型必須相同 (因為 vector 只能儲存相同的資料類型)。\n我們可以使用 tibble 套件的 tibble()11 建立 data frame。上圖中的 data frame 例子即可由下方的程式碼所建立:tibble() 裡的每個 vector 對映到 data frame 中的一欄 (column)。因此 data frame 中不同欄的資料類型可能不同，但每一欄 (變項) 內的資料類型必須相同 (因為 vector 只能儲存相同的資料類型)。下方的指令可用於檢視 data frame 的資訊\n\nnrow(df)   # number rows\nncol(df)   # number columns\ndim(df)    # 形狀 (num rows, num columns)\nnames(df)  # name column\n#> [1] 4\n#> [1] 3\n#> [1] 4 3\n#> [1] \"name\" \"age\"  \"grad\"\n\ntibble::glimpse(df)  # 關於 df 的各種資訊\n#> Rows: 4\n#> Columns: 3\n#> $ name <chr> \"kai\", \"pooh\", \"tiger\", \"piglet\"\n#> $ age  <dbl> 40, 20, 18, 19\n#> $ grad <lgl> FALSE, TRUE, FALSE, TRUE\n\nstr(df)              # 也可用 Base R 內建函數: str()\n#> tibble [4 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ name: chr [1:4] \"kai\" \"pooh\" \"tiger\" \"piglet\"\n#>  $ age : num [1:4] 40 20 18 19\n#>  $ grad: logi [1:4] FALSE TRUE FALSE TRUE\n\nView(df)   # View data frame RStudio source pane下方的指令可用於檢視 data frame 的資訊","code":"\nlibrary(tibble)\n\ndf <- tibble(name = c(\"kai\", \"pooh\", \"tiger\", \"piglet\"),\n             age  = c(40, 20, 18, 19), \n             grad = c(FALSE, TRUE, FALSE, TRUE))\ndf#> # A tibble: 4 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 kai       40 FALSE\n#> 2 pooh      20 TRUE \n#> 3 tiger     18 FALSE\n#> 4 piglet    19 TRUE\nnrow(df)   # number of rows\nncol(df)   # number of columns\ndim(df)    # 形狀 (num of rows, num of columns)\nnames(df)  # name of each column#> [1] 4\n#> [1] 3\n#> [1] 4 3\n#> [1] \"name\" \"age\"  \"grad\"\ntibble::glimpse(df)  # 關於 df 的各種資訊#> Rows: 4\n#> Columns: 3\n#> $ name <chr> \"kai\", \"pooh\", \"tiger\", \"piglet\"\n#> $ age  <dbl> 40, 20, 18, 19\n#> $ grad <lgl> FALSE, TRUE, FALSE, TRUE\nstr(df)              # 也可用 Base R 內建函數: str()#> tibble [4 × 3] (S3: tbl_df/tbl/data.frame)\n#>  $ name: chr [1:4] \"kai\" \"pooh\" \"tiger\" \"piglet\"\n#>  $ age : num [1:4] 40 20 18 19\n#>  $ grad: logi [1:4] FALSE TRUE FALSE TRUE\nView(df)   # View data frame in RStudio source pane"},{"path":"ch03.html","id":"subsetting-returning-a-data-frame","chapter":"3 Base R (II)","heading":"3.4.1 Subsetting: returning a data frame","text":"data frame 的篩選 (subsetting) 與 vector 和 list 類似，差別只在於 data frame 屬於二維的資料結構，因此需要提供 2 個 vector 進行資料的篩選：\ndf[<vector 1>, <vector 2>]\n在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。\n以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])\ndata frame 的篩選 (subsetting) 與 vector 和 list 類似，差別只在於 data frame 屬於二維的資料結構，因此需要提供 2 個 vector 進行資料的篩選：在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。在這裡，<vector 1> 篩選的是「列 (row)」，亦即，<vector 1> 決定要篩選出哪幾個觀察值 (observations)。<vector 2> 篩選的則是「欄 (column)」，亦即，<vector 2> 決定要篩選出哪些變項 (variables)。以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])以這種語法進行篩選，回傳的一定是 data frame12，即使只有篩選出一個值 (e.g. df[1, 1])","code":"df[<vector 1>, <vector 2>]\ndf[2, 1]#> # A tibble: 1 x 1\n#>   name \n#>   <chr>\n#> 1 pooh\ndf[2, 1:2]  # df[2, c(\"name\", \"age\")]#> # A tibble: 1 x 2\n#>   name    age\n#>   <chr> <dbl>\n#> 1 pooh     20\ndf[2, ]#> # A tibble: 1 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 pooh     20 TRUE"},{"path":"ch03.html","id":"subsetting-returning-a-vector","chapter":"3 Base R (II)","heading":"3.4.2 Subsetting: returning a vector","text":"若想要從 data frame 裡面篩選出 vector (取得「火車車廂」內的值)，則要使用之前提過的 $ 或 [[]]:\n\ndf[[2]]      # df[[<column_index>]]\ndf[[\"age\"]]  # df[[\"<column_name>\"]]\ndf$age       # df$<column_name>, 最常見\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19若想要從 data frame 裡面篩選出 vector (取得「火車車廂」內的值)，則要使用之前提過的 $ 或 [[]]:篩選 data frame 而回傳 vector 是個很實用的技巧，因為我們可以使用這個回傳的 vector 當作我們進一步篩選 data frame 的依據，例如：\n\nover19 <- df$age > 19  \nover19\n#> [1]  TRUE  TRUE FALSE FALSE\n\n# subset df obs. 19\ndf[over19, ]\n#> # tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\n\n# subset df obs. equal 19\ndf[!over19, ]\n#> # tibble: 2 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 tiger     18 FALSE\n#> 2 piglet    19 TRUE\n\n# 合併起來寫 (最常見的寫法，但比較難讀懂)\ndf[df$age > 19, ]\n#> # tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE篩選 data frame 而回傳 vector 是個很實用的技巧，因為我們可以使用這個回傳的 vector 當作我們進一步篩選 data frame 的依據，例如：透過這個技巧，R 能幫助我們快速篩選出需要的資料，例如，我們可以結合 age 與 grad 兩個變項，篩選出「小於 20 歲且為研究所學生」的 data frame:\n\ndf[(df$age < 20) & (df$grad), ]\n#> # tibble: 1 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 piglet    19 TRUE透過這個技巧，R 能幫助我們快速篩選出需要的資料，例如，我們可以結合 age 與 grad 兩個變項，篩選出「小於 20 歲且為研究所學生」的 data frame:","code":"\ndf[[2]]      # df[[<column_index>]]\ndf[[\"age\"]]  # df[[\"<column_name>\"]]\ndf$age       # df$<column_name>, 最常見#> [1] 40 20 18 19\n#> [1] 40 20 18 19\n#> [1] 40 20 18 19\nover19 <- df$age > 19  \nover19#> [1]  TRUE  TRUE FALSE FALSE\n# subset df with obs. over 19\ndf[over19, ]#> # A tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\n# subset df with obs. below or equal 19\ndf[!over19, ]#> # A tibble: 2 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 tiger     18 FALSE\n#> 2 piglet    19 TRUE\n# 合併起來寫 (最常見的寫法，但比較難讀懂)\ndf[df$age > 19, ]#> # A tibble: 2 x 3\n#>   name    age grad \n#>   <chr> <dbl> <lgl>\n#> 1 kai      40 FALSE\n#> 2 pooh     20 TRUE\ndf[(df$age < 20) & (df$grad), ]#> # A tibble: 1 x 3\n#>   name     age grad \n#>   <chr>  <dbl> <lgl>\n#> 1 piglet    19 TRUE"}]
